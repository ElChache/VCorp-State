shadow$provide.module$node_modules$$xyflow$react$dist$umd$index = function(global, require, module, exports) {
  !function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports, require("module$node_modules$react$jsx_runtime"), require("module$node_modules$react$index"), require("module$node_modules$react_dom$index")) : "function" == typeof define && define.amd ? define(["exports", "react/jsx-runtime", "react", "react-dom"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).ReactFlow = {}, e.jsxRuntime, e.React, e.ReactDOM);
  }(this, function(e$jscomp$0, t, n$jscomp$0, o) {
    function r(e) {
      if ("string" == typeof e || "number" == typeof e) {
        return "" + e;
      }
      let t = "";
      if (Array.isArray(e)) {
        for (let n, o = 0; o < e.length; o++) {
          "" !== (n = r(e[o])) && (t += (t && " ") + n);
        }
      } else {
        for (let n in e) {
          e[n] && (t += (t && " ") + n);
        }
      }
      return t;
    }
    function a() {
      for (var e, t = 0, n = arguments.length, o = {}; t < n; ++t) {
        if (!(e = arguments[t] + "") || e in o || /[\s.]/.test(e)) {
          throw Error("illegal type: " + e);
        }
        o[e] = [];
      }
      return new s(o);
    }
    function s(e) {
      this._ = e;
    }
    function l(e, t) {
      for (var n, o = 0, r = e.length; o < r; ++o) {
        if ((n = e[o]).name === t) {
          return n.value;
        }
      }
    }
    function c(e, t, n) {
      for (var o = 0, r = e.length; o < r; ++o) {
        if (e[o].name === t) {
          e[o] = i;
          e = e.slice(0, o).concat(e.slice(o + 1));
          break;
        }
      }
      return null != n && e.push({name:t, value:n}), e;
    }
    function h(e) {
      var t = e += "", n = t.indexOf(":");
      return 0 <= n && "xmlns" !== (t = e.slice(0, n)) && (e = e.slice(n + 1)), d.hasOwnProperty(t) ? {space:d[t], local:e} : e;
    }
    function f(e) {
      return function() {
        var t = this.ownerDocument, n = this.namespaceURI;
        return "http://www.w3.org/1999/xhtml" === n && "http://www.w3.org/1999/xhtml" === t.documentElement.namespaceURI ? t.createElement(e) : t.createElementNS(n, e);
      };
    }
    function g(e) {
      return function() {
        return this.ownerDocument.createElementNS(e.space, e.local);
      };
    }
    function p(e) {
      e = h(e);
      return (e.local ? g : f)(e);
    }
    function m() {
    }
    function y(e) {
      return null == e ? m : function() {
        return this.querySelector(e);
      };
    }
    function v() {
      return [];
    }
    function x(e) {
      return null == e ? v : function() {
        return this.querySelectorAll(e);
      };
    }
    function w(e) {
      return function() {
        var t;
        return null == (t = e.apply(this, arguments)) ? [] : Array.isArray(t) ? t : Array.from(t);
      };
    }
    function b(e) {
      return function() {
        return this.matches(e);
      };
    }
    function S(e) {
      return function(t) {
        return t.matches(e);
      };
    }
    function E() {
      return this.firstElementChild;
    }
    function M() {
      return Array.from(this.children);
    }
    function N(e) {
      return Array(e.length);
    }
    function _(e, t) {
      this.ownerDocument = e.ownerDocument;
      this.namespaceURI = e.namespaceURI;
      this._next = null;
      this._parent = e;
      this.__data__ = t;
    }
    function P(e, t, n, o, r, i) {
      for (var a, s = 0, l = t.length, c = i.length; s < c; ++s) {
        (a = t[s]) ? (a.__data__ = i[s], o[s] = a) : n[s] = new _(e, i[s]);
      }
      for (; s < l; ++s) {
        (a = t[s]) && (r[s] = a);
      }
    }
    function z(e, t, n, o, r, i, a) {
      var s, l, c, u = new Map(), d = t.length, h = i.length, f = Array(d);
      for (s = 0; s < d; ++s) {
        (l = t[s]) && (f[s] = c = a.call(l, l.__data__, s, t) + "", u.has(c) ? r[s] = l : u.set(c, l));
      }
      for (s = 0; s < h; ++s) {
        c = a.call(e, i[s], s, i) + "", (l = u.get(c)) ? (o[s] = l, l.__data__ = i[s], u.delete(c)) : n[s] = new _(e, i[s]);
      }
      for (s = 0; s < d; ++s) {
        (l = t[s]) && u.get(f[s]) === l && (r[s] = l);
      }
    }
    function O(e) {
      return e.__data__;
    }
    function I(e) {
      return "object" == typeof e && "length" in e ? e : Array.from(e);
    }
    function A(e, t) {
      return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
    }
    function D(e) {
      return function() {
        this.removeAttribute(e);
      };
    }
    function R(e) {
      return function() {
        this.removeAttributeNS(e.space, e.local);
      };
    }
    function L(e, t) {
      return function() {
        this.setAttribute(e, t);
      };
    }
    function $(e, t) {
      return function() {
        this.setAttributeNS(e.space, e.local, t);
      };
    }
    function T(e, t) {
      return function() {
        var n = t.apply(this, arguments);
        null == n ? this.removeAttribute(e) : this.setAttribute(e, n);
      };
    }
    function V(e, t) {
      return function() {
        var n = t.apply(this, arguments);
        null == n ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
      };
    }
    function j(e) {
      return function() {
        this.style.removeProperty(e);
      };
    }
    function H(e, t, n) {
      return function() {
        this.style.setProperty(e, t, n);
      };
    }
    function Z(e, t, n) {
      return function() {
        var o = t.apply(this, arguments);
        null == o ? this.style.removeProperty(e) : this.style.setProperty(e, o, n);
      };
    }
    function X(e, t) {
      return e.style.getPropertyValue(t) || (e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView).getComputedStyle(e, null).getPropertyValue(t);
    }
    function Y(e) {
      return function() {
        delete this[e];
      };
    }
    function F(e, t) {
      return function() {
        this[e] = t;
      };
    }
    function W(e, t) {
      return function() {
        var n = t.apply(this, arguments);
        null == n ? delete this[e] : this[e] = n;
      };
    }
    function G(e) {
      return e.classList || new q(e);
    }
    function q(e) {
      this._node = e;
      this._names = (e.getAttribute("class") || "").trim().split(/^|\s+/);
    }
    function U(e, t) {
      e = G(e);
      for (var o = -1, r = t.length; ++o < r;) {
        e.add(t[o]);
      }
    }
    function Q(e, t) {
      e = G(e);
      for (var o = -1, r = t.length; ++o < r;) {
        e.remove(t[o]);
      }
    }
    function J(e) {
      return function() {
        U(this, e);
      };
    }
    function ee(e) {
      return function() {
        Q(this, e);
      };
    }
    function te(e, t) {
      return function() {
        (t.apply(this, arguments) ? U : Q)(this, e);
      };
    }
    function ne() {
      this.textContent = "";
    }
    function oe(e) {
      return function() {
        this.textContent = e;
      };
    }
    function re(e) {
      return function() {
        var t = e.apply(this, arguments);
        this.textContent = null == t ? "" : t;
      };
    }
    function ie() {
      this.innerHTML = "";
    }
    function ae(e) {
      return function() {
        this.innerHTML = e;
      };
    }
    function se(e) {
      return function() {
        var t = e.apply(this, arguments);
        this.innerHTML = null == t ? "" : t;
      };
    }
    function le() {
      this.nextSibling && this.parentNode.appendChild(this);
    }
    function ce() {
      this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function ue() {
      return null;
    }
    function de() {
      var e = this.parentNode;
      e && e.removeChild(this);
    }
    function he() {
      var e = this.cloneNode(!1), t = this.parentNode;
      return t ? t.insertBefore(e, this.nextSibling) : e;
    }
    function fe() {
      var e = this.cloneNode(!0), t = this.parentNode;
      return t ? t.insertBefore(e, this.nextSibling) : e;
    }
    function ge(e) {
      return function() {
        var t = this.__on;
        if (t) {
          for (var n, o = 0, r = -1, i = t.length; o < i; ++o) {
            n = t[o], e.type && n.type !== e.type || n.name !== e.name ? t[++r] = n : this.removeEventListener(n.type, n.listener, n.options);
          }
          ++r ? t.length = r : delete this.__on;
        }
      };
    }
    function pe(e, t, n) {
      return function() {
        var o, r = this.__on, i = function(e) {
          return function(t) {
            e.call(this, t, this.__data__);
          };
        }(t);
        if (r) {
          for (var a = 0, s = r.length; a < s; ++a) {
            if ((o = r[a]).type === e.type && o.name === e.name) {
              return this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = i, o.options = n), void(o.value = t);
            }
          }
        }
        this.addEventListener(e.type, i, n);
        o = {type:e.type, name:e.name, value:t, listener:i, options:n};
        r ? r.push(o) : this.__on = [o];
      };
    }
    function me(e, t, n) {
      var o = e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView, r = o.CustomEvent;
      "function" == typeof r ? r = new r(t, n) : (r = o.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1));
      e.dispatchEvent(r);
    }
    function ye(e, t) {
      return function() {
        return me(this, e, t);
      };
    }
    function ve(e, t) {
      return function() {
        return me(this, e, t.apply(this, arguments));
      };
    }
    function we(e, t) {
      this._groups = e;
      this._parents = t;
    }
    function be() {
      return new we([[document.documentElement]], xe);
    }
    function Se(e) {
      return "string" == typeof e ? new we([[document.querySelector(e)]], [document.documentElement]) : new we([[e]], xe);
    }
    function Ce(e$jscomp$0, t$jscomp$0) {
      var e = e$jscomp$0;
      let t;
      for (; t = e.sourceEvent;) {
        e = t;
      }
      if (e$jscomp$0 = e, void 0 === t$jscomp$0 && (t$jscomp$0 = e$jscomp$0.currentTarget), t$jscomp$0) {
        e = t$jscomp$0.ownerSVGElement || t$jscomp$0;
        if (e.createSVGPoint) {
          return e = e.createSVGPoint(), e.x = e$jscomp$0.clientX, e.y = e$jscomp$0.clientY, [(e = e.matrixTransform(t$jscomp$0.getScreenCTM().inverse())).x, e.y];
        }
        if (t$jscomp$0.getBoundingClientRect) {
          return e = t$jscomp$0.getBoundingClientRect(), [e$jscomp$0.clientX - e.left - t$jscomp$0.clientLeft, e$jscomp$0.clientY - e.top - t$jscomp$0.clientTop];
        }
      }
      return [e$jscomp$0.pageX, e$jscomp$0.pageY];
    }
    function Ne(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    function _e(e) {
      var t = e.document.documentElement;
      e = Se(e).on("dragstart.drag", Ne, ke);
      "onselectstart" in t ? e.on("selectstart.drag", Ne, ke) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
    }
    function Pe(e, t) {
      var n = e.document.documentElement, o = Se(e).on("dragstart.drag", null);
      t && (o.on("click.drag", Ne, ke), setTimeout(function() {
        o.on("click.drag", null);
      }, 0));
      "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
    }
    function Oe(e, {sourceEvent:t, subject:n, target:o, identifier:r, active:i, x:a, y:s, dx:l, dy:c, dispatch:u}) {
      Object.defineProperties(this, {type:{value:e, enumerable:!0, configurable:!0}, sourceEvent:{value:t, enumerable:!0, configurable:!0}, subject:{value:n, enumerable:!0, configurable:!0}, target:{value:o, enumerable:!0, configurable:!0}, identifier:{value:r, enumerable:!0, configurable:!0}, active:{value:i, enumerable:!0, configurable:!0}, x:{value:a, enumerable:!0, configurable:!0}, y:{value:s, enumerable:!0, configurable:!0}, dx:{value:l, enumerable:!0, configurable:!0}, dy:{value:c, enumerable:!0, 
      configurable:!0}, _:{value:u}});
    }
    function Ie(e) {
      return !e.ctrlKey && !e.button;
    }
    function Ae() {
      return this.parentNode;
    }
    function De(e, t) {
      return null == t ? {x:e.x, y:e.y} : t;
    }
    function Re() {
      return navigator.maxTouchPoints || "ontouchstart" in this;
    }
    function Le() {
      function f(e) {
        e.on("mousedown.drag", g).filter(l).on("touchstart.drag", y).on("touchmove.drag", v, Ee).on("touchend.drag touchcancel.drag", x).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }
      function g(a, s) {
        !o && r.call(this, a, s) && (s = w(this, i.call(this, a, s), a, s, "mouse")) && (Se(a.view).on("mousemove.drag", p, ke).on("mouseup.drag", m, ke), _e(a.view), a.stopImmediatePropagation(), n = !1, e = a.clientX, t = a.clientY, s("start", a));
      }
      function p(o) {
        if (Ne(o), !n) {
          var r = o.clientX - e, i = o.clientY - t;
          n = r * r + i * i > h;
        }
        c.mouse("drag", o);
      }
      function m(e) {
        Se(e.view).on("mousemove.drag mouseup.drag", null);
        Pe(e.view, n);
        Ne(e);
        c.mouse("end", e);
      }
      function y(e, t) {
        if (r.call(this, e, t)) {
          var n, o, a = e.changedTouches, s = i.call(this, e, t), l = a.length;
          for (n = 0; n < l; ++n) {
            if (o = w(this, s, e, t, a[n].identifier, a[n])) {
              e.stopImmediatePropagation(), o("start", e, a[n]);
            }
          }
        }
      }
      function v(e) {
        var t, n, o = e.changedTouches, r = o.length;
        for (t = 0; t < r; ++t) {
          (n = c[o[t].identifier]) && (Ne(e), n("drag", e, o[t]));
        }
      }
      function x(e) {
        var t, n, r = e.changedTouches, i = r.length;
        o && clearTimeout(o);
        o = setTimeout(function() {
          o = null;
        }, 500);
        for (t = 0; t < i; ++t) {
          if (n = c[r[t].identifier]) {
            e.stopImmediatePropagation(), n("end", e, r[t]);
          }
        }
      }
      function w(e, t, n, o, r, i) {
        var a, l, h, g = u.copy(), p = Ce(i || n, t);
        if (null != (h = s.call(e, new Oe("beforestart", {sourceEvent:n, target:f, identifier:r, active:d, x:p[0], y:p[1], dx:0, dy:0, dispatch:g}), o))) {
          return a = h.x - p[0] || 0, l = h.y - p[1] || 0, function n(i, s, u) {
            var y = p;
            switch(i) {
              case "start":
                c[r] = n;
                var m = d++;
                break;
              case "end":
                delete c[r], --d;
              case "drag":
                p = Ce(u || s, t), m = d;
            }
            g.call(i, e, new Oe(i, {sourceEvent:s, subject:h, target:f, identifier:r, active:m, x:p[0] + a, y:p[1] + l, dx:p[0] - y[0], dy:p[1] - y[1], dispatch:g}), o);
          };
        }
      }
      var e, t, n, o, r = Ie, i = Ae, s = De, l = Re, c = {}, u = a("start", "drag", "end"), d = 0, h = 0;
      return f.filter = function(e) {
        return arguments.length ? (r = "function" == typeof e ? e : ze(!!e), f) : r;
      }, f.container = function(e) {
        return arguments.length ? (i = "function" == typeof e ? e : ze(e), f) : i;
      }, f.subject = function(e) {
        return arguments.length ? (s = "function" == typeof e ? e : ze(e), f) : s;
      }, f.touchable = function(e) {
        return arguments.length ? (l = "function" == typeof e ? e : ze(!!e), f) : l;
      }, f.on = function() {
        var e = u.on.apply(u, arguments);
        return e === u ? f : e;
      }, f.clickDistance = function(e) {
        return arguments.length ? (h = (e = +e) * e, f) : Math.sqrt(h);
      }, f;
    }
    function $e(e, t, n) {
      e.prototype = t.prototype = n;
      n.constructor = e;
    }
    function Te(e, t) {
      e = Object.create(e.prototype);
      for (var o in t) {
        e[o] = t[o];
      }
      return e;
    }
    function Ve() {
    }
    function Je() {
      return this.rgb().formatHex();
    }
    function et() {
      return this.rgb().formatRgb();
    }
    function tt(e) {
      var t, n;
      return e = (e + "").trim().toLowerCase(), (t = Ye.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), 6 === n ? nt(t) : 3 === n ? new it(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, (15 & t) << 4 | 15 & t, 1) : 8 === n ? ot(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (255 & t) / 255) : 4 === n ? ot(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, ((15 & t) << 4 | 15 & t) / 255) : null) : (t = Fe.exec(e)) ? new it(t[1], t[2], t[3], 1) : (t = We.exec(e)) ? 
      new it(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, 1) : (t = Ke.exec(e)) ? ot(t[1], t[2], t[3], t[4]) : (t = Ge.exec(e)) ? ot(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, t[4]) : (t = qe.exec(e)) ? dt(t[1], t[2] / 100, t[3] / 100, 1) : (t = Ue.exec(e)) ? dt(t[1], t[2] / 100, t[3] / 100, t[4]) : Qe.hasOwnProperty(e) ? nt(Qe[e]) : "transparent" === e ? new it(NaN, NaN, NaN, 0) : null;
    }
    function nt(e) {
      return new it(e >> 16 & 255, e >> 8 & 255, 255 & e, 1);
    }
    function ot(e, t, n, o) {
      return 0 >= o && (e = t = n = NaN), new it(e, t, n, o);
    }
    function rt(e, t, n, o) {
      var r;
      return 1 === arguments.length ? ((r = e) instanceof Ve || (r = tt(r)), r ? new it((r = r.rgb()).r, r.g, r.b, r.opacity) : new it()) : new it(e, t, n, null == o ? 1 : o);
    }
    function it(e, t, n, o) {
      this.r = +e;
      this.g = +t;
      this.b = +n;
      this.opacity = +o;
    }
    function at() {
      return `#${ut(this.r)}${ut(this.g)}${ut(this.b)}`;
    }
    function st() {
      const e = lt(this.opacity);
      return `${1 === e ? "rgb(" : "rgba("}${ct(this.r)}, ${ct(this.g)}, ${ct(this.b)}${1 === e ? ")" : `, ${e})`}`;
    }
    function lt(e) {
      return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
    }
    function ct(e) {
      return Math.max(0, Math.min(255, Math.round(e) || 0));
    }
    function ut(e) {
      return (16 > (e = ct(e)) ? "0" : "") + e.toString(16);
    }
    function dt(e, t, n, o) {
      return 0 >= o ? e = t = n = NaN : 0 >= n || 1 <= n ? e = t = NaN : 0 >= t && (e = NaN), new ft(e, t, n, o);
    }
    function ht(e) {
      if (e instanceof ft) {
        return new ft(e.h, e.s, e.l, e.opacity);
      }
      if (e instanceof Ve || (e = tt(e)), !e) {
        return new ft();
      }
      if (e instanceof ft) {
        return e;
      }
      var t = (e = e.rgb()).r / 255, n = e.g / 255, o = e.b / 255, r = Math.min(t, n, o), i = Math.max(t, n, o), a = NaN, s = i - r, l = (i + r) / 2;
      return s ? (a = t === i ? (n - o) / s + 6 * (n < o) : n === i ? (o - t) / s + 2 : (t - n) / s + 4, s /= .5 > l ? i + r : 2 - i - r, a *= 60) : s = 0 < l && 1 > l ? 0 : a, new ft(a, s, l, e.opacity);
    }
    function ft(e, t, n, o) {
      this.h = +e;
      this.s = +t;
      this.l = +n;
      this.opacity = +o;
    }
    function gt(e) {
      return 0 > (e = (e || 0) % 360) ? e + 360 : e;
    }
    function pt(e) {
      return Math.max(0, Math.min(1, e || 0));
    }
    function mt(e, t, n) {
      return 255 * (60 > e ? t + (n - t) * e / 60 : 180 > e ? n : 240 > e ? t + (n - t) * (240 - e) / 60 : t);
    }
    function vt(e) {
      return 1 == (e = +e) ? xt : function(t, n) {
        return n - t ? function(e, t, n) {
          return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(o) {
            return Math.pow(e + o * t, n);
          };
        }(t, n, e) : yt(isNaN(t) ? n : t);
      };
    }
    function xt(e, t) {
      var n = t - e;
      return n ? function(e, t) {
        return function(n) {
          return e + n * t;
        };
      }(e, n) : yt(isNaN(e) ? t : e);
    }
    function bt(e, t) {
      t || (t = []);
      var n, o = e ? Math.min(t.length, e.length) : 0, r = t.slice();
      return function(i) {
        for (n = 0; n < o; ++n) {
          r[n] = e[n] * (1 - i) + t[n] * i;
        }
        return r;
      };
    }
    function St(e, t) {
      var n, o = t ? t.length : 0, r = e ? Math.min(o, e.length) : 0, i = Array(r), a = Array(o);
      for (n = 0; n < r; ++n) {
        i[n] = Pt(e[n], t[n]);
      }
      for (; n < o; ++n) {
        a[n] = t[n];
      }
      return function(e) {
        for (n = 0; n < r; ++n) {
          a[n] = i[n](e);
        }
        return a;
      };
    }
    function Ct(e, t) {
      var n = new Date();
      return e = +e, t = +t, function(o) {
        return n.setTime(e * (1 - o) + t * o), n;
      };
    }
    function Et(e, t) {
      return e = +e, t = +t, function(n) {
        return e * (1 - n) + t * n;
      };
    }
    function kt(e, t) {
      var n, o = {}, r = {};
      for (n in null !== e && "object" == typeof e || (e = {}), null !== t && "object" == typeof t || (t = {}), t) {
        n in e ? o[n] = Pt(e[n], t[n]) : r[n] = t[n];
      }
      return function(e) {
        for (n in o) {
          r[n] = o[n](e);
        }
        return r;
      };
    }
    function _t(e, t) {
      var n, o, r, i = Mt.lastIndex = Nt.lastIndex = 0, a = -1, s = [], l = [];
      e += "";
      for (t += ""; (n = Mt.exec(e)) && (o = Nt.exec(t));) {
        (r = o.index) > i && (r = t.slice(i, r), s[a] ? s[a] += r : s[++a] = r), (n = n[0]) === (o = o[0]) ? s[a] ? s[a] += o : s[++a] = o : (s[++a] = null, l.push({i:a, x:Et(n, o)})), i = Nt.lastIndex;
      }
      return i < t.length && (r = t.slice(i), s[a] ? s[a] += r : s[++a] = r), 2 > s.length ? l[0] ? function(e) {
        return function(t) {
          return e(t) + "";
        };
      }(l[0].x) : function(e) {
        return function() {
          return e;
        };
      }(t) : (t = l.length, function(e) {
        for (var n, o = 0; o < t; ++o) {
          s[(n = l[o]).i] = n.x(e);
        }
        return s.join("");
      });
    }
    function Pt(e, t) {
      var n, o, r = typeof t;
      return null == t || "boolean" === r ? yt(t) : ("number" === r ? Et : "string" === r ? (n = tt(t)) ? (t = n, wt) : _t : t instanceof tt ? wt : t instanceof Date ? Ct : (o = t, !ArrayBuffer.isView(o) || o instanceof DataView ? Array.isArray(t) ? St : "function" != typeof t.valueOf && "function" != typeof t.toString || isNaN(t) ? kt : Et : bt))(e, t);
    }
    function At(e, t, n, o, r, i) {
      var a, s, l;
      return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * o) && (n -= e * l, o -= t * l), (s = Math.sqrt(n * n + o * o)) && (n /= s, o /= s, l /= s), e * o < t * n && (e = -e, t = -t, l = -l, a = -a), {translateX:r, translateY:i, rotate:Math.atan2(t, e) * Ot, skewX:Math.atan(l) * Ot, scaleX:a, scaleY:s};
    }
    function Dt(e, t, n, o) {
      function r(e) {
        return e.length ? e.pop() + " " : "";
      }
      return function(i, a) {
        var s = [], l = [];
        return i = e(i), a = e(a), function(e, o, r, i, a, s) {
          e !== r || o !== i ? (a = a.push("translate(", null, t, null, n), s.push({i:a - 4, x:Et(e, r)}, {i:a - 2, x:Et(o, i)})) : (r || i) && a.push("translate(" + r + t + i + n);
        }(i.translateX, i.translateY, a.translateX, a.translateY, s, l), function(e, t, n, i) {
          e !== t ? (180 < e - t ? t += 360 : 180 < t - e && (e += 360), i.push({i:n.push(r(n) + "rotate(", null, o) - 2, x:Et(e, t)})) : t && n.push(r(n) + "rotate(" + t + o);
        }(i.rotate, a.rotate, s, l), function(e, t, n, i) {
          e !== t ? i.push({i:n.push(r(n) + "skewX(", null, o) - 2, x:Et(e, t)}) : t && n.push(r(n) + "skewX(" + t + o);
        }(i.skewX, a.skewX, s, l), function(e, t, n, o, i, a) {
          e !== n || t !== o ? (i = i.push(r(i) + "scale(", null, ",", null, ")"), a.push({i:i - 4, x:Et(e, n)}, {i:i - 2, x:Et(t, o)})) : 1 === n && 1 === o || i.push(r(i) + "scale(" + n + "," + o + ")");
        }(i.scaleX, i.scaleY, a.scaleX, a.scaleY, s, l), i = a = null, function(e) {
          for (var t, n = -1, o = l.length; ++n < o;) {
            s[(t = l[n]).i] = t.x(e);
          }
          return s.join("");
        };
      };
    }
    function $t(e) {
      return ((e = Math.exp(e)) + 1 / e) / 2;
    }
    function qt() {
      return Ft || (Gt(Ut), Ft = Kt.now() + Wt);
    }
    function Ut() {
      Ft = 0;
    }
    function Qt() {
      this._call = this._time = this._next = null;
    }
    function Jt(e, t, n) {
      var o = new Qt();
      return o.restart(e, t, n), o;
    }
    function en() {
      Ft = (Yt = Kt.now()) + Wt;
      jt = Ht = 0;
      try {
        !function() {
          qt();
          ++jt;
          for (var e, t = Tt; t;) {
            0 <= (e = Ft - t._time) && t._call.call(void 0, e), t = t._next;
          }
          --jt;
        }();
      } finally {
        jt = 0, function() {
          for (var e, t, n = Tt, o = 1 / 0; n;) {
            n._call ? (o > n._time && (o = n._time), e = n, n = n._next) : (t = n._next, n._next = null, n = e ? e._next = t : Tt = t);
          }
          Vt = e;
          nn(o);
        }(), Ft = 0;
      }
    }
    function tn() {
      var e = Kt.now(), t = e - Yt;
      1E3 < t && (Wt -= t, Yt = e);
    }
    function nn(e) {
      jt || (Ht && (Ht = clearTimeout(Ht)), 24 < e - Ft ? (e < 1 / 0 && (Ht = setTimeout(en, e - Kt.now() - Wt)), Zt && (Zt = clearInterval(Zt))) : (Zt || (Yt = Kt.now(), Zt = setInterval(tn, 1E3)), jt = 1, Gt(en)));
    }
    function on(e, t, n) {
      var o = new Qt();
      return t = null == t ? 0 : +t, o.restart(n => {
        o.stop();
        e(n + t);
      }, t, n), o;
    }
    function gn(e, t, n, o, r, i) {
      var a = e.__transition;
      if (a) {
        if (n in a) {
          return;
        }
      } else {
        e.__transition = {};
      }
      !function(e, t, n) {
        function a(i) {
          var u, d, h;
          if (1 !== n.state) {
            return l();
          }
          for (c in r) {
            if ((h = r[c]).name === n.name) {
              if (3 === h.state) {
                return on(a);
              }
              4 === h.state ? (h.state = 6, h.timer.stop(), h.on.call("interrupt", e, e.__data__, h.index, h.group), delete r[c]) : +c < t && (h.state = 6, h.timer.stop(), h.on.call("cancel", e, e.__data__, h.index, h.group), delete r[c]);
            }
          }
          if (on(function() {
            3 === n.state && (n.state = 4, n.timer.restart(s, n.delay, n.time), s(i));
          }), n.state = 2, n.on.call("start", e, e.__data__, n.index, n.group), 2 === n.state) {
            n.state = 3;
            o = Array(d = n.tween.length);
            var c = 0;
            for (u = -1; c < d; ++c) {
              (h = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (o[++u] = h);
            }
            o.length = u + 1;
          }
        }
        function s(t) {
          t = t < n.duration ? n.ease.call(null, t / n.duration) : (n.timer.restart(l), n.state = 5, 1);
          for (var i = -1, a = o.length; ++i < a;) {
            o[i].call(e, t);
          }
          5 === n.state && (n.on.call("end", e, e.__data__, n.index, n.group), l());
        }
        function l() {
          for (var o in n.state = 6, n.timer.stop(), delete r[t], r) {
            return;
          }
          delete e.__transition;
        }
        var o, r = e.__transition;
        r[t] = n;
        n.timer = Jt(function(e) {
          n.state = 1;
          n.timer.restart(a, n.delay, n.time);
          n.delay <= e && a(e - n.delay);
        }, 0, n.time);
      }(e, n, {name:t, index:o, group:r, on:rn, tween:an, time:i.time, delay:i.delay, duration:i.duration, ease:i.ease, timer:null, state:0});
    }
    function pn(e, t) {
      e = yn(e, t);
      if (0 < e.state) {
        throw Error("too late; already scheduled");
      }
      return e;
    }
    function mn(e, t) {
      e = yn(e, t);
      if (3 < e.state) {
        throw Error("too late; already running");
      }
      return e;
    }
    function yn(e, t) {
      e = e.__transition;
      if (!e || !(e = e[t])) {
        throw Error("transition not found");
      }
      return e;
    }
    function vn(e, t) {
      var n, o, r, i = e.__transition, a = !0;
      if (i) {
        for (r in t = null == t ? null : t + "", i) {
          (n = i[r]).name === t ? (o = 2 < n.state && 5 > n.state, n.state = 6, n.timer.stop(), n.on.call(o ? "interrupt" : "cancel", e, e.__data__, n.index, n.group), delete i[r]) : a = !1;
        }
        a && delete e.__transition;
      }
    }
    function xn(e, t) {
      var n, o;
      return function() {
        var r = mn(this, e), i = r.tween;
        if (i !== n) {
          var a = 0;
          for (i = (o = n = i).length; a < i; ++a) {
            if (o[a].name === t) {
              (o = o.slice()).splice(a, 1);
              break;
            }
          }
        }
        r.tween = o;
      };
    }
    function wn(e, t, n) {
      var o, r;
      if ("function" != typeof n) {
        throw Error();
      }
      return function() {
        var i = mn(this, e), a = i.tween;
        if (a !== o) {
          r = (o = a).slice();
          a = {name:t, value:n};
          for (var l = 0, c = r.length; l < c; ++l) {
            if (r[l].name === t) {
              r[l] = a;
              break;
            }
          }
          l === c && r.push(a);
        }
        i.tween = r;
      };
    }
    function bn(e, t, n) {
      var o = e._id;
      return e.each(function() {
        var e = mn(this, o);
        (e.value || (e.value = {}))[t] = n.apply(this, arguments);
      }), function(e) {
        return yn(e, o).value[t];
      };
    }
    function Sn(e, t) {
      var n;
      return ("number" == typeof t ? Et : t instanceof tt ? wt : (n = tt(t)) ? (t = n, wt) : _t)(e, t);
    }
    function Cn(e) {
      return function() {
        this.removeAttribute(e);
      };
    }
    function En(e) {
      return function() {
        this.removeAttributeNS(e.space, e.local);
      };
    }
    function kn(e, t, n) {
      var o, r, i = n + "";
      return function() {
        var a = this.getAttribute(e);
        return a === i ? null : a === o ? r : r = t(o = a, n);
      };
    }
    function Mn(e, t, n) {
      var o, r, i = n + "";
      return function() {
        var a = this.getAttributeNS(e.space, e.local);
        return a === i ? null : a === o ? r : r = t(o = a, n);
      };
    }
    function Nn(e, t, n) {
      var o, r, i;
      return function() {
        var a, s, l = n(this);
        if (null != l) {
          return (a = this.getAttribute(e)) === (s = l + "") ? null : a === o && s === r ? i : (r = s, i = t(o = a, l));
        }
        this.removeAttribute(e);
      };
    }
    function _n(e, t, n) {
      var o, r, i;
      return function() {
        var a, s, l = n(this);
        if (null != l) {
          return (a = this.getAttributeNS(e.space, e.local)) === (s = l + "") ? null : a === o && s === r ? i : (r = s, i = t(o = a, l));
        }
        this.removeAttributeNS(e.space, e.local);
      };
    }
    function Pn(e, t) {
      function r() {
        var r = t.apply(this, arguments);
        return r !== o && (n = (o = r) && function(e, t) {
          return function(n) {
            this.setAttributeNS(e.space, e.local, t.call(this, n));
          };
        }(e, r)), n;
      }
      var n, o;
      return r._value = t, r;
    }
    function zn(e, t) {
      function r() {
        var r = t.apply(this, arguments);
        return r !== o && (n = (o = r) && function(e, t) {
          return function(n) {
            this.setAttribute(e, t.call(this, n));
          };
        }(e, r)), n;
      }
      var n, o;
      return r._value = t, r;
    }
    function On(e, t) {
      return function() {
        pn(this, e).delay = +t.apply(this, arguments);
      };
    }
    function In(e, t) {
      return t = +t, function() {
        pn(this, e).delay = t;
      };
    }
    function An(e, t) {
      return function() {
        mn(this, e).duration = +t.apply(this, arguments);
      };
    }
    function Dn(e, t) {
      return t = +t, function() {
        mn(this, e).duration = t;
      };
    }
    function Ln(e) {
      return function() {
        this.style.removeProperty(e);
      };
    }
    function Tn(e, t, n, o) {
      this._groups = e;
      this._parents = t;
      this._name = n;
      this._id = o;
    }
    function Xn(e, {sourceEvent:t, target:n, transform:o, dispatch:r}) {
      Object.defineProperties(this, {type:{value:e, enumerable:!0, configurable:!0}, sourceEvent:{value:t, enumerable:!0, configurable:!0}, target:{value:n, enumerable:!0, configurable:!0}, transform:{value:o, enumerable:!0, configurable:!0}, _:{value:r}});
    }
    function Yn(e, t, n) {
      this.k = e;
      this.x = t;
      this.y = n;
    }
    function Wn(e) {
      for (; !e.__zoom;) {
        if (!(e = e.parentNode)) {
          return Fn;
        }
      }
      return e.__zoom;
    }
    function Gn(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    function qn(e) {
      return !(e.ctrlKey && "wheel" !== e.type || e.button);
    }
    function Un() {
      var e = this;
      return e instanceof SVGElement ? (e = e.ownerSVGElement || e).hasAttribute("viewBox") ? [[(e = e.viewBox.baseVal).x, e.y], [e.x + e.width, e.y + e.height]] : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]] : [[0, 0], [e.clientWidth, e.clientHeight]];
    }
    function Qn() {
      return this.__zoom || Fn;
    }
    function Jn(e) {
      return -e.deltaY * (1 === e.deltaMode ? .05 : e.deltaMode ? 1 : .002) * (e.ctrlKey ? 10 : 1);
    }
    function eo() {
      return navigator.maxTouchPoints || "ontouchstart" in this;
    }
    function to(e, t, n) {
      var o = e.invertX(t[0][0]) - n[0][0], r = e.invertX(t[1][0]) - n[1][0], i = e.invertY(t[0][1]) - n[0][1];
      t = e.invertY(t[1][1]) - n[1][1];
      return e.translate(r > o ? (o + r) / 2 : Math.min(0, o) || Math.max(0, r), t > i ? (i + t) / 2 : Math.min(0, i) || Math.max(0, t));
    }
    function no() {
      function v(e) {
        e.property("__zoom", Qn).on("wheel.zoom", k, {passive:!1}).on("mousedown.zoom", M).on("dblclick.zoom", N).filter(l).on("touchstart.zoom", _).on("touchmove.zoom", P).on("touchend.zoom touchcancel.zoom", z).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }
      function x(e, t) {
        return (t = Math.max(c[0], Math.min(c[1], t))) === e.k ? e : new Yn(t, e.x, e.y);
      }
      function w(e, t, n) {
        var o = t[0] - n[0] * e.k;
        t = t[1] - n[1] * e.k;
        return o === e.x && t === e.y ? e : new Yn(e.k, o, t);
      }
      function b(e) {
        return [(+e[0][0] + +e[1][0]) / 2, (+e[0][1] + +e[1][1]) / 2];
      }
      function S(e, t, n, o) {
        e.on("start.zoom", function() {
          C(this, arguments).event(o).start();
        }).on("interrupt.zoom end.zoom", function() {
          C(this, arguments).event(o).end();
        }).tween("zoom", function() {
          var i = arguments, a = C(this, i).event(o), s = r.apply(this, i), l = null == n ? b(s) : "function" == typeof n ? n.apply(this, i) : n, c = Math.max(s[1][0] - s[0][0], s[1][1] - s[0][1]);
          s = this.__zoom;
          var d = "function" == typeof t ? t.apply(this, i) : t, f = h(s.invert(l).concat(c / s.k), d.invert(l).concat(c / d.k));
          return function(e) {
            if (1 === e) {
              e = d;
            } else {
              e = f(e);
              var n = c / e[2];
              e = new Yn(n, l[0] - e[0] * n, l[1] - e[1] * n);
            }
            a.zoom(null, e);
          };
        });
      }
      function C(e, t, n) {
        return !n && e.__zooming || new E(e, t);
      }
      function E(e, t) {
        this.that = e;
        this.args = t;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = r.apply(e, t);
        this.taps = 0;
      }
      function k(e, ...t) {
        if (o.apply(this, arguments)) {
          var n = C(this, t).event(e);
          t = this.__zoom;
          var a = Math.max(c[0], Math.min(c[1], t.k * Math.pow(2, s.apply(this, arguments)))), l = Ce(e);
          if (n.wheel) {
            n.mouse[0][0] === l[0] && n.mouse[0][1] === l[1] || (n.mouse[1] = t.invert(n.mouse[0] = l)), clearTimeout(n.wheel);
          } else {
            if (t.k === a) {
              return;
            }
            n.mouse = [l, t.invert(l)];
            vn(this);
            n.start();
          }
          Gn(e);
          n.wheel = setTimeout(function() {
            n.wheel = null;
            n.end();
          }, 150);
          n.zoom("mouse", i(w(x(t, a), n.mouse[0], n.mouse[1]), n.extent, u));
        }
      }
      function M(e, ...t) {
        if (!n && o.apply(this, arguments)) {
          var r = e.currentTarget, a = C(this, t, !0).event(e), s = Se(e.view).on("mousemove.zoom", function(e) {
            if (Gn(e), !a.moved) {
              var t = e.clientX - c, n = e.clientY - d;
              a.moved = t * t + n * n > m;
            }
            a.event(e).zoom("mouse", i(w(a.that.__zoom, a.mouse[0] = Ce(e, r), a.mouse[1]), a.extent, u));
          }, !0).on("mouseup.zoom", function(e) {
            s.on("mousemove.zoom mouseup.zoom", null);
            Pe(e.view, a.moved);
            Gn(e);
            a.event(e).end();
          }, !0);
          t = Ce(e, r);
          var c = e.clientX, d = e.clientY;
          _e(e.view);
          e.stopImmediatePropagation();
          a.mouse = [t, this.__zoom.invert(t)];
          vn(this);
          a.start();
        }
      }
      function N(e, ...t) {
        if (o.apply(this, arguments)) {
          var n = this.__zoom, a = Ce(e.changedTouches ? e.changedTouches[0] : e, this), s = n.invert(a);
          t = i(w(x(n, n.k * (e.shiftKey ? .5 : 2)), a, s), r.apply(this, t), u);
          Gn(e);
          0 < d ? Se(this).transition().duration(d).call(S, t, a, e) : Se(this).call(v.transform, t, a, e);
        }
      }
      function _(n, ...r) {
        if (o.apply(this, arguments)) {
          var i, s, c = n.touches, u = c.length, d = C(this, r, n.changedTouches.length === u).event(n);
          n.stopImmediatePropagation();
          for (r = 0; r < u; ++r) {
            var l = [l = Ce(s = c[r], this), this.__zoom.invert(l), s.identifier];
            d.touch0 ? d.touch1 || d.touch0[2] === l[2] || (d.touch1 = l, d.taps = 0) : (d.touch0 = l, i = !0, d.taps = 1 + !!e);
          }
          e && (e = clearTimeout(e));
          i && (2 > d.taps && (t = l[0], e = setTimeout(function() {
            e = null;
          }, 500)), vn(this), d.start());
        }
      }
      function P(e, ...t) {
        if (this.__zooming) {
          var n;
          t = C(this, t).event(e);
          var l = e.changedTouches, c = l.length;
          Gn(e);
          for (n = 0; n < c; ++n) {
            var r = Ce(e = l[n], this);
            t.touch0 && t.touch0[2] === e.identifier ? t.touch0[0] = r : t.touch1 && t.touch1[2] === e.identifier && (t.touch1[0] = r);
          }
          if (e = t.that.__zoom, t.touch1) {
            r = t.touch0[0];
            l = t.touch0[1];
            n = t.touch1[0];
            c = t.touch1[1];
            var a = (a = n[0] - r[0]) * a + (a = n[1] - r[1]) * a;
            var m = (m = c[0] - l[0]) * m + (m = c[1] - l[1]) * m;
            e = x(e, Math.sqrt(a / m));
            r = [(r[0] + n[0]) / 2, (r[1] + n[1]) / 2];
            a = [(l[0] + c[0]) / 2, (l[1] + c[1]) / 2];
          } else {
            if (!t.touch0) {
              return;
            }
            r = t.touch0[0];
            a = t.touch0[1];
          }
          t.zoom("touch", i(w(e, r, a), t.extent, u));
        }
      }
      function z(e, ...o) {
        if (this.__zooming) {
          var a = C(this, o).event(e), s = e.changedTouches, l = s.length;
          e.stopImmediatePropagation();
          n && clearTimeout(n);
          n = setTimeout(function() {
            n = null;
          }, 500);
          for (o = 0; o < l; ++o) {
            var i = s[o];
            a.touch0 && a.touch0[2] === i.identifier ? delete a.touch0 : a.touch1 && a.touch1[2] === i.identifier && delete a.touch1;
          }
          (a.touch1 && !a.touch0 && (a.touch0 = a.touch1, delete a.touch1), a.touch0) ? a.touch0[1] = this.__zoom.invert(a.touch0[0]) : (a.end(), 2 === a.taps && (i = Ce(i, this), Math.hypot(t[0] - i[0], t[1] - i[1]) < y)) && (i = Se(this).on("dblclick.zoom")) && i.apply(this, arguments);
        }
      }
      var e, t, n, o = qn, r = Un, i = to, s = Jn, l = eo, c = [0, 1 / 0], u = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], d = 250, h = Bt, f = a("start", "zoom", "end"), m = 0, y = 10;
      return v.transform = function(e, t, n, o) {
        var r = e.selection ? e.selection() : e;
        r.property("__zoom", Qn);
        e !== r ? S(e, t, n, o) : r.interrupt().each(function() {
          C(this, arguments).event(o).start().zoom(null, "function" == typeof t ? t.apply(this, arguments) : t).end();
        });
      }, v.scaleBy = function(e, t, n, o) {
        v.scaleTo(e, function() {
          return this.__zoom.k * ("function" == typeof t ? t.apply(this, arguments) : t);
        }, n, o);
      }, v.scaleTo = function(e, t, n, o) {
        v.transform(e, function() {
          var e = r.apply(this, arguments), o = this.__zoom, a = null == n ? b(e) : "function" == typeof n ? n.apply(this, arguments) : n, s = o.invert(a), l = "function" == typeof t ? t.apply(this, arguments) : t;
          return i(w(x(o, l), a, s), e, u);
        }, n, o);
      }, v.translateBy = function(e, t, n, o) {
        v.transform(e, function() {
          return i(this.__zoom.translate("function" == typeof t ? t.apply(this, arguments) : t, "function" == typeof n ? n.apply(this, arguments) : n), r.apply(this, arguments), u);
        }, null, o);
      }, v.translateTo = function(e, t, n, o, a) {
        v.transform(e, function() {
          var e = r.apply(this, arguments), a = this.__zoom, s = null == o ? b(e) : "function" == typeof o ? o.apply(this, arguments) : o;
          return i(Fn.translate(s[0], s[1]).scale(a.k).translate("function" == typeof t ? -t.apply(this, arguments) : -t, "function" == typeof n ? -n.apply(this, arguments) : -n), e, u);
        }, o, a);
      }, E.prototype = {event:function(e) {
        return e && (this.sourceEvent = e), this;
      }, start:function() {
        return 1 == ++this.active && (this.that.__zooming = this, this.emit("start")), this;
      }, zoom:function(e, t) {
        return this.mouse && "mouse" !== e && (this.mouse[1] = t.invert(this.mouse[0])), this.touch0 && "touch" !== e && (this.touch0[1] = t.invert(this.touch0[0])), this.touch1 && "touch" !== e && (this.touch1[1] = t.invert(this.touch1[0])), this.that.__zoom = t, this.emit("zoom"), this;
      }, end:function() {
        return 0 == --this.active && (delete this.that.__zooming, this.emit("end")), this;
      }, emit:function(e) {
        var t = Se(this.that).datum();
        f.call(e, this.that, new Xn(e, {sourceEvent:this.sourceEvent, target:v, type:e, transform:this.that.__zoom, dispatch:f}), t);
      }}, v.wheelDelta = function(e) {
        return arguments.length ? (s = "function" == typeof e ? e : Zn(+e), v) : s;
      }, v.filter = function(e) {
        return arguments.length ? (o = "function" == typeof e ? e : Zn(!!e), v) : o;
      }, v.touchable = function(e) {
        return arguments.length ? (l = "function" == typeof e ? e : Zn(!!e), v) : l;
      }, v.extent = function(e) {
        return arguments.length ? (r = "function" == typeof e ? e : Zn([[+e[0][0], +e[0][1]], [+e[1][0], +e[1][1]]]), v) : r;
      }, v.scaleExtent = function(e) {
        return arguments.length ? (c[0] = +e[0], c[1] = +e[1], v) : [c[0], c[1]];
      }, v.translateExtent = function(e) {
        return arguments.length ? (u[0][0] = +e[0][0], u[1][0] = +e[1][0], u[0][1] = +e[0][1], u[1][1] = +e[1][1], v) : [[u[0][0], u[0][1]], [u[1][0], u[1][1]]];
      }, v.constrain = function(e) {
        return arguments.length ? (i = e, v) : i;
      }, v.duration = function(e) {
        return arguments.length ? (d = +e, v) : d;
      }, v.interpolate = function(e) {
        return arguments.length ? (h = e, v) : h;
      }, v.on = function() {
        var e = f.on.apply(f, arguments);
        return e === f ? v : e;
      }, v.clickDistance = function(e) {
        return arguments.length ? (m = (e = +e) * e, v) : Math.sqrt(m);
      }, v.tapDistance = function(e) {
        return arguments.length ? (y = +e, v) : y;
      }, v;
    }
    function mo(e, t) {
      if (!e && !t) {
        return !0;
      }
      if (!e || !t || e.size !== t.size) {
        return !1;
      }
      if (!e.size && !t.size) {
        return !0;
      }
      for (const n of e.keys()) {
        if (!t.has(n)) {
          return !1;
        }
      }
      return !0;
    }
    function yo(e, t, n) {
      if (n) {
        var o = [];
        e.forEach((e, n) => {
          t?.has(n) || o.push(e);
        });
        o.length && n(o);
      }
    }
    async function Mo({nodes:e, width:t, height:n, panZoom:o, minZoom:r, maxZoom:i}, a) {
      if (0 === e.size) {
        return Promise.resolve(!0);
      }
      e = function(e, t) {
        const n = new Map(), o = t?.nodes ? new Set(t.nodes.map(e => e.id)) : null;
        return e.forEach(e => {
          !e.measured.width || !e.measured.height || !t?.includeHiddenNodes && e.hidden || o && !o.has(e.id) || n.set(e.id, e);
        }), n;
      }(e, a);
      e = Co(e);
      t = Wo(e, t, n, a?.minZoom ?? r, a?.maxZoom ?? i, a?.padding ?? .1);
      return await o.setViewport(t, {duration:a?.duration, ease:a?.ease, interpolate:a?.interpolate}), Promise.resolve(!0);
    }
    function No({nodeId:e, nextPosition:t, nodeLookup:n, nodeOrigin:o = [0, 0], nodeExtent:r, onError:i}) {
      e = n.get(e);
      n = e.parentId ? n.get(e.parentId) : void 0;
      const {x:l, y:c} = n ? n.internals.positionAbsolute : {x:0, y:0};
      o = e.origin ?? o;
      r = e.extent || r;
      if ("parent" !== e.extent || e.expandParent) {
        n && Go(e.extent) && (r = [[e.extent[0][0] + l, e.extent[0][1] + c], [e.extent[1][0] + l, e.extent[1][1] + c]]);
      } else if (n) {
        const e = n.measured.width;
        n = n.measured.height;
        e && n && (r = [[l, c], [l + e, c + n]]);
      } else {
        i?.("005", oo.error005());
      }
      t = Go(r) ? Po(t, r, e.measured) : t;
      return void 0 !== e.measured.width && void 0 !== e.measured.height || i?.("015", oo.error015()), {position:{x:t.x - l + (e.measured.width ?? 0) * o[0], y:t.y - c + (e.measured.height ?? 0) * o[1]}, positionAbsolute:t};
    }
    function zo(e, t, n) {
      const {width:o, height:r} = qo(n), {x:i, y:a} = n.internals.positionAbsolute;
      return Po(e, [[i, a], [i + o, a + r]], t);
    }
    function Fo(e, t$jscomp$0) {
      if ("number" == typeof e) {
        return Math.floor(.5 * (t$jscomp$0 - t$jscomp$0 / (1 + e)));
      }
      if ("string" == typeof e && e.endsWith("px")) {
        var t = parseFloat(e);
        if (!Number.isNaN(t)) {
          return Math.floor(t);
        }
      }
      return "string" == typeof e && e.endsWith("%") && (t = parseFloat(e), !Number.isNaN(t)) ? Math.floor(t$jscomp$0 * t * .01) : (console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0);
    }
    function Go(e) {
      return null != e && "parent" !== e;
    }
    function qo(e) {
      return {width:e.measured?.width ?? e.width ?? e.initialWidth ?? 0, height:e.measured?.height ?? e.height ?? e.initialHeight ?? 0};
    }
    function Uo(e) {
      return void 0 !== (e.measured?.width ?? e.width ?? e.initialWidth) && void 0 !== (e.measured?.height ?? e.height ?? e.initialHeight);
    }
    function Qo(e, t = {width:0, height:0}, n, o, r) {
      e = {...e};
      if (n = o.get(n)) {
        r = n.origin || r, e.x += n.internals.positionAbsolute.x - (t.width ?? 0) * r[0], e.y += n.internals.positionAbsolute.y - (t.height ?? 0) * r[1];
      }
      return e;
    }
    function Jo(e, t) {
      if (e.size !== t.size) {
        return !1;
      }
      for (const n of e) {
        if (!t.has(n)) {
          return !1;
        }
      }
      return !0;
    }
    function er(e, {snapGrid:t = [0, 0], snapToGrid:n = !1, transform:o, containerBounds:r}) {
      const {x:i, y:a} = ar(e);
      e = Xo({x:i - (r?.left ?? 0), y:a - (r?.top ?? 0)}, o);
      const {x:l, y:c} = n ? Zo(e, t) : e;
      return {xSnapped:l, ySnapped:c, ...e};
    }
    function rr(e) {
      e = e.composedPath?.()?.[0] || e.target;
      return 1 !== e?.nodeType ? !1 : or.includes(e.nodeName) || e.hasAttribute("contenteditable") || !!e.closest(".nokey");
    }
    function lr({sourceX:e, sourceY:t, targetX:n, targetY:o, sourceControlX:r, sourceControlY:i, targetControlX:a, targetControlY:s}) {
      n = .125 * e + .375 * r + .375 * a + .125 * n;
      o = .125 * t + .375 * i + .375 * s + .125 * o;
      return [n, o, Math.abs(n - e), Math.abs(o - t)];
    }
    function cr(e, t) {
      return 0 <= e ? .5 * e : 25 * t * Math.sqrt(-e);
    }
    function ur({pos:t, x1:n, y1:o, x2:r, y2:i, c:a}) {
      switch(t) {
        case e$jscomp$0.Position.Left:
          return [n - cr(n - r, a), o];
        case e$jscomp$0.Position.Right:
          return [n + cr(r - n, a), o];
        case e$jscomp$0.Position.Top:
          return [n, o - cr(o - i, a)];
        case e$jscomp$0.Position.Bottom:
          return [n, o + cr(i - o, a)];
      }
    }
    function dr({sourceX:t, sourceY:n, sourcePosition:o = e$jscomp$0.Position.Bottom, targetX:r, targetY:i, targetPosition:a = e$jscomp$0.Position.Top, curvature:s = .25}) {
      const [l, c] = ur({pos:o, x1:t, y1:n, x2:r, y2:i, c:s}), [u, d] = ur({pos:a, x1:r, y1:i, x2:t, y2:n, c:s}), [h, f, g, p] = lr({sourceX:t, sourceY:n, targetX:r, targetY:i, sourceControlX:l, sourceControlY:c, targetControlX:u, targetControlY:d});
      return [`M${t},${n} C${l},${c} ${u},${d} ${r},${i}`, h, f, g, p];
    }
    function hr({sourceX:e, sourceY:t, targetX:n, targetY:o}) {
      const r = Math.abs(n - e) / 2, a = Math.abs(o - t) / 2;
      return [n < e ? n + r : n - r, o < t ? o + a : o - a, r, a];
    }
    function fr({sourceNode:e, targetNode:t, width:n, height:o, transform:r}) {
      e = Ao($o(e), $o(t));
      e.x === e.x2 && (e.x2 += 1);
      e.y === e.y2 && (e.y2 += 1);
      return 0 < Vo({x:-r[0] / r[2], y:-r[1] / r[2], width:n / r[2], height:o / r[2]}, Ro(e));
    }
    function mr({sourceX:e, sourceY:t, targetX:n, targetY:o}) {
      const [r, i, a, s] = hr({sourceX:e, sourceY:t, targetX:n, targetY:o});
      return [`M ${e},${t}L ${n},${o}`, r, i, a, s];
    }
    function wr({sourceX:t, sourceY:n, sourcePosition:o = e$jscomp$0.Position.Bottom, targetX:r, targetY:i, targetPosition:a = e$jscomp$0.Position.Top, borderRadius:s = 5, centerX:l, centerY:c, offset:u = 20, stepPosition:d = .5}) {
      const [h, f, g, p, m] = function({source:t, sourcePosition:n = e$jscomp$0.Position.Bottom, target:o, targetPosition:r = e$jscomp$0.Position.Top, center:i$jscomp$0, offset:a, stepPosition:s}) {
        var l = yr[n], c = yr[r];
        const u = {x:t.x + l.x * a, y:t.y + l.y * a}, d = {x:o.x + c.x * a, y:o.y + c.y * a};
        var h = vr({source:u, sourcePosition:n, target:d}), f = 0 !== h.x ? "x" : "y", g = h[f];
        let p, m;
        h = {x:0, y:0};
        const x = {x:0, y:0}, [, , w, b] = hr({sourceX:t.x, sourceY:t.y, targetX:o.x, targetY:o.y});
        if (-1 == l[f] * c[f]) {
          "x" === f ? (p = i$jscomp$0.x ?? u.x + (d.x - u.x) * s, m = i$jscomp$0.y ?? (u.y + d.y) / 2) : (p = i$jscomp$0.x ?? (u.x + d.x) / 2, m = i$jscomp$0.y ?? u.y + (d.y - u.y) * s), i$jscomp$0 = [{x:p, y:u.y}, {x:p, y:d.y}], c = [{x:u.x, y:m}, {x:d.x, y:m}], i$jscomp$0 = l[f] === g ? "x" === f ? i$jscomp$0 : c : "x" === f ? c : i$jscomp$0;
        } else {
          s = [{x:u.x, y:d.y}];
          const i = [{x:d.x, y:u.y}];
          if (i$jscomp$0 = "x" === f ? l.x === g ? i : s : l.y === g ? s : i, n === r) {
            const e = Math.abs(t[f] - o[f]);
            e <= a && (a = Math.min(a - 1, a - e), l[f] === g ? h[f] = (u[f] > t[f] ? -1 : 1) * a : x[f] = (d[f] > o[f] ? -1 : 1) * a);
          }
          n !== r && (g = "x" === f ? "y" : "x", c = l[f] === c[g], n = u[g] > d[g], g = u[g] < d[g], (1 === l[f] && (!c && n || c && g) || 1 !== l[f] && (!c && g || c && n)) && (i$jscomp$0 = "x" === f ? s : i));
          l = u.x + h.x;
          f = u.y + h.y;
          c = d.x + x.x;
          g = d.y + x.y;
          Math.max(Math.abs(l - i$jscomp$0[0].x), Math.abs(c - i$jscomp$0[0].x)) >= Math.max(Math.abs(f - i$jscomp$0[0].y), Math.abs(g - i$jscomp$0[0].y)) ? (p = (l + c) / 2, m = i$jscomp$0[0].y) : (p = i$jscomp$0[0].x, m = (f + g) / 2);
        }
        return [[t, {x:u.x + h.x, y:u.y + h.y}, ...i$jscomp$0, {x:d.x + x.x, y:d.y + x.y}, o], p, m, w, b];
      }({source:{x:t, y:n}, sourcePosition:o, target:{x:r, y:i}, targetPosition:a, center:{x:l, y:c}, offset:u, stepPosition:d});
      return [h.reduce((e$jscomp$0, t, n) => {
        let o = "";
        if (0 < n && n < h.length - 1) {
          {
            var e = h[n - 1];
            n = h[n + 1];
            const r = Math.min(Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) / 2, Math.sqrt(Math.pow(n.x - t.x, 2) + Math.pow(n.y - t.y, 2)) / 2, s), {x:i, y:a} = t;
            t = e.x === i && i === n.x || e.y === a && a === n.y ? `L${i} ${a}` : e.y === a ? `L ${i + r * (e.x < n.x ? -1 : 1)},${a}Q ${i},${a} ${i},${a + r * (e.y < n.y ? 1 : -1)}` : `L ${i},${a + r * (e.y < n.y ? -1 : 1)}Q ${i},${a} ${i + r * (e.x < n.x ? 1 : -1)},${a}`;
          }
        } else {
          t = `${0 === n ? "M" : "L"}${t.x} ${t.y}`;
        }
        return o = t, e$jscomp$0 + o;
      }, ""), f, g, p, m];
    }
    function br(e) {
      return e && !(!e.internals.handleBounds && !e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
    }
    function Sr(e) {
      if (!e) {
        return null;
      }
      const t = [], n = [];
      for (const o of e) {
        o.width = o.width ?? 1, o.height = o.height ?? 1, "source" === o.type ? t.push(o) : "target" === o.type && n.push(o);
      }
      return {source:t, target:n};
    }
    function Cr(t, n, o = e$jscomp$0.Position.Left, r = !1) {
      const i = (n?.x ?? 0) + t.internals.positionAbsolute.x, a = (n?.y ?? 0) + t.internals.positionAbsolute.y, {width:s, height:l} = n ?? qo(t);
      if (r) {
        return {x:i + s / 2, y:a + l / 2};
      }
      switch(n?.position ?? o) {
        case e$jscomp$0.Position.Top:
          return {x:i + s / 2, y:a};
        case e$jscomp$0.Position.Right:
          return {x:i + s, y:a + l / 2};
        case e$jscomp$0.Position.Bottom:
          return {x:i + s / 2, y:a + l};
        case e$jscomp$0.Position.Left:
          return {x:i, y:a + l / 2};
      }
    }
    function Er(e, t) {
      return e && (t ? e.find(e => e.id === t) : e[0]) || null;
    }
    function kr(e, t) {
      return e ? "string" == typeof e ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map(t => `${t}=${e[t]}`).join("\x26")}` : "";
    }
    function Mr(t, n, o, r, i) {
      let a = .5;
      "start" === i ? a = 0 : "end" === i && (a = 1);
      i = [(t.x + t.width * a) * n.zoom + n.x, t.y * n.zoom + n.y - r];
      let l = [-100 * a, -100];
      switch(o) {
        case e$jscomp$0.Position.Right:
          i = [(t.x + t.width) * n.zoom + n.x + r, (t.y + t.height * a) * n.zoom + n.y];
          l = [0, -100 * a];
          break;
        case e$jscomp$0.Position.Bottom:
          i[1] = (t.y + t.height) * n.zoom + n.y + r;
          l[1] = 0;
          break;
        case e$jscomp$0.Position.Left:
          i = [t.x * n.zoom + n.x - r, (t.y + t.height * a) * n.zoom + n.y], l = [-100, -100 * a];
      }
      return `translate(${i[0]}px, ${i[1]}px) translate(${l[0]}%, ${l[1]}%)`;
    }
    function Pr(e$jscomp$0, t) {
      e$jscomp$0 = {...e$jscomp$0};
      for (const e in t) {
        void 0 !== t[e] && (e$jscomp$0[e] = t[e]);
      }
      return e$jscomp$0;
    }
    function Or(e$jscomp$0, t, n, o$jscomp$0) {
      const r = Pr(_r, o$jscomp$0);
      let i = 0 < e$jscomp$0.length;
      const a = new Map(t), s = r?.elevateNodesOnSelect ? 1E3 : 0;
      t.clear();
      n.clear();
      for (const l of e$jscomp$0) {
        var e = a.get(l.id);
        if (!r.checkEquality || l !== e?.internals.userNode) {
          e$jscomp$0 = bo(l, r.nodeOrigin);
          var o = Go(l.extent) ? l.extent : r.nodeExtent;
          const i = Po(e$jscomp$0, o, qo(l));
          e$jscomp$0 = {...r.defaults};
          o = {width:l.measured?.width, height:l.measured?.height};
          a: {
            if (!l.handles) {
              e = l.measured ? e?.internals.handleBounds : void 0;
              break a;
            }
            e = [];
            const o = [];
            for (const t of l.handles) {
              const r = {width:t.width ?? 1, height:t.height ?? 1, nodeId:l.id, x:t.x, y:t.y, position:t.position, type:t.type};
              "source" === t.type ? e.push(r) : "target" === t.type && o.push(r);
            }
            e = {source:e, target:o};
          }
          e = {...e$jscomp$0, ...l, measured:o, internals:{positionAbsolute:i, handleBounds:e, z:(jo(l.zIndex) ? l.zIndex : 0) + (l.selected ? s : 0), userNode:l}};
        }
        t.set(l.id, e);
        void 0 !== e.measured && void 0 !== e.measured.width && void 0 !== e.measured.height || e.hidden || (i = !1);
        l.parentId && Ir(e, t, n, o$jscomp$0);
      }
      return i;
    }
    function Ir(e, t, n, o) {
      const {elevateNodesOnSelect:r, nodeOrigin:i, nodeExtent:a} = Pr(Nr, o);
      o = e.parentId;
      const l = t.get(o);
      if (!l) {
        return void console.warn(`Parent node ${o} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
      }
      !function(e, t) {
        if (e.parentId) {
          var n = t.get(e.parentId);
          n ? n.set(e.id, e) : t.set(e.parentId, new Map([[e.id, e]]));
        }
      }(e, n);
      const {x:u, y:d, z:h} = function(e, t, n, o, r) {
        const {x:i, y:a} = t.internals.positionAbsolute, s = qo(e);
        n = bo(e, n);
        n = Go(e.extent) ? Po(n, e.extent, s) : n;
        o = Po({x:i + n.x, y:a + n.y}, o, s);
        "parent" === e.extent && (o = zo(o, s, t));
        e = (jo(e.zIndex) ? e.zIndex : 0) + (e.selected ? r : 0);
        t = t.internals.z ?? 0;
        return {x:o.x, y:o.y, z:t >= e ? t + 1 : e};
      }(e, l, i, a, r ? 1E3 : 0);
      ({positionAbsolute:n} = e.internals);
      ((o = u !== n.x || d !== n.y) || h !== e.internals.z) && t.set(e.id, {...e, internals:{...e.internals, positionAbsolute:o ? {x:u, y:d} : n, z:h}});
    }
    function Dr(e, t, n, o$jscomp$0 = [0, 0]) {
      const r = [], i = new Map();
      for (const n of e) {
        const e = t.get(n.parentId);
        if (e) {
          var o = i.get(n.parentId)?.expandedRect ?? Lo(e);
          o = To(o, n.rect);
          i.set(n.parentId, {expandedRect:o, parent:e});
        }
      }
      return 0 < i.size && i.forEach(({expandedRect:t, parent:i}, a) => {
        var s = i.internals.positionAbsolute;
        const l = qo(i), c = i.origin ?? o$jscomp$0, u = t.x < s.x ? Math.round(Math.abs(s.x - t.x)) : 0, d = t.y < s.y ? Math.round(Math.abs(s.y - t.y)) : 0;
        s = Math.max(l.width, Math.round(t.width));
        const f = Math.max(l.height, Math.round(t.height)), g = (s - l.width) * c[0], p = (f - l.height) * c[1];
        (0 < u || 0 < d || g || p) && (r.push({id:a, type:"position", position:{x:i.position.x - u + g, y:i.position.y - d + p}}), n.get(a)?.forEach(t => {
          e.some(e => e.id === t.id) || r.push({id:t.id, type:"position", position:{x:t.position.x + u, y:t.position.y + d}});
        }));
        (l.width < t.width || l.height < t.height || u || d) && r.push({id:a, type:"dimensions", setAttributes:!0, dimensions:{width:s + (u ? c[0] * u - g : 0), height:f + (d ? c[1] * d - p : 0)}});
      }), r;
    }
    function Rr(e, t, n, o, r, i) {
      let a = r;
      var s = o.get(a) || new Map();
      o.set(a, s.set(n, t));
      a = `${r}-${e}`;
      s = o.get(a) || new Map();
      if (o.set(a, s.set(n, t)), i) {
        a = `${r}-${e}-${i}`, e = o.get(a) || new Map(), o.set(a, e.set(n, t));
      }
    }
    function Lr(e, t, n$jscomp$0) {
      e.clear();
      t.clear();
      for (const o of n$jscomp$0) {
        const {source:n, target:r, sourceHandle:i = null, targetHandle:a = null} = o;
        n$jscomp$0 = {edgeId:o.id, source:n, target:r, sourceHandle:i, targetHandle:a};
        const l = `${n}-${i}--${r}-${a}`;
        Rr("source", n$jscomp$0, `${r}-${a}--${n}-${i}`, e, n, i);
        Rr("target", n$jscomp$0, l, e, r, a);
        t.set(o.id, o);
      }
    }
    function $r(e$jscomp$0, t) {
      if (null === e$jscomp$0 || null === t) {
        return !1;
      }
      e$jscomp$0 = Array.isArray(e$jscomp$0) ? e$jscomp$0 : [e$jscomp$0];
      t = Array.isArray(t) ? t : [t];
      if (e$jscomp$0.length !== t.length) {
        return !1;
      }
      for (let e = 0; e < e$jscomp$0.length; e++) {
        if (e$jscomp$0[e].id !== t[e].id || e$jscomp$0[e].type !== t[e].type || !Object.is(e$jscomp$0[e].data, t[e].data)) {
          return !1;
        }
      }
      return !0;
    }
    function Tr(e, t) {
      if (!e.parentId) {
        return !1;
      }
      e = t.get(e.parentId);
      return !!e && (!!e.selected || Tr(e, t));
    }
    function Vr(e, t, n) {
      do {
        if (e?.matches?.(t)) {
          return !0;
        }
        if (e === n) {
          break;
        }
        e = e?.parentElement;
      } while (e);
      return !1;
    }
    function Br({nodeId:e, dragItems:t, nodeLookup:n, dragging:o = !0}) {
      const r = [];
      for (const [e, i] of t) {
        const t = n.get(e)?.internals.userNode;
        t && r.push({...t, position:i.position, dragging:o});
      }
      if (!e) {
        return [r[0], r];
      }
      n = n.get(e)?.internals.userNode;
      return [n ? {...n, position:t.get(e)?.position || n.position, dragging:o} : r[0], r];
    }
    function jr({onNodeMouseDown:e, getStoreItems:t$jscomp$0, onDragStart:n, onDrag:o, onDragStop:r}) {
      let i = {x:null, y:null}, a = 0, s$jscomp$0 = new Map(), l = !1, c = {x:0, y:0}, u = null, d = !1, h = null, f = !1, g = !1, p = null;
      return {update:function({noDragClassName:m, handleSelector:y, domNode:v, isSelectable:x, nodeId:w, nodeClickDistance:b = 0}) {
        function S({x:e, y:n}) {
          const {nodeLookup:r, nodeExtent:a, snapGrid:l, snapToGrid:c, nodeOrigin:u, onNodeDrag:d, onSelectionDrag:h, onError:f, updateNodePositions:m} = t$jscomp$0();
          i = {x:e, y:n};
          let y = !1;
          const v = 1 < s$jscomp$0.size, x = v && a ? Do(Co(s$jscomp$0)) : null, b = v && c ? function({dragItems:e, snapGrid:t, x:n, y:o}) {
            e = e.values().next().value;
            if (!e) {
              return null;
            }
            n = {x:n - e.distance.x, y:o - e.distance.y};
            t = Zo(n, t);
            return {x:t.x - n.x, y:t.y - n.y};
          }({dragItems:s$jscomp$0, snapGrid:l, x:e, y:n}) : null;
          for (const [t, o] of s$jscomp$0) {
            if (!r.has(t)) {
              continue;
            }
            let i = {x:e - o.distance.x, y:n - o.distance.y};
            c && (i = b ? {x:Math.round(i.x + b.x), y:Math.round(i.y + b.y)} : Zo(i, l));
            var s = null;
            v && a && !o.extent && x && ({positionAbsolute:s} = o.internals, s = [[s.x - x.x + a[0][0], s.y - x.y + a[0][1]], [s.x + o.measured.width - x.x2 + a[1][0], s.y + o.measured.height - x.y2 + a[1][1]]]);
            const {position:d, positionAbsolute:h} = No({nodeId:t, nextPosition:i, nodeLookup:r, nodeExtent:s || a, nodeOrigin:u, onError:f});
            y = y || o.position.x !== d.x || o.position.y !== d.y;
            o.position = d;
            o.internals.positionAbsolute = h;
          }
          if (g = g || y, y && (m(s$jscomp$0, !0), p && (o || d || !w && h))) {
            const [e, t] = Br({nodeId:w, dragItems:s$jscomp$0, nodeLookup:r});
            o?.(p, s$jscomp$0, e, t);
            d?.(p, e, t);
            w || h?.(p, t);
          }
        }
        async function C() {
          if (u) {
            var {transform:e, panBy:n, autoPanSpeed:o, autoPanOnNodeDrag:r} = t$jscomp$0();
            if (!r) {
              return l = !1, void cancelAnimationFrame(a);
            }
            var [s, d] = Io(c, u, o);
            0 === s && 0 === d || (i.x = (i.x ?? 0) - s / e[2], i.y = (i.y ?? 0) - d / e[2], await n({x:s, y:d}) && S(i));
            a = requestAnimationFrame(C);
          }
        }
        function E(o) {
          const {nodeLookup:r, multiSelectionActive:a, nodesDraggable:l, transform:c, snapGrid:h, snapToGrid:f, selectNodesOnDrag:g, onNodeDragStart:p, onSelectionDragStart:m, unselectNodesAndEdges:y} = t$jscomp$0();
          d = !0;
          g && x || a || !w || r.get(w)?.selected || y();
          x && g && w && e?.(w);
          const v = er(o.sourceEvent, {transform:c, snapGrid:h, snapToGrid:f, containerBounds:u});
          i = v;
          const r$jscomp$0 = new Map();
          for (const [i, a] of r) {
            if (!(!a.selected && a.id !== w || a.parentId && Tr(a, r)) && (a.draggable || l && void 0 === a.draggable)) {
              const t = r.get(i);
              t && r$jscomp$0.set(i, {id:i, position:t.position || {x:0, y:0}, distance:{x:v.x - t.internals.positionAbsolute.x, y:v.y - t.internals.positionAbsolute.y}, extent:t.extent, parentId:t.parentId, origin:t.origin, expandParent:t.expandParent, internals:{positionAbsolute:t.internals.positionAbsolute || {x:0, y:0}}, measured:{width:t.measured.width ?? 0, height:t.measured.height ?? 0}});
            }
          }
          if (s$jscomp$0 = r$jscomp$0, 0 < s$jscomp$0.size && (n || p || !w && m)) {
            const [e, t] = Br({nodeId:w, dragItems:s$jscomp$0, nodeLookup:r});
            n?.(o.sourceEvent, s$jscomp$0, e, t);
            p?.(o.sourceEvent, e, t);
            w || m?.(o.sourceEvent, t);
          }
        }
        h = Se(v);
        b = Le().clickDistance(b).on("start", e => {
          const {domNode:n, nodeDragThreshold:o, transform:r, snapGrid:a, snapToGrid:s} = t$jscomp$0();
          u = n?.getBoundingClientRect() || null;
          g = f = !1;
          p = e.sourceEvent;
          0 === o && E(e);
          i = er(e.sourceEvent, {transform:r, snapGrid:a, snapToGrid:s, containerBounds:u});
          c = ar(e.sourceEvent, u);
        }).on("drag", e => {
          const {autoPanOnNodeDrag:n, transform:o, snapGrid:r, snapToGrid:a, nodeDragThreshold:h, nodeLookup:g} = t$jscomp$0(), m = er(e.sourceEvent, {transform:o, snapGrid:r, snapToGrid:a, containerBounds:u});
          if (p = e.sourceEvent, ("touchmove" === e.sourceEvent.type && 1 < e.sourceEvent.touches.length || w && !g.has(w)) && (f = !0), !f) {
            if (!l && n && d && (l = !0, C()), !d) {
              var t = ar(e.sourceEvent, u);
              const n = t.x - c.x;
              t = t.y - c.y;
              Math.sqrt(n * n + t * t) > h && E(e);
            }
            (i.x !== m.xSnapped || i.y !== m.ySnapped) && s$jscomp$0 && d && (c = ar(e.sourceEvent, u), S(m));
          }
        }).on("end", e => {
          if (d && !f && (l = !1, d = !1, cancelAnimationFrame(a), 0 < s$jscomp$0.size)) {
            const {nodeLookup:n, updateNodePositions:o, onNodeDragStop:i, onSelectionDragStop:a} = t$jscomp$0();
            if (g && (o(s$jscomp$0, !1), g = !1), r || i || !w && a) {
              const [t, o] = Br({nodeId:w, dragItems:s$jscomp$0, nodeLookup:n, dragging:!1});
              r?.(e.sourceEvent, s$jscomp$0, t, o);
              i?.(e.sourceEvent, t, o);
              w || a?.(e.sourceEvent, o);
            }
          }
        }).filter(e => {
          const t = e.target;
          return !e.button && (!m || !Vr(t, `.${m}`, v)) && (!y || Vr(t, y, v));
        });
        h.call(b);
      }, destroy:function() {
        h?.on(".drag", null);
      }};
    }
    function Zr(e, t, n$jscomp$0, o) {
      let r = [], i = 1 / 0;
      n$jscomp$0 = function(e$jscomp$0, t, n) {
        const o = [];
        e$jscomp$0 = {x:e$jscomp$0.x - n, y:e$jscomp$0.y - n, width:2 * n, height:2 * n};
        for (const e of t.values()) {
          0 < Vo(e$jscomp$0, Lo(e)) && o.push(e);
        }
        return o;
      }(e, n$jscomp$0, t + 250);
      for (const n of n$jscomp$0) {
        n$jscomp$0 = [...(n.internals.handleBounds?.source ?? []), ...(n.internals.handleBounds?.target ?? [])];
        for (const s of n$jscomp$0) {
          if (o.nodeId === s.nodeId && o.type === s.type && o.id === s.id) {
            continue;
          }
          const {x:a, y:l} = Cr(n, s, s.position, !0);
          n$jscomp$0 = Math.sqrt(Math.pow(a - e.x, 2) + Math.pow(l - e.y, 2));
          n$jscomp$0 > t || (n$jscomp$0 < i ? (r = [{...s, x:a, y:l}], i = n$jscomp$0) : n$jscomp$0 === i && r.push({...s, x:a, y:l}));
        }
      }
      if (!r.length) {
        return null;
      }
      if (1 < r.length) {
        const e = "source" === o.type ? "target" : "source";
        return r.find(t => t.type === e) ?? r[0];
      }
      return r[0];
    }
    function Xr(e, t, n, o, r, i = !1) {
      e = o.get(e);
      if (!e) {
        return null;
      }
      t = "strict" === r ? e.internals.handleBounds?.[t] : [...(e.internals.handleBounds?.source ?? []), ...(e.internals.handleBounds?.target ?? [])];
      return (t = (n ? t?.find(e => e.id === n) : t?.[0]) ?? null) && i ? {...t, ...Cr(e, t, t.position, !0)} : t;
    }
    function Yr(e, t) {
      return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
    }
    function Wr(t, {handle:n, connectionMode:o, fromNodeId:r, fromHandleId:i, fromType:a, doc:s, lib:l, flowId:c$jscomp$0, isValidConnection:u = Fr, nodeLookup:d}) {
      a = "target" === a;
      n = n ? s.querySelector(`.${l}-flow__handle[data-id="${c$jscomp$0}-${n?.nodeId}-${n?.id}-${n?.type}"]`) : null;
      const {x:g, y:p} = ar(t);
      t = s.elementFromPoint(g, p);
      var y = t?.classList.contains(`${l}-flow__handle`) ? t : n;
      l = {handleDomNode:y, isValid:!1, connection:null, toHandle:null};
      if (y) {
        t = Yr(void 0, y);
        s = y.getAttribute("data-nodeid");
        n = y.getAttribute("data-handleid");
        c$jscomp$0 = y.classList.contains("connectable");
        y = y.classList.contains("connectableend");
        if (!s || !t) {
          return l;
        }
        const c = {source:a ? s : r, sourceHandle:a ? n : i, target:a ? r : s, targetHandle:a ? i : n};
        l.connection = c;
        l.isValid = c$jscomp$0 && y && (o === e$jscomp$0.ConnectionMode.Strict ? a && "source" === t || !a && "target" === t : s !== r || n !== i) && u(c);
        l.toHandle = Xr(s, t, n, d, o, !0);
      }
      return l;
    }
    function oi({domNode:t, minZoom:n, maxZoom:o, paneClickDistance:r, translateExtent:i, viewport:a, onPanZoom:s, onPanZoomStart:l, onPanZoomEnd:c, onDraggingChange:u}) {
      function y(e, t) {
        return g ? new Promise(n => {
          f?.interpolate("linear" === t?.interpolate ? Pt : Bt).transform(ti(g, t?.duration, t?.ease, () => n(!0)), e);
        }) : Promise.resolve(!1);
      }
      function v() {
        f.on("zoom", null);
      }
      async function x(e, t, n) {
        e = Ur(e);
        const r = f?.constrain()(e, t, n);
        return r && await y(r), new Promise(e => e(r));
      }
      const d = {isZoomingOrPanning:!1, usedRightMouseButton:!1, prevViewport:{x:0, y:0, zoom:0}, mouseButton:0, timerId:void 0, panScrollTimeout:void 0, isPanScrolling:!1}, h = t.getBoundingClientRect(), f = no().clickDistance(!jo(r) || 0 > r ? 0 : r).scaleExtent([n, o]).translateExtent(i), g = Se(t).call(f);
      x({x:a.x, y:a.y, zoom:_o(a.zoom, n, o)}, [[0, 0], [h.width, h.height]], i);
      const p = g.on("wheel.zoom"), m = g.on("dblclick.zoom");
      return f.wheelDelta(ni), {update:function({noWheelClassName:t, noPanClassName:n, onPaneContextMenu:o, userSelectionActive:r, panOnScroll:i, panOnDrag:a, panOnScrollMode:h, panOnScrollSpeed:y, preventScrolling:x, zoomOnPinch:w, zoomOnScroll:b, zoomOnDoubleClick:S, zoomActivationKeyPressed:C, lib:E, onTransformChange:k, connectionInProgress:M}) {
        r && !d.isZoomingOrPanning && v();
        h = !i || C || r ? function({noWheelClassName:e, preventScrolling:t, d3ZoomHandler:n}) {
          return function(o, r) {
            const i = "wheel" === o.type, a = !t && i && !o.ctrlKey, s = o.target.closest(`.${e}`);
            if (o.ctrlKey && i && s && o.preventDefault(), a || s) {
              return null;
            }
            o.preventDefault();
            n.call(this, o, r);
          };
        }({noWheelClassName:t, preventScrolling:x, d3ZoomHandler:p}) : function({zoomPanValues:t$jscomp$0, noWheelClassName:n, d3Selection:o, d3Zoom:r, panOnScrollMode:i, panOnScrollSpeed:a, zoomOnPinch:s, onPanZoomStart:l, onPanZoom:c, onPanZoomEnd:u}) {
          return d => {
            if (d.target.closest(`.${n}`)) {
              return !1;
            }
            d.preventDefault();
            d.stopImmediatePropagation();
            const h = o.property("__zoom").k || 1;
            if (d.ctrlKey && s) {
              var e = Ce(d), t = ni(d);
              return void r.scaleTo(o, h * Math.pow(2, t), e, d);
            }
            e = 1 === d.deltaMode ? 20 : 1;
            t = i === e$jscomp$0.PanOnScrollMode.Vertical ? 0 : d.deltaX * e;
            let p = i === e$jscomp$0.PanOnScrollMode.Horizontal ? 0 : d.deltaY * e;
            !Ko() && d.shiftKey && i !== e$jscomp$0.PanOnScrollMode.Vertical && (t = d.deltaY * e, p = 0);
            r.translateBy(o, -t / h * a, -p / h * a, {internal:!0});
            const m = qr(o.property("__zoom"));
            clearTimeout(t$jscomp$0.panScrollTimeout);
            t$jscomp$0.isPanScrolling || (t$jscomp$0.isPanScrolling = !0, l?.(d, m));
            t$jscomp$0.isPanScrolling && (c?.(d, m), t$jscomp$0.panScrollTimeout = setTimeout(() => {
              u?.(d, m);
              t$jscomp$0.isPanScrolling = !1;
            }, 150));
          };
        }({zoomPanValues:d, noWheelClassName:t, d3Selection:g, d3Zoom:f, panOnScrollMode:h, panOnScrollSpeed:y, zoomOnPinch:w, onPanZoomStart:l, onPanZoom:s, onPanZoomEnd:c});
        (g.on("wheel.zoom", h, {passive:!1}), r) || (h = function({zoomPanValues:e, onDraggingChange:t, onPanZoomStart:n}) {
          return o => {
            if (!o.sourceEvent?.internal) {
              var r = qr(o.transform);
              e.mouseButton = o.sourceEvent?.button || 0;
              e.isZoomingOrPanning = !0;
              e.prevViewport = r;
              "mousedown" === o.sourceEvent?.type && t(!0);
              n && n?.(o.sourceEvent, r);
            }
          };
        }({zoomPanValues:d, onDraggingChange:u, onPanZoomStart:l}), f.on("start", h), k = function({zoomPanValues:e, panOnDrag:t, onPaneContextMenu:n, onTransformChange:o, onPanZoom:r}) {
          return i => {
            e.usedRightMouseButton = !(!n || !Jr(t, e.mouseButton ?? 0));
            i.sourceEvent?.sync || o([i.transform.x, i.transform.y, i.transform.k]);
            r && !i.sourceEvent?.internal && r?.(i.sourceEvent, qr(i.transform));
          };
        }({zoomPanValues:d, panOnDrag:a, onPaneContextMenu:!!o, onPanZoom:s, onTransformChange:k}), f.on("zoom", k), o = function({zoomPanValues:e, panOnDrag:t, panOnScroll:n, onDraggingChange:o, onPanZoomEnd:r, onPaneContextMenu:i}) {
          return a => {
            if (!a.sourceEvent?.internal && (e.isZoomingOrPanning = !1, i && Jr(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && a.sourceEvent && i(a.sourceEvent), e.usedRightMouseButton = !1, o(!1), r && Gr(e.prevViewport, a.transform))) {
              const t = qr(a.transform);
              e.prevViewport = t;
              clearTimeout(e.timerId);
              e.timerId = setTimeout(() => {
                r?.(a.sourceEvent, t);
              }, n ? 150 : 0);
            }
          };
        }({zoomPanValues:d, panOnDrag:a, panOnScroll:i, onPaneContextMenu:o, onPanZoomEnd:c, onDraggingChange:u}), f.on("end", o));
        t = function({zoomActivationKeyPressed:e, zoomOnScroll:t, zoomOnPinch:n, panOnDrag:o, panOnScroll:r, zoomOnDoubleClick:i, userSelectionActive:a, noWheelClassName:s, noPanClassName:l, lib:c, connectionInProgress:u}) {
          return d => {
            var h = e || t;
            const f = n && d.ctrlKey, g = "wheel" === d.type;
            if (1 === d.button && "mousedown" === d.type && (d.target.closest(`.${`${c}-flow__node`}`) || d.target.closest(`.${`${c}-flow__edge`}`))) {
              return !0;
            }
            if (!(o || h || r || i || n) || a || u && !g || d.target.closest(`.${s}`) && g || d.target.closest(`.${l}`) && (!g || r && g && !e) || !n && d.ctrlKey && g) {
              return !1;
            }
            if (!n && "touchstart" === d.type && 1 < d.touches?.length) {
              return d.preventDefault(), !1;
            }
            if (!h && !r && !f && g || !o && ("mousedown" === d.type || "touchstart" === d.type) || Array.isArray(o) && !o.includes(d.button) && "mousedown" === d.type) {
              return !1;
            }
            h = Array.isArray(o) && o.includes(d.button) || !d.button || 1 >= d.button;
            return (!d.ctrlKey || g) && h;
          };
        }({zoomActivationKeyPressed:C, panOnDrag:a, zoomOnScroll:b, panOnScroll:i, zoomOnDoubleClick:S, zoomOnPinch:w, userSelectionActive:r, noPanClassName:n, noWheelClassName:t, lib:E, connectionInProgress:M});
        f.filter(t);
        S ? g.on("dblclick.zoom", m) : g.on("dblclick.zoom", null);
      }, destroy:v, setViewport:async function(e, t) {
        const n = Ur(e);
        return await y(n, t), new Promise(e => e(n));
      }, setViewportConstrained:x, getViewport:function() {
        const e = g ? Wn(g.node()) : {x:0, y:0, k:1};
        return {x:e.x, y:e.y, zoom:e.k};
      }, scaleTo:function(e, t) {
        return g ? new Promise(n => {
          f?.interpolate("linear" === t?.interpolate ? Pt : Bt).scaleTo(ti(g, t?.duration, t?.ease, () => n(!0)), e);
        }) : Promise.resolve(!1);
      }, scaleBy:function(e, t) {
        return g ? new Promise(n => {
          f?.interpolate("linear" === t?.interpolate ? Pt : Bt).scaleBy(ti(g, t?.duration, t?.ease, () => n(!0)), e);
        }) : Promise.resolve(!1);
      }, setScaleExtent:function(e) {
        f?.scaleExtent(e);
      }, setTranslateExtent:function(e) {
        f?.translateExtent(e);
      }, syncViewport:function(e) {
        if (g) {
          const t = Ur(e), n = g.property("__zoom");
          n.k === e.zoom && n.x === e.x && n.y === e.y || f?.transform(g, t, null, {sync:!0});
        }
      }, setClickDistance:function(e) {
        e = !jo(e) || 0 > e ? 0 : e;
        f?.clickDistance(e);
      }};
    }
    function ci(e, t, n) {
      return Math.max(0, t - e, e - n);
    }
    function gi({domNode:e, nodeId:t$jscomp$0, getStoreItems:n$jscomp$1, onChange:o, onEnd:r}) {
      const i = Se(e);
      return {update:function({controlPosition:e, boundaries:a, keepAspectRatio:s, resizeDirection:l, onResizeStart:c, onResize:u, onResizeEnd:d, shouldResize:h}) {
        let f = {...di}, g = {...hi};
        const p = function(e) {
          return {isHorizontal:e.includes("right") || e.includes("left"), isVertical:e.includes("bottom") || e.includes("top"), affectsX:e.includes("left"), affectsY:e.includes("top")};
        }(e);
        let m, y, v, x, w = null, b = [], S = !1;
        e = Le().on("start", e => {
          const {nodeLookup:o, transform:r, snapGrid:i, snapToGrid:a, nodeOrigin:s$jscomp$0, paneDomNode:l} = n$jscomp$1();
          if (m = o.get(t$jscomp$0), m) {
            w = l?.getBoundingClientRect() ?? null;
            var {xSnapped:u, ySnapped:d} = er(e.sourceEvent, {transform:r, snapGrid:i, snapToGrid:a, containerBounds:w});
            f = {width:m.measured.width ?? 0, height:m.measured.height ?? 0, x:m.position.x ?? 0, y:m.position.y ?? 0};
            g = {...f, pointerX:u, pointerY:d, aspectRatio:f.width / f.height};
            y = void 0;
            m.parentId && ("parent" === m.extent || m.expandParent) && (y = o.get(m.parentId), v = y && "parent" === m.extent ? [[0, 0], [y.measured.width, y.measured.height]] : void 0);
            b = [];
            x = void 0;
            for (const [e, n] of o) {
              if (n.parentId === t$jscomp$0 && (b.push({id:e, position:{...n.position}, extent:n.extent}), "parent" === n.extent || n.expandParent)) {
                var e$jscomp$0 = n, t = m, n$jscomp$0 = n.origin ?? s$jscomp$0, o$jscomp$0 = t.position.x + e$jscomp$0.position.x;
                t = t.position.y + e$jscomp$0.position.y;
                const i = e$jscomp$0.measured.width ?? 0;
                e$jscomp$0 = e$jscomp$0.measured.height ?? 0;
                const s = n$jscomp$0[0] * i;
                n$jscomp$0 = n$jscomp$0[1] * e$jscomp$0;
                o$jscomp$0 = [[o$jscomp$0 - s, t - n$jscomp$0], [o$jscomp$0 + i - s, t + e$jscomp$0 - n$jscomp$0]];
                x = x ? [[Math.min(o$jscomp$0[0][0], x[0][0]), Math.min(o$jscomp$0[0][1], x[0][1])], [Math.max(o$jscomp$0[1][0], x[1][0]), Math.max(o$jscomp$0[1][1], x[1][1])]] : o$jscomp$0;
              }
            }
            c?.(e, {...f});
          }
        }).on("drag", e => {
          const {transform:t, snapGrid:r, snapToGrid:i, nodeOrigin:c} = n$jscomp$1();
          var d = er(e.sourceEvent, {transform:t, snapGrid:r, snapToGrid:i, containerBounds:w});
          const C = [];
          if (m) {
            var {x:E, y:k, width:M, height:N} = f, _ = {}, P = m.origin ?? c, {width:z, height:O, x:I, y:A} = function(e$jscomp$0, t$jscomp$0, n, o, r, i, a, s) {
              let {affectsX:l, affectsY:c} = t$jscomp$0;
              const {isHorizontal:u, isVertical:d} = t$jscomp$0;
              t$jscomp$0 = u && d;
              const {xSnapped:f, ySnapped:g} = n, {minWidth:p, maxWidth:m, minHeight:y, maxHeight:v} = o, {x, y:w, width:b, height:S, aspectRatio:C} = e$jscomp$0;
              n = Math.floor(u ? f - e$jscomp$0.pointerX : 0);
              e$jscomp$0 = Math.floor(d ? g - e$jscomp$0.pointerY : 0);
              o = b + (l ? -n : n);
              const N = S + (c ? -e$jscomp$0 : e$jscomp$0), _ = -i[0] * b;
              var P = -i[1] * S;
              let z = ci(o, p, m), O = ci(N, y, v);
              if (a) {
                var e = 0, t = 0;
                l && 0 > n ? e = Math.max(0, a[0][0] - (x + n + _)) : !l && 0 < n && (e = Math.max(0, x + o + _ - a[1][0]));
                c && 0 > e$jscomp$0 ? t = Math.max(0, a[0][1] - (w + e$jscomp$0 + P)) : !c && 0 < e$jscomp$0 && (t = Math.max(0, w + N + P - a[1][1]));
                z = Math.max(z, e);
                O = Math.max(O, t);
              }
              s && (t = e = 0, l && 0 < n ? e = Math.max(0, x + n - s[0][0]) : !l && 0 > n && (e = Math.max(0, s[1][0] - (x + o))), c && 0 < e$jscomp$0 ? t = Math.max(0, w + e$jscomp$0 - s[0][1]) : !c && 0 > e$jscomp$0 && (t = Math.max(0, s[1][1] - (w + N))), z = Math.max(z, e), O = Math.max(O, t));
              if (r) {
                if (u) {
                  e = ci(o / C, y, v) * C;
                  if (z = Math.max(z, e), a) {
                    z = Math.max(z, !l && !c || l && !c && t$jscomp$0 ? Math.max(0, w + P + o / C - a[1][1]) * C : Math.max(0, a[0][1] - (w + P + (l ? n : -n) / C)) * C);
                  }
                  s && (z = Math.max(z, !l && !c || l && !c && t$jscomp$0 ? Math.max(0, s[1][1] - (w + o / C)) * C : Math.max(0, w + (l ? n : -n) / C - s[0][1]) * C));
                }
                if (d) {
                  P = ci(N * C, p, m) / C;
                  if (O = Math.max(O, P), a) {
                    O = Math.max(O, !l && !c || c && !l && t$jscomp$0 ? Math.max(0, x + N * C + _ - a[1][0]) / C : Math.max(0, a[0][0] - (x + (c ? e$jscomp$0 : -e$jscomp$0) * C + _)) / C);
                  }
                  s && (O = Math.max(O, !l && !c || c && !l && t$jscomp$0 ? Math.max(0, s[1][0] - (x + N * C)) / C : Math.max(0, x + (c ? e$jscomp$0 : -e$jscomp$0) * C - s[0][0]) / C));
                }
              }
              e$jscomp$0 += 0 > e$jscomp$0 ? O : -O;
              n += 0 > n ? z : -z;
              r && (t$jscomp$0 ? o > N * C ? e$jscomp$0 = ((l ? !c : c) ? -n : n) / C : n = ((l ? !c : c) ? -e$jscomp$0 : e$jscomp$0) * C : u ? (e$jscomp$0 = n / C, c = l) : (n = e$jscomp$0 * C, l = c));
              return {width:b + (l ? -n : n), height:S + (c ? -e$jscomp$0 : e$jscomp$0), x:i[0] * n * (l ? -1 : 1) + (l ? x + n : x), y:i[1] * e$jscomp$0 * (c ? -1 : 1) + (c ? w + e$jscomp$0 : w)};
            }(g, p, d, a, s, P, v, x);
            d = z !== M;
            var R = O !== N, L = I !== E && d, $ = A !== k && R;
            if (L || $ || d || R) {
              if ((L || $ || 1 === P[0] || 1 === P[1]) && (_.x = L ? I : f.x, _.y = $ ? A : f.y, f.x = _.x, f.y = _.y, 0 < b.length)) {
                L = I - E;
                $ = A - k;
                for (var n of b) {
                  n.position = {x:n.position.x - L + P[0] * (z - M), y:n.position.y - $ + P[1] * (O - N)}, C.push(n);
                }
              }
              if ((d || R) && (_.width = !d || l && "horizontal" !== l ? f.width : z, _.height = !R || l && "vertical" !== l ? f.height : O, f.width = _.width, f.height = _.height), y && m.expandParent) {
                n = P[0] * (_.width ?? 0), _.x && _.x < n && (f.x = n, g.x -= _.x - n), P = P[1] * (_.height ?? 0), _.y && _.y < P && (f.y = P, g.y -= _.y - P);
              }
              P = function({width:e, prevWidth:t, height:n, prevHeight:o, affectsX:r, affectsY:i}) {
                e -= t;
                n -= o;
                o = [0 < e ? 1 : 0 > e ? -1 : 0, 0 < n ? 1 : 0 > n ? -1 : 0];
                return e && r && (o[0] *= -1), n && i && (o[1] *= -1), o;
              }({width:f.width, prevWidth:M, height:f.height, prevHeight:N, affectsX:p.affectsX, affectsY:p.affectsY});
              P = {...f, direction:P};
              !1 !== h?.(e, P) && (S = !0, u?.(e, P), o(_, C));
            }
          }
        }).on("end", e => {
          S && (d?.(e, {...f}), r?.({...f}), S = !1);
        });
        i.call(e);
      }, destroy:function() {
        i.on(".drag", null);
      }};
    }
    function Ci() {
      return yi || (yi = 1, JSCompiler_object_inline_exports_1635 = function() {
        function s(e) {
          var n = e.getSnapshot;
          e = e.value;
          try {
            var o = n();
            return !t(e, o);
          } catch (e) {
            return !0;
          }
        }
        if (mi) {
          return Si;
        }
        mi = 1;
        var t = "function" == typeof Object.is ? Object.is : function(e, t) {
          return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t;
        }, o = n$jscomp$0.useState, r = n$jscomp$0.useEffect, i = n$jscomp$0.useLayoutEffect, a = n$jscomp$0.useDebugValue, l = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function(e, t) {
          return t();
        } : function(e, t) {
          var n = t(), l = o({inst:{value:n, getSnapshot:t}}), c = l[0].inst, u = l[1];
          return i(function() {
            c.value = n;
            c.getSnapshot = t;
            s(c) && u({inst:c});
          }, [e, n, t]), r(function() {
            return s(c) && u({inst:c}), e(function() {
              s(c) && u({inst:c});
            });
          }, [e]), a(n), n;
        };
        return Si.useSyncExternalStore = void 0 !== n$jscomp$0.useSyncExternalStore ? n$jscomp$0.useSyncExternalStore : l, Si;
      }()), JSCompiler_object_inline_exports_1635;
    }
    function Ni(e, t = e.getState, o) {
      e = Mi(e.subscribe, e.getState, e.getServerState || e.getState, t, o);
      return n$jscomp$0.useDebugValue(e), e;
    }
    function Ii(e, t) {
      const o = n$jscomp$0.useContext(Pi);
      if (null === o) {
        throw Error(Oi);
      }
      return Ni(o, e, t);
    }
    function Ai() {
      const e = n$jscomp$0.useContext(Pi);
      if (null === e) {
        throw Error(Oi);
      }
      return n$jscomp$0.useMemo(() => ({getState:e.getState, setState:e.setState, subscribe:e.subscribe}), [e]);
    }
    function ji({rfId:e}) {
      const n = Ii(Vi);
      return t.jsx("div", {id:`${"react-flow__aria-live"}-${e}`, "aria-live":"assertive", "aria-atomic":"true", style:Ri, children:n});
    }
    function Hi({rfId:e, disableKeyboardA11y:n}) {
      const o = Ii(Bi);
      return t.jsxs(t.Fragment, {children:[t.jsx("div", {id:`${"react-flow__node-desc"}-${e}`, style:Di, children:n ? o["node.a11yDescription.default"] : o["node.a11yDescription.keyboardDisabled"]}), t.jsx("div", {id:`${"react-flow__edge-desc"}-${e}`, style:Di, children:o["edge.a11yDescription.default"]}), !n && t.jsx(ji, {rfId:e})]});
    }
    function Xi({proOptions:e, position:n = "bottom-right"}) {
      return e?.hideAttribution ? null : t.jsx(Zi, {position:n, className:"react-flow__attribution", "data-message":"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children:t.jsx("a", {href:"https://reactflow.dev", target:"_blank", rel:"noopener noreferrer", "aria-label":"React Flow attribution", children:"React Flow"})});
    }
    function Yi(e, t) {
      if (Object.is(e, t)) {
        return !0;
      }
      if ("object" != typeof e || null === e || "object" != typeof t || null === t) {
        return !1;
      }
      if (e instanceof Map && t instanceof Map) {
        if (e.size !== t.size) {
          return !1;
        }
        for (const [n, o] of e) {
          if (!Object.is(o, t.get(n))) {
            return !1;
          }
        }
        return !0;
      }
      if (e instanceof Set && t instanceof Set) {
        if (e.size !== t.size) {
          return !1;
        }
        for (var n of e) {
          if (!t.has(n)) {
            return !1;
          }
        }
        return !0;
      }
      n = Object.keys(e);
      if (n.length !== Object.keys(t).length) {
        return !1;
      }
      for (let o = 0; o < n.length; o++) {
        if (!Object.prototype.hasOwnProperty.call(t, n[o]) || !Object.is(e[n[o]], t[n[o]])) {
          return !1;
        }
      }
      return !0;
    }
    function Ki(e, t) {
      return Yi(e.selectedNodes.map(Wi), t.selectedNodes.map(Wi)) && Yi(e.selectedEdges.map(Wi), t.selectedEdges.map(Wi));
    }
    function Gi({onSelectionChange:e}) {
      const t = Ai(), {selectedNodes:o, selectedEdges:r} = Ii(Fi, Ki);
      return n$jscomp$0.useEffect(() => {
        const n = {nodes:o, edges:r};
        e?.(n);
        t.getState().onSelectionChangeHandlers.forEach(e => e(n));
      }, [o, r, e]), null;
    }
    function Ui({onSelectionChange:e}) {
      const n = Ii(qi);
      return e || n ? t.jsx(Gi, {onSelectionChange:e}) : null;
    }
    function oa(e) {
      const {setNodes:t, setEdges:o, setMinZoom:r, setMaxZoom:i, setTranslateExtent:a, setNodeExtent:s, reset:l, setDefaultNodesAndEdges:c, setPaneClickDistance:u} = Ii(ta, Yi), d = Ai();
      n$jscomp$0.useEffect(() => (c(e.defaultNodes, e.defaultEdges), () => {
        h.current = na;
        l();
      }), []);
      const h = n$jscomp$0.useRef(na);
      return n$jscomp$0.useEffect(() => {
        for (const l of ea) {
          const c = e[l];
          c !== h.current[l] && void 0 !== e[l] && ("nodes" === l ? t(c) : "edges" === l ? o(c) : "minZoom" === l ? r(c) : "maxZoom" === l ? i(c) : "translateExtent" === l ? a(c) : "nodeExtent" === l ? s(c) : "paneClickDistance" === l ? u(c) : "ariaLabelConfig" === l ? d.setState({ariaLabelConfig:(n = c, {...ao, ...(n || {})})}) : "fitView" === l ? d.setState({fitViewQueued:c}) : "fitViewOptions" === l ? d.setState({fitViewOptions:c}) : d.setState({[l]:c}));
        }
        var n;
        h.current = e;
      }, ea.map(t => e[t])), null;
    }
    function ra() {
      return "undefined" != typeof window && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;
    }
    function aa(e = null, t = {target:ia, actInsideInputWithModifier:!0}) {
      const [o, r] = n$jscomp$0.useState(!1), i = n$jscomp$0.useRef(!1), a = n$jscomp$0.useRef(new Set([])), [s, l] = n$jscomp$0.useMemo(() => {
        if (null !== e) {
          const t = (Array.isArray(e) ? e : [e]).filter(e => "string" == typeof e).map(e => e.replace("+", "\n").replace("\n\n", "\n+").split("\n")), n = t.reduce((e, t) => e.concat(...t), []);
          return [t, n];
        }
        return [[], []];
      }, [e]);
      return n$jscomp$0.useEffect(() => {
        const n = t?.target ?? ia, o = t?.actInsideInputWithModifier ?? !0;
        if (null !== e) {
          const e = e => {
            i.current = e.ctrlKey || e.metaKey || e.shiftKey || e.altKey;
            if ((!i.current || i.current && !o) && rr(e)) {
              return !1;
            }
            var n = l.includes(e.code) ? "code" : "key";
            if (a.current.add(e[n]), sa(s, a.current, !1)) {
              n = e.composedPath?.()?.[0] || e.target, !1 === t.preventDefault || !i.current && ("BUTTON" === n?.nodeName || "A" === n?.nodeName) || e.preventDefault(), r(!0);
            }
          }, c = e => {
            const t = l.includes(e.code) ? "code" : "key";
            sa(s, a.current, !0) ? (r(!1), a.current.clear()) : a.current.delete(e[t]);
            "Meta" === e.key && a.current.clear();
            i.current = !1;
          }, u = () => {
            a.current.clear();
            r(!1);
          };
          return n?.addEventListener("keydown", e), n?.addEventListener("keyup", c), window.addEventListener("blur", u), window.addEventListener("contextmenu", u), () => {
            n?.removeEventListener("keydown", e);
            n?.removeEventListener("keyup", c);
            window.removeEventListener("blur", u);
            window.removeEventListener("contextmenu", u);
          };
        }
      }, [e, r]), o;
    }
    function sa(e, t, n) {
      return e.filter(e => n || e.length === t.size).some(e => e.every(e => t.has(e)));
    }
    function ua(e, t$jscomp$0) {
      const n = [], o = new Map(), r = [];
      for (var t of e) {
        "add" !== t.type ? "remove" === t.type || "replace" === t.type ? o.set(t.id, [t]) : (e = o.get(t.id)) ? e.push(t) : o.set(t.id, [t]) : r.push(t);
      }
      for (const e of t$jscomp$0) {
        if (t$jscomp$0 = o.get(e.id), !t$jscomp$0) {
          n.push(e);
        } else {
          if ("remove" !== t$jscomp$0[0].type) {
            if ("replace" === t$jscomp$0[0].type) {
              n.push({...t$jscomp$0[0].item});
            } else {
              t = {...e};
              for (const e of t$jscomp$0) {
                switch(e.type) {
                  case "select":
                    t.selected = e.selected;
                    break;
                  case "position":
                    void 0 !== e.position && (t.position = e.position);
                    void 0 !== e.dragging && (t.dragging = e.dragging);
                    break;
                  case "dimensions":
                    void 0 !== e.dimensions && (t.measured ?? (t.measured = {}), t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && (!0 !== e.setAttributes && "width" !== e.setAttributes || (t.width = e.dimensions.width), !0 !== e.setAttributes && "height" !== e.setAttributes || (t.height = e.dimensions.height))), "boolean" == typeof e.resizing && (t.resizing = e.resizing);
                }
              }
              n.push(t);
            }
          }
        }
      }
      return r.length && r.forEach(e => {
        void 0 !== e.index ? n.splice(e.index, 0, {...e.item}) : n.push({...e.item});
      }), n;
    }
    function ga(e, t) {
      return {id:e, type:"select", selected:t};
    }
    function pa(e, t = new Set(), n = !1) {
      const o = [];
      for (const [r, i] of e) {
        e = t.has(r), void 0 === i.selected && !e || i.selected === e || (n && (i.selected = e), o.push(ga(i.id, e)));
      }
      return o;
    }
    function ma({items:e = [], lookup:t}) {
      const n = [], o = new Map(e.map(e => [e.id, e]));
      for (const [o, r] of e.entries()) {
        e = t.get(r.id), e = e?.internals?.userNode ?? e, void 0 !== e && e !== r && n.push({id:r.id, item:r, type:"replace"}), void 0 === e && n.push({item:r, type:"add", index:o});
      }
      for (const [e] of t) {
        void 0 === o.get(e) && n.push({id:e, type:"remove"});
      }
      return n;
    }
    function ya(e) {
      return {id:e.id, type:"remove"};
    }
    function Sa(e) {
      const [t, o] = n$jscomp$0.useState(BigInt(0)), [r] = n$jscomp$0.useState(() => function(e) {
        let t = [];
        return {get:() => t, reset:() => {
          t = [];
        }, push:n => {
          t.push(n);
          e();
        }};
      }(() => o(e => e + BigInt(1))));
      return ba(() => {
        const t = r.get();
        t.length && (e(t), r.reset());
      }, [t]), r;
    }
    function Ea({children:e}) {
      const o = Ai(), r = Sa(n$jscomp$0.useCallback(e => {
        const {nodes:t = [], setNodes:n, hasDefaultNodes:r, onNodesChange:i, nodeLookup:a, fitViewQueued:s} = o.getState();
        let l = t;
        for (const t of e) {
          l = "function" == typeof t ? t(l) : t;
        }
        e = ma({items:l, lookup:a});
        r && n(l);
        0 < e.length ? i?.(e) : s && window.requestAnimationFrame(() => {
          const {fitViewQueued:e, nodes:t, setNodes:n} = o.getState();
          e && n(t);
        });
      }, [])), i = Sa(n$jscomp$0.useCallback(e => {
        const {edges:t = [], setEdges:n, hasDefaultEdges:r, onEdgesChange:i, edgeLookup:a} = o.getState();
        let s = t;
        for (const t of e) {
          s = "function" == typeof t ? t(s) : t;
        }
        r ? n(s) : i && i(ma({items:s, lookup:a}));
      }, [])), a = n$jscomp$0.useMemo(() => ({nodeQueue:r, edgeQueue:i}), []);
      return t.jsx(Ca.Provider, {value:a, children:e});
    }
    function Ma() {
      const e = ca(), t = Ai(), o$jscomp$0 = function() {
        const e = n$jscomp$0.useContext(Ca);
        if (!e) {
          throw Error("useBatchContext must be used within a BatchProvider");
        }
        return e;
      }(), r = Ii(ka), i = n$jscomp$0.useMemo(() => {
        const e = e => t.getState().nodeLookup.get(e), i = e => {
          const {nodeLookup:n, nodeOrigin:o} = t.getState();
          e = va(e) ? e : n.get(e.id);
          const i = e.parentId ? Qo(e.position, e.measured, e.parentId, n, o) : e.position;
          return Lo({...e, position:i, width:e.measured?.width ?? e.width, height:e.measured?.height ?? e.height});
        }, a = (e, t, o = {replace:!1}) => {
          o$jscomp$0.nodeQueue.push(n => n.map(n => {
            if (n.id === e) {
              const e = "function" == typeof t ? t(n) : t;
              return o.replace && va(e) ? e : {...n, ...e};
            }
            return n;
          }));
        }, s = (e, t, n = {replace:!1}) => {
          o$jscomp$0.edgeQueue.push(o => o.map(o => {
            if (o.id === e) {
              const e = "function" == typeof t ? t(o) : t;
              return n.replace && xo(e) ? e : {...o, ...e};
            }
            return o;
          }));
        };
        return {getNodes:() => t.getState().nodes.map(e => ({...e})), getNode:t => e(t)?.internals.userNode, getInternalNode:e, getEdges:() => {
          const {edges:e = []} = t.getState();
          return e.map(e => ({...e}));
        }, getEdge:e => t.getState().edgeLookup.get(e), setNodes:e => {
          o$jscomp$0.nodeQueue.push(e);
        }, setEdges:e => {
          o$jscomp$0.edgeQueue.push(e);
        }, addNodes:e => {
          const t = Array.isArray(e) ? e : [e];
          o$jscomp$0.nodeQueue.push(e => [...e, ...t]);
        }, addEdges:e => {
          const t = Array.isArray(e) ? e : [e];
          o$jscomp$0.edgeQueue.push(e => [...e, ...t]);
        }, toObject:() => {
          const {nodes:e = [], edges:n = [], transform:o} = t.getState(), [r, i, a] = o;
          return {nodes:e.map(e => ({...e})), edges:n.map(e => ({...e})), viewport:{x:r, y:i, zoom:a}};
        }, deleteElements:async({nodes:e$jscomp$0 = [], edges:n = []}) => {
          const {nodes:o, edges:r, onNodesDelete:i, onEdgesDelete:a, triggerNodeChanges:s, triggerEdgeChanges:l, onDelete:c, onBeforeDelete:u} = t.getState(), {nodes:d, edges:h} = await async function({nodesToRemove:e$jscomp$0 = [], edgesToRemove:t = [], nodes:n$jscomp$0, edges:o, onBeforeDelete:r}) {
            var i = new Set(e$jscomp$0.map(e => e.id));
            e$jscomp$0 = [];
            for (const e of n$jscomp$0) {
              if (!1 === e.deletable) {
                continue;
              }
              n$jscomp$0 = i.has(e.id);
              const n = !n$jscomp$0 && e.parentId && e$jscomp$0.find(t => t.id === e.parentId);
              (n$jscomp$0 || n) && e$jscomp$0.push(e);
            }
            t = new Set(t.map(e => e.id));
            i = o.filter(e => !1 !== e.deletable);
            o = ko(e$jscomp$0, i);
            for (const e of i) {
              t.has(e.id) && !o.find(t => t.id === e.id) && o.push(e);
            }
            if (!r) {
              return {edges:o, nodes:e$jscomp$0};
            }
            r = await r({nodes:e$jscomp$0, edges:o});
            return "boolean" == typeof r ? r ? {edges:o, nodes:e$jscomp$0} : {edges:[], nodes:[]} : r;
          }({nodesToRemove:e$jscomp$0, edgesToRemove:n, nodes:o, edges:r, onBeforeDelete:u});
          e$jscomp$0 = 0 < h.length;
          n = 0 < d.length;
          if (e$jscomp$0) {
            var e = h.map(ya);
            a?.(h);
            l(e);
          }
          n && (e = d.map(ya), i?.(d), s(e));
          return (n || e$jscomp$0) && c?.({nodes:d, edges:h}), {deletedNodes:d, deletedEdges:h};
        }, getIntersectingNodes:(e, n = !0, o) => {
          const r = Bo(e), a = r ? e : i(e), s = void 0 !== o;
          return a ? (o || t.getState().nodes).filter(o => {
            var i = t.getState().nodeLookup.get(o.id);
            if (i && !r && (o.id === e.id || !i.internals.positionAbsolute)) {
              return !1;
            }
            o = Lo(s ? o : i);
            i = Vo(o, a);
            return n && 0 < i || i >= o.width * o.height || i >= a.width * a.height;
          }) : [];
        }, isNodeIntersecting:(e, t, n = !0) => {
          e = Bo(e) ? e : i(e);
          if (!e) {
            return !1;
          }
          const r = Vo(e, t);
          return n && 0 < r || r >= t.width * t.height || r >= e.width * e.height;
        }, updateNode:a, updateNodeData:(e, t, n = {replace:!1}) => {
          a(e, e => {
            const o = "function" == typeof t ? t(e) : t;
            return n.replace ? {...e, data:o} : {...e, data:{...e.data, ...o}};
          }, n);
        }, updateEdge:s, updateEdgeData:(e, t, n = {replace:!1}) => {
          s(e, e => {
            const o = "function" == typeof t ? t(e) : t;
            return n.replace ? {...e, data:o} : {...e, data:{...e.data, ...o}};
          }, n);
        }, getNodesBounds:e => {
          const {nodeLookup:n, nodeOrigin:o} = t.getState();
          return So(e, {nodeLookup:n, nodeOrigin:o});
        }, getHandleConnections:({type:e, id:n, nodeId:o}) => Array.from(t.getState().connectionLookup.get(`${o}-${e}${n ? `-${n}` : ""}`)?.values() ?? []), getNodeConnections:({type:e, handleId:n, nodeId:o}) => Array.from(t.getState().connectionLookup.get(`${o}${e ? n ? `-${e}-${n}` : `-${e}` : ""}`)?.values() ?? []), fitView:async e => {
          const n = t.getState().fitViewResolver ?? function() {
            let e, t;
            return {promise:new Promise((n, o) => {
              e = n;
              t = o;
            }), resolve:e, reject:t};
          }();
          return t.setState({fitViewQueued:!0, fitViewOptions:e, fitViewResolver:n}), o$jscomp$0.nodeQueue.push(e => [...e]), n.promise;
        }};
      }, []);
      return n$jscomp$0.useMemo(() => ({...i, ...e, viewportInitialized:r}), [r]);
    }
    function Oa({onPaneContextMenu:o, zoomOnScroll:r = !0, zoomOnPinch:i = !0, panOnScroll:a = !1, panOnScrollSpeed:s = .5, panOnScrollMode:l = e$jscomp$0.PanOnScrollMode.Free, zoomOnDoubleClick:c = !0, panOnDrag:u = !0, defaultViewport:d, translateExtent:h, minZoom:f, maxZoom:g, zoomActivationKeyCode:p, preventScrolling:m = !0, children:y, noWheelClassName:v, noPanClassName:x, onViewportChange:w, isControlledViewport:b, paneClickDistance:S}) {
      const C = Ai(), E = n$jscomp$0.useRef(null), {userSelectionActive:k, lib:M, connectionInProgress:N} = Ii(za, Yi), _ = aa(p), P = n$jscomp$0.useRef();
      !function(e) {
        const t = Ai();
        n$jscomp$0.useEffect(() => {
          const n = () => {
            if (!(e.current && (e.current.checkVisibility?.() ?? 1))) {
              return !1;
            }
            const n = tr(e.current);
            0 !== n.height && 0 !== n.width || t.getState().onError?.("004", oo.error004());
            t.setState({width:n.width || 500, height:n.height || 500});
          };
          if (e.current) {
            n();
            window.addEventListener("resize", n);
            const t = new ResizeObserver(() => n());
            return t.observe(e.current), () => {
              window.removeEventListener("resize", n);
              t && e.current && t.unobserve(e.current);
            };
          }
        }, []);
      }(E);
      const z = n$jscomp$0.useCallback(e => {
        w?.({x:e[0], y:e[1], zoom:e[2]});
        b || C.setState({transform:e});
      }, [w, b]);
      return n$jscomp$0.useEffect(() => {
        if (E.current) {
          P.current = oi({domNode:E.current, minZoom:f, maxZoom:g, translateExtent:h, viewport:d, paneClickDistance:S, onDraggingChange:e => C.setState({paneDragging:e}), onPanZoomStart:(e, t) => {
            const {onViewportChangeStart:n, onMoveStart:o} = C.getState();
            o?.(e, t);
            n?.(t);
          }, onPanZoom:(e, t) => {
            const {onViewportChange:n, onMove:o} = C.getState();
            o?.(e, t);
            n?.(t);
          }, onPanZoomEnd:(e, t) => {
            const {onViewportChangeEnd:n, onMoveEnd:o} = C.getState();
            o?.(e, t);
            n?.(t);
          }});
          const {x:e, y:t, zoom:n} = P.current.getViewport();
          return C.setState({panZoom:P.current, transform:[e, t, n], domNode:E.current.closest(".react-flow")}), () => {
            P.current?.destroy();
          };
        }
      }, []), n$jscomp$0.useEffect(() => {
        P.current?.update({onPaneContextMenu:o, zoomOnScroll:r, zoomOnPinch:i, panOnScroll:a, panOnScrollSpeed:s, panOnScrollMode:l, zoomOnDoubleClick:c, panOnDrag:u, zoomActivationKeyPressed:_, preventScrolling:m, noPanClassName:x, userSelectionActive:k, noWheelClassName:v, lib:M, onTransformChange:z, connectionInProgress:N});
      }, [o, r, i, a, s, l, c, u, _, m, x, k, v, M, z, N]), t.jsx("div", {className:"react-flow__renderer", ref:E, style:Pa, children:y});
    }
    function Aa() {
      const {userSelectionActive:e, userSelectionRect:n} = Ii(Ia, Yi);
      return e && n ? t.jsx("div", {className:"react-flow__selection react-flow__container", style:{width:n.width, height:n.height, transform:`translate(${n.x}px, ${n.y}px)`}}) : null;
    }
    function La({isSelecting:o, selectionKeyPressed:i, selectionMode:a = e$jscomp$0.SelectionMode.Full, panOnDrag:s, selectionOnDrag:l, onSelectionStart:c, onSelectionEnd:u, onPaneClick:d, onPaneContextMenu:h, onPaneScroll:f, onPaneMouseEnter:g, onPaneMouseMove:p, onPaneMouseLeave:m, children:y}) {
      const v = Ai(), {userSelectionActive:x, elementsSelectable:w, dragging:b, connectionInProgress:S} = Ii(Ra, Yi), C = w && (o || x), E = n$jscomp$0.useRef(null), k = n$jscomp$0.useRef(), M = n$jscomp$0.useRef(new Set()), N = n$jscomp$0.useRef(new Set()), _ = n$jscomp$0.useRef(!1), P = n$jscomp$0.useRef(!1), z = e => {
        _.current || S ? _.current = !1 : (d?.(e), v.getState().resetSelectedElements(), v.setState({nodesSelectionActive:!1}));
      }, O = f ? e => f(e) : void 0, I = !0 === s || Array.isArray(s) && s.includes(0);
      return t.jsxs("div", {className:r(["react-flow__pane", {draggable:I, dragging:b, selection:o}]), onClick:C ? void 0 : Da(z, E), onContextMenu:Da(e => {
        Array.isArray(s) && s?.includes(2) ? e.preventDefault() : h?.(e);
      }, E), onWheel:Da(O, E), onPointerEnter:C ? void 0 : g, onPointerDown:C ? e => {
        const {resetSelectedElements:t, domNode:n} = v.getState();
        if (k.current = n?.getBoundingClientRect(), w && o && 0 === e.button && e.target === E.current && k.current) {
          e.target?.setPointerCapture?.(e.pointerId);
          P.current = !0;
          _.current = !1;
          var {x:r, y:i} = ar(e.nativeEvent, k.current);
          t();
          v.setState({userSelectionRect:{width:0, height:0, startX:r, startY:i, x:r, y:i}});
          c?.(e);
        }
      } : p, onPointerMove:C ? t$jscomp$0 => {
        const {userSelectionRect:n, transform:o, nodeLookup:r, edgeLookup:i, connectionLookup:s, triggerNodeChanges:l, triggerEdgeChanges:c, defaultEdgeOptions:u} = v.getState();
        if (k.current && n) {
          _.current = !0;
          var {x:d, y:h} = ar(t$jscomp$0.nativeEvent, k.current), {startX:f, startY:g} = n;
          t$jscomp$0 = {startX:f, startY:g, x:d < f ? d : f, y:h < g ? h : g, width:Math.abs(d - f), height:Math.abs(h - g)};
          var m = M.current, y = N.current;
          M.current = new Set(Eo(r, t$jscomp$0, o, a === e$jscomp$0.SelectionMode.Partial, !0).map(e => e.id));
          N.current = new Set();
          var x = u?.selectable ?? !0;
          for (const e of M.current) {
            var t = s.get(e);
            if (t) {
              for (const {edgeId:e} of t.values()) {
                (t = i.get(e)) && (t.selectable ?? x) && N.current.add(e);
              }
            }
          }
          Jo(m, M.current) || l(pa(r, M.current, !0));
          Jo(y, N.current) || c(pa(i, N.current));
          v.setState({userSelectionRect:t$jscomp$0, userSelectionActive:!0, nodesSelectionActive:!1});
        }
      } : p, onPointerUp:C ? e => {
        if (0 === e.button && P.current) {
          e.target?.releasePointerCapture?.(e.pointerId);
          var {userSelectionRect:t} = v.getState();
          !x && t && e.target === E.current && z?.(e);
          v.setState({userSelectionActive:!1, userSelectionRect:null, nodesSelectionActive:0 < M.current.size});
          u?.(e);
          (i || l) && (_.current = !1);
          P.current = !1;
        }
      } : void 0, onPointerLeave:m, ref:E, style:Pa, children:[y, t.jsx(Aa, {})]});
    }
    function $a({id:e, store:t, unselect:n = !1, nodeRef:o}) {
      const {addSelectedNodes:r, unselectNodesAndEdges:i, multiSelectionActive:a, nodeLookup:s, onError:l} = t.getState(), c = s.get(e);
      c ? (t.setState({nodesSelectionActive:!1}), c.selected ? (n || c.selected && a) && (i({nodes:[c], edges:[]}), requestAnimationFrame(() => o?.current?.blur())) : r([e])) : l?.("012", oo.error012(e));
    }
    function Ta({nodeRef:e, disabled:t = !1, noDragClassName:o, handleSelector:r, nodeId:i, isSelectable:a, nodeClickDistance:s}) {
      const l = Ai(), [c, u] = n$jscomp$0.useState(!1), d = n$jscomp$0.useRef();
      return n$jscomp$0.useEffect(() => {
        d.current = jr({getStoreItems:() => l.getState(), onNodeMouseDown:t => {
          $a({id:t, store:l, nodeRef:e});
        }, onDragStart:() => {
          u(!0);
        }, onDragStop:() => {
          u(!1);
        }});
      }, []), n$jscomp$0.useEffect(() => {
        if (t) {
          d.current?.destroy();
        } else if (e.current) {
          return d.current?.update({noDragClassName:o, handleSelector:r, domNode:e.current, isSelectable:a, nodeId:i, nodeClickDistance:s}), () => {
            d.current?.destroy();
          };
        }
      }, [o, r, t, a, e, i]), c;
    }
    function Ba() {
      const e = Ai();
      return n$jscomp$0.useCallback(t$jscomp$0 => {
        const {nodeExtent:n, snapToGrid:o, snapGrid:r, nodesDraggable:i, onError:a, updateNodePositions:s, nodeLookup:l, nodeOrigin:c} = e.getState(), u = new Map(), d = Va(i), g = t$jscomp$0.direction.x * (o ? r[0] : 5) * t$jscomp$0.factor;
        t$jscomp$0 = t$jscomp$0.direction.y * (o ? r[1] : 5) * t$jscomp$0.factor;
        for (const [, e] of l) {
          if (!d(e)) {
            continue;
          }
          let t = {x:e.internals.positionAbsolute.x + g, y:e.internals.positionAbsolute.y + t$jscomp$0};
          o && (t = Zo(t, r));
          const {position:i, positionAbsolute:s} = No({nodeId:e.id, nextPosition:t, nodeLookup:l, nodeExtent:n, nodeOrigin:c, onError:a});
          e.position = i;
          e.internals.positionAbsolute = s;
          u.set(e.id, e);
        }
        s(u);
      }, []);
    }
    function Ga({onSelectionContextMenu:e, noPanClassName:o, disableKeyboardA11y:i}) {
      const a = Ai(), {width:s, height:l, transformString:c, userSelectionActive:u} = Ii(Ka, Yi), d = Ba(), h = n$jscomp$0.useRef(null);
      if (n$jscomp$0.useEffect(() => {
        i || h.current?.focus({preventScroll:!0});
      }, [i]), Ta({nodeRef:h}), u || !s || !l) {
        return null;
      }
      const f = e ? t => {
        const n = a.getState().nodes.filter(e => e.selected);
        e(t, n);
      } : void 0;
      return t.jsx("div", {className:r(["react-flow__nodesselection", "react-flow__container", o]), style:{transform:c}, children:t.jsx("div", {ref:h, className:"react-flow__nodesselection-rect", onContextMenu:f, tabIndex:i ? void 0 : -1, onKeyDown:i ? void 0 : e => {
        Object.prototype.hasOwnProperty.call(Fa, e.key) && (e.preventDefault(), d({direction:Fa[e.key], factor:e.shiftKey ? 4 : 1}));
      }, style:{width:s, height:l}})});
    }
    function Qa({children:e, onPaneClick:o, onPaneMouseEnter:r, onPaneMouseMove:i, onPaneMouseLeave:a, onPaneContextMenu:s, onPaneScroll:l, paneClickDistance:c, deleteKeyCode:u, selectionKeyCode:d, selectionOnDrag:h, selectionMode:f, onSelectionStart:g, onSelectionEnd:p, multiSelectionKeyCode:m, panActivationKeyCode:y, zoomActivationKeyCode:v, elementsSelectable:x, zoomOnScroll:w, zoomOnPinch:b, panOnScroll:S, panOnScrollSpeed:C, panOnScrollMode:E, zoomOnDoubleClick:k, panOnDrag:M, defaultViewport:N, 
    translateExtent:_, minZoom:P, maxZoom:z, preventScrolling:O, onSelectionContextMenu:I, noWheelClassName:A, noPanClassName:D, disableKeyboardA11y:R, onViewportChange:L, isControlledViewport:$}) {
      const {nodesSelectionActive:T, userSelectionActive:V} = Ii(Ua);
      d = aa(d, {target:qa});
      M = (y = aa(y, {target:qa})) || M;
      S = y || S;
      h = h && !0 !== M;
      y = d || V || h;
      return function({deleteKeyCode:e, multiSelectionKeyCode:t}) {
        const o = Ai(), {deleteElements:r} = Ma(), i = aa(e, {actInsideInputWithModifier:!1}), a = aa(t, {target:_a});
        n$jscomp$0.useEffect(() => {
          if (i) {
            const {edges:e, nodes:t} = o.getState();
            r({nodes:t.filter(Na), edges:e.filter(Na)});
            o.setState({nodesSelectionActive:!1});
          }
        }, [i]);
        n$jscomp$0.useEffect(() => {
          o.setState({multiSelectionActive:a});
        }, [a]);
      }({deleteKeyCode:u, multiSelectionKeyCode:m}), t.jsx(Oa, {onPaneContextMenu:s, elementsSelectable:x, zoomOnScroll:w, zoomOnPinch:b, panOnScroll:S, panOnScrollSpeed:C, panOnScrollMode:E, zoomOnDoubleClick:k, panOnDrag:!d && M, defaultViewport:N, translateExtent:_, minZoom:P, maxZoom:z, zoomActivationKeyCode:v, preventScrolling:O, noWheelClassName:A, noPanClassName:D, onViewportChange:L, isControlledViewport:$, paneClickDistance:c, children:t.jsxs(La, {onSelectionStart:g, onSelectionEnd:p, onPaneClick:o, 
      onPaneMouseEnter:r, onPaneMouseMove:i, onPaneMouseLeave:a, onPaneContextMenu:s, onPaneScroll:l, panOnDrag:M, isSelecting:!!y, selectionMode:f, selectionKeyPressed:d, selectionOnDrag:h, children:[e, T && t.jsx(Ga, {onSelectionContextMenu:I, noPanClassName:D, disableKeyboardA11y:R})]})});
    }
    function ns({id:e, onClick:o, onMouseEnter:i, onMouseMove:a, onMouseLeave:s, onContextMenu:l, onDoubleClick:c, nodesDraggable:u, elementsSelectable:d, nodesConnectable:h, nodesFocusable:f, resizeObserver:g, noDragClassName:p, noPanClassName:m, disableKeyboardA11y:y, rfId:v, nodeTypes:x, nodeClickDistance:w, onError:b}) {
      const {node:S, internals:C, isParent:E} = Ii(t => {
        const n = t.nodeLookup.get(e);
        t = t.parentLookup.has(e);
        return {node:n, internals:n.internals, isParent:t};
      }, Yi);
      let k = S.type || "default", M = x?.[k] || Wa[k];
      void 0 === M && (b?.("003", oo.error003(k)), k = "default", M = x?.default || Wa.default);
      const N = !!(S.draggable || u && void 0 === S.draggable), _ = !!(S.selectable || d && void 0 === S.selectable);
      u = !!(S.connectable || h && void 0 === S.connectable);
      f = !!(S.focusable || f && void 0 === S.focusable);
      const O = Ai();
      d = Uo(S);
      const A = function({node:e, nodeType:t, hasDimensions:o, resizeObserver:r}) {
        const i = Ai(), a = n$jscomp$0.useRef(null), s = n$jscomp$0.useRef(null), l = n$jscomp$0.useRef(e.sourcePosition), c = n$jscomp$0.useRef(e.targetPosition), u = n$jscomp$0.useRef(t), d = o && !!e.internals.handleBounds;
        return n$jscomp$0.useEffect(() => {
          !a.current || e.hidden || d && s.current === a.current || (s.current && r?.unobserve(s.current), r?.observe(a.current), s.current = a.current);
        }, [d, e.hidden]), n$jscomp$0.useEffect(() => () => {
          s.current && (r?.unobserve(s.current), s.current = null);
        }, []), n$jscomp$0.useEffect(() => {
          if (a.current) {
            const o = l.current !== e.sourcePosition, r = c.current !== e.targetPosition;
            (u.current !== t || o || r) && (u.current = t, l.current = e.sourcePosition, c.current = e.targetPosition, i.getState().updateNodeInternals(new Map([[e.id, {id:e.id, nodeElement:a.current, force:!0}]])));
          }
        }, [e.id, t, e.sourcePosition, e.targetPosition]), a;
      }({node:S, nodeType:k, hasDimensions:d, resizeObserver:g});
      g = Ta({nodeRef:A, disabled:S.hidden || !N, noDragClassName:p, handleSelector:S.dragHandle, nodeId:e, isSelectable:_, nodeClickDistance:w});
      const R = Ba();
      if (S.hidden) {
        return null;
      }
      const L = qo(S);
      p = void 0 === S.internals.handleBounds ? {width:S.width ?? S.initialWidth ?? S.style?.width, height:S.height ?? S.initialHeight ?? S.style?.height} : {width:S.width ?? S.style?.width, height:S.height ?? S.style?.height};
      w = _ || N || o || i || a || s;
      h = i ? e => i(e, {...C.userNode}) : void 0;
      x = a ? e => a(e, {...C.userNode}) : void 0;
      b = s ? e => s(e, {...C.userNode}) : void 0;
      const H = l ? e => l(e, {...C.userNode}) : void 0, Z = c ? e => c(e, {...C.userNode}) : void 0;
      return t.jsx("div", {className:r(["react-flow__node", `react-flow__node-${k}`, {[m]:N}, S.className, {selected:S.selected, selectable:_, parent:E, draggable:N, dragging:g}]), ref:A, style:{zIndex:C.z, transform:`translate(${C.positionAbsolute.x}px,${C.positionAbsolute.y}px)`, pointerEvents:w ? "all" : "none", visibility:d ? "visible" : "hidden", ...S.style, ...p}, "data-id":e, "data-testid":`rf__node-${e}`, onMouseEnter:h, onMouseMove:x, onMouseLeave:b, onContextMenu:H, onClick:t => {
        const {selectNodesOnDrag:n, nodeDragThreshold:r} = O.getState();
        _ && (!n || !N || 0 < r) && $a({id:e, store:O, nodeRef:A});
        o && o(t, {...C.userNode});
      }, onDoubleClick:Z, onKeyDown:f ? t => {
        if (!rr(t.nativeEvent) && !y) {
          if (io.includes(t.key) && _) {
            $a({id:e, store:O, unselect:"Escape" === t.key, nodeRef:A});
          } else if (N && S.selected && Object.prototype.hasOwnProperty.call(Fa, t.key)) {
            t.preventDefault();
            const {ariaLabelConfig:e} = O.getState();
            O.setState({ariaLiveMessage:e["node.a11yDescription.ariaLiveMessage"]({direction:t.key.replace("Arrow", "").toLowerCase(), x:~~C.positionAbsolute.x, y:~~C.positionAbsolute.y})});
            R({direction:Fa[t.key], factor:t.shiftKey ? 4 : 1});
          }
        }
      } : void 0, tabIndex:f ? 0 : void 0, onFocus:f ? () => {
        if (!y && A.current?.matches(":focus-visible")) {
          var {transform:t, width:n, height:o, autoPanOnNodeFocus:r, setCenter:i} = O.getState();
          r && (0 < Eo(new Map([[e, S]]), {x:0, y:0, width:n, height:o}, t, !0).length || i(S.position.x + L.width / 2, S.position.y + L.height / 2, {zoom:t[2]}));
        }
      } : void 0, role:S.ariaRole ?? (f ? "group" : void 0), "aria-roledescription":"node", "aria-describedby":y ? void 0 : `${"react-flow__node-desc"}-${v}`, "aria-label":S.ariaLabel, ...S.domAttributes, children:t.jsx(Ha, {value:e, children:t.jsx(M, {id:e, data:S.data, type:k, positionAbsoluteX:C.positionAbsolute.x, positionAbsoluteY:C.positionAbsolute.y, selected:S.selected ?? !1, selectable:_, draggable:N, deletable:S.deletable ?? !0, isConnectable:u, sourcePosition:S.sourcePosition, targetPosition:S.targetPosition, 
      dragging:g, dragHandle:S.dragHandle, zIndex:C.z, parentId:S.parentId, ...L})})});
    }
    function rs(e) {
      const {nodesDraggable:o, nodesConnectable:r, nodesFocusable:i, elementsSelectable:a, onError:s} = Ii(os, Yi), l = (c = e.onlyRenderVisibleElements, Ii(n$jscomp$0.useCallback(es(c), [c]), Yi));
      var c;
      const u = function() {
        const e = Ii(ts), [t] = n$jscomp$0.useState(() => "undefined" == typeof ResizeObserver ? null : new ResizeObserver(t => {
          const n = new Map();
          t.forEach(e => {
            const t = e.target.getAttribute("data-id");
            n.set(t, {id:t, nodeElement:e.target, force:!0});
          });
          e(n);
        }));
        return n$jscomp$0.useEffect(() => () => {
          t?.disconnect();
        }, [t]), t;
      }();
      return t.jsx("div", {className:"react-flow__nodes", style:Pa, children:l.map(n => t.jsx(ns, {id:n, nodeTypes:e.nodeTypes, nodeExtent:e.nodeExtent, onClick:e.onNodeClick, onMouseEnter:e.onNodeMouseEnter, onMouseMove:e.onNodeMouseMove, onMouseLeave:e.onNodeMouseLeave, onContextMenu:e.onNodeContextMenu, onDoubleClick:e.onNodeDoubleClick, noDragClassName:e.noDragClassName, noPanClassName:e.noPanClassName, rfId:e.rfId, disableKeyboardA11y:e.disableKeyboardA11y, resizeObserver:u, nodesDraggable:o, 
      nodesConnectable:r, nodesFocusable:i, elementsSelectable:a, nodeClickDistance:e.nodeClickDistance, onError:s}, n))});
    }
    function us({x:e, y:o, label:i, labelStyle:a, labelShowBg:s = !0, labelBgStyle:l, labelBgPadding:c = [2, 4], labelBgBorderRadius:u = 2, children:d, className:h, ...f}) {
      const [g, p] = n$jscomp$0.useState({x:1, y:0, width:0, height:0});
      h = r(["react-flow__edge-textwrapper", h]);
      const y = n$jscomp$0.useRef(null);
      return n$jscomp$0.useEffect(() => {
        if (y.current) {
          const e = y.current.getBBox();
          p({x:e.x, y:e.y, width:e.width, height:e.height});
        }
      }, [i]), i ? t.jsxs("g", {transform:`translate(${e - g.width / 2} ${o - g.height / 2})`, className:h, visibility:g.width ? "visible" : "hidden", ...f, children:[s && t.jsx("rect", {width:g.width + 2 * c[0], x:-c[0], y:-c[1], height:g.height + 2 * c[1], className:"react-flow__edge-textbg", style:l, rx:u, ry:u}), t.jsx("text", {className:"react-flow__edge-text", y:g.height / 2, dy:"0.3em", ref:y, style:a, children:i}), d]}) : null;
    }
    function hs({path:e, labelX:n, labelY:o, label:i, labelStyle:a, labelShowBg:s, labelBgStyle:l, labelBgPadding:c, labelBgBorderRadius:u, interactionWidth:d = 20, ...h}) {
      return t.jsxs(t.Fragment, {children:[t.jsx("path", {...h, d:e, fill:"none", className:r(["react-flow__edge-path", h.className])}), d ? t.jsx("path", {d:e, fill:"none", strokeOpacity:0, strokeWidth:d, className:"react-flow__edge-interaction"}) : null, i && jo(n) && jo(o) ? t.jsx(ds, {x:n, y:o, label:i, labelStyle:a, labelShowBg:s, labelBgStyle:l, labelBgPadding:c, labelBgBorderRadius:u}) : null]});
    }
    function fs({pos:t, x1:n, y1:o, x2:r, y2:i}) {
      return t === e$jscomp$0.Position.Left || t === e$jscomp$0.Position.Right ? [.5 * (n + r), o] : [n, .5 * (o + i)];
    }
    function gs({sourceX:t, sourceY:n, sourcePosition:o = e$jscomp$0.Position.Bottom, targetX:r, targetY:i, targetPosition:a = e$jscomp$0.Position.Top}) {
      const [s, l] = fs({pos:o, x1:t, y1:n, x2:r, y2:i}), [c, u] = fs({pos:a, x1:r, y1:i, x2:t, y2:n}), [d, h, f, g] = lr({sourceX:t, sourceY:n, targetX:r, targetY:i, sourceControlX:s, sourceControlY:l, targetControlX:c, targetControlY:u});
      return [`M${t},${n} C${s},${l} ${c},${u} ${r},${i}`, d, h, f, g];
    }
    function ps(e) {
      return n$jscomp$0.memo(({id:n, sourceX:o, sourceY:r, targetX:i, targetY:a, sourcePosition:s, targetPosition:l, label:c, labelStyle:u, labelShowBg:d, labelBgStyle:h, labelBgPadding:f, labelBgBorderRadius:g, style:p, markerEnd:m, markerStart:y, interactionWidth:v}) => {
        const [x, w, b] = gs({sourceX:o, sourceY:r, sourcePosition:s, targetX:i, targetY:a, targetPosition:l});
        return t.jsx(hs, {id:e.isInternal ? void 0 : n, path:x, labelX:w, labelY:b, label:c, labelStyle:u, labelShowBg:d, labelBgStyle:h, labelBgPadding:f, labelBgBorderRadius:g, style:p, markerEnd:m, markerStart:y, interactionWidth:v});
      });
    }
    function vs(o) {
      return n$jscomp$0.memo(({id:n, sourceX:r, sourceY:i, targetX:a, targetY:s, label:l, labelStyle:c, labelShowBg:u, labelBgStyle:d, labelBgPadding:h, labelBgBorderRadius:f, style:g, sourcePosition:p = e$jscomp$0.Position.Bottom, targetPosition:m = e$jscomp$0.Position.Top, markerEnd:y, markerStart:v, pathOptions:x, interactionWidth:w}) => {
        const [b, S, C] = wr({sourceX:r, sourceY:i, sourcePosition:p, targetX:a, targetY:s, targetPosition:m, borderRadius:x?.borderRadius, offset:x?.offset, stepPosition:x?.stepPosition});
        return t.jsx(hs, {id:o.isInternal ? void 0 : n, path:b, labelX:S, labelY:C, label:l, labelStyle:c, labelShowBg:u, labelBgStyle:d, labelBgPadding:h, labelBgBorderRadius:f, style:g, markerEnd:y, markerStart:v, interactionWidth:w});
      });
    }
    function bs(e) {
      return n$jscomp$0.memo(({id:o, ...r}) => t.jsx(xs, {...r, id:e.isInternal ? void 0 : o, pathOptions:n$jscomp$0.useMemo(() => ({borderRadius:0, offset:r.pathOptions?.offset}), [r.pathOptions?.offset])}));
    }
    function Es(e) {
      return n$jscomp$0.memo(({id:n, sourceX:o, sourceY:r, targetX:i, targetY:a, label:s, labelStyle:l, labelShowBg:c, labelBgStyle:u, labelBgPadding:d, labelBgBorderRadius:h, style:f, markerEnd:g, markerStart:p, interactionWidth:m}) => {
        const [y, v, x] = mr({sourceX:o, sourceY:r, targetX:i, targetY:a});
        return t.jsx(hs, {id:e.isInternal ? void 0 : n, path:y, labelX:v, labelY:x, label:s, labelStyle:l, labelShowBg:c, labelBgStyle:u, labelBgPadding:d, labelBgBorderRadius:h, style:f, markerEnd:g, markerStart:p, interactionWidth:m});
      });
    }
    function Ns(o) {
      return n$jscomp$0.memo(({id:n, sourceX:r, sourceY:i, targetX:a, targetY:s, sourcePosition:l = e$jscomp$0.Position.Bottom, targetPosition:c = e$jscomp$0.Position.Top, label:u, labelStyle:d, labelShowBg:h, labelBgStyle:f, labelBgPadding:g, labelBgBorderRadius:p, style:m, markerEnd:y, markerStart:v, pathOptions:x, interactionWidth:w}) => {
        const [b, S, C] = dr({sourceX:r, sourceY:i, sourcePosition:l, targetX:a, targetY:s, targetPosition:c, curvature:x?.curvature});
        return t.jsx(hs, {id:o.isInternal ? void 0 : n, path:b, labelX:S, labelY:C, label:u, labelStyle:d, labelShowBg:h, labelBgStyle:f, labelBgPadding:g, labelBgBorderRadius:p, style:m, markerEnd:y, markerStart:v, interactionWidth:w});
      });
    }
    function Rs({position:e, centerX:n, centerY:o, radius:i = 10, onMouseDown:a, onMouseEnter:s, onMouseOut:l, type:c}) {
      return t.jsx("circle", {onMouseDown:a, onMouseEnter:s, onMouseOut:l, className:r(["react-flow__edgeupdater", `${"react-flow__edgeupdater"}-${c}`]), cx:e === e$jscomp$0.Position.Left ? n - i : e === e$jscomp$0.Position.Right ? n + i : n, cy:e === e$jscomp$0.Position.Top ? o - i : e === e$jscomp$0.Position.Bottom ? o + i : o, r:i, stroke:"transparent", fill:"transparent"});
    }
    function Ls({isReconnectable:e, reconnectRadius:n, edge:o, sourceX:r, sourceY:i, targetX:a, targetY:s, sourcePosition:l, targetPosition:c, onReconnect:u, onReconnectStart:d, onReconnectEnd:h, setReconnecting:f, setUpdateHover:g}) {
      const p = Ai(), m = (e, t) => {
        if (0 === e.button) {
          var {autoPanOnConnect:n, domNode:r, isValidConnection:i, connectionMode:a, connectionRadius:s, lib:l, onConnectStart:c, onConnectEnd:g, cancelConnection:m, nodeLookup:y, rfId:v, panBy:x, updateConnection:w} = p.getState();
          Kr.onPointerDown(e.nativeEvent, {autoPanOnConnect:n, connectionMode:a, connectionRadius:s, domNode:r, handleId:t.id, nodeId:t.nodeId, nodeLookup:y, isTarget:"target" === t.type, edgeUpdaterType:t.type, lib:l, flowId:v, cancelConnection:m, panBy:x, isValidConnection:i, onConnect:e => u?.(o, e), onConnectStart:(n, r) => {
            f(!0);
            d?.(e, o, t.type);
            c?.(n, r);
          }, onConnectEnd:g, onReconnectEnd:(e, n) => {
            f(!1);
            h?.(e, o, t.type, n);
          }, updateConnection:w, getTransform:() => p.getState().transform, getFromHandle:() => p.getState().connection.fromHandle, dragThreshold:p.getState().connectionDragThreshold, handleDomNode:e.currentTarget});
        }
      }, y = () => g(!0), v = () => g(!1);
      return t.jsxs(t.Fragment, {children:[(!0 === e || "source" === e) && t.jsx(Rs, {position:l, centerX:r, centerY:i, radius:n, onMouseDown:e => m(e, {nodeId:o.target, id:o.targetHandle ?? null, type:"target"}), onMouseEnter:y, onMouseOut:v, type:"source"}), (!0 === e || "target" === e) && t.jsx(Rs, {position:c, centerX:a, centerY:s, radius:n, onMouseDown:e => m(e, {nodeId:o.source, id:o.sourceHandle ?? null, type:"source"}), onMouseEnter:y, onMouseOut:v, type:"target"})]});
    }
    function $s({id:o, edgesFocusable:i, edgesReconnectable:a, elementsSelectable:s, onClick:l, onDoubleClick:c, onContextMenu:u, onMouseEnter:d, onMouseMove:h, onMouseLeave:f, reconnectRadius:g, onReconnect:p, onReconnectStart:m, onReconnectEnd:y, rfId:v, edgeTypes:x, noPanClassName:w, onError:b, disableKeyboardA11y:S}) {
      let C = Ii(e => e.edgeLookup.get(o));
      var E = Ii(e => e.defaultEdgeOptions);
      C = E ? {...E, ...C} : C;
      E = C.type || "default";
      let M = x?.[E] || zs[E];
      void 0 === M && (b?.("011", oo.error011(E)), E = "default", M = x?.default || zs.default);
      i = !!(C.focusable || i && void 0 === C.focusable);
      a = void 0 !== p && (C.reconnectable || a && void 0 === C.reconnectable);
      const P = !!(C.selectable || s && void 0 === C.selectable), z = n$jscomp$0.useRef(null), [O, I] = n$jscomp$0.useState(!1), [A, D] = n$jscomp$0.useState(!1), R = Ai(), {zIndex:L, sourceX:$, sourceY:T, targetX:V, targetY:B, sourcePosition:j, targetPosition:H} = Ii(n$jscomp$0.useCallback(t => {
        const n = t.nodeLookup.get(C.source), r = t.nodeLookup.get(C.target);
        if (!n || !r) {
          return {zIndex:C.zIndex, ...Os};
        }
        const i = function(t) {
          const {sourceNode:n, targetNode:o} = t;
          if (!br(n) || !br(o)) {
            return null;
          }
          var r = n.internals.handleBounds || Sr(n.handles), i = o.internals.handleBounds || Sr(o.handles);
          r = Er(r?.source ?? [], t.sourceHandle);
          i = Er(t.connectionMode === e$jscomp$0.ConnectionMode.Strict ? i?.target ?? [] : (i?.target ?? []).concat(i?.source ?? []), t.targetHandle);
          if (!r || !i) {
            return t.onError?.("008", oo.error008(r ? "target" : "source", {id:t.id, sourceHandle:t.sourceHandle, targetHandle:t.targetHandle})), null;
          }
          t = r?.position || e$jscomp$0.Position.Bottom;
          const c = i?.position || e$jscomp$0.Position.Top;
          r = Cr(n, r, t);
          i = Cr(o, i, c);
          return {sourceX:r.x, sourceY:r.y, targetX:i.x, targetY:i.y, sourcePosition:t, targetPosition:c};
        }({id:o, sourceNode:n, targetNode:r, sourceHandle:C.sourceHandle || null, targetHandle:C.targetHandle || null, connectionMode:t.connectionMode, onError:b});
        return {zIndex:function({sourceNode:e, targetNode:t, selected:n = !1, zIndex:o, elevateOnSelect:r = !1}) {
          return void 0 !== o ? o : (r && n ? 1E3 : 0) + Math.max(e.parentId || r && e.selected ? e.internals.z : 0, t.parentId || r && t.selected ? t.internals.z : 0);
        }({selected:C.selected, zIndex:C.zIndex, sourceNode:n, targetNode:r, elevateOnSelect:t.elevateEdgesOnSelect}), ...(i || Os)};
      }, [C.source, C.target, C.sourceHandle, C.targetHandle, C.selected, C.zIndex]), Yi);
      s = n$jscomp$0.useMemo(() => C.markerStart ? `url('#${kr(C.markerStart, v)}')` : void 0, [C.markerStart, v]);
      x = n$jscomp$0.useMemo(() => C.markerEnd ? `url('#${kr(C.markerEnd, v)}')` : void 0, [C.markerEnd, v]);
      if (C.hidden || null === $ || null === T || null === V || null === B) {
        return null;
      }
      const Y = c ? e => {
        c(e, {...C});
      } : void 0, F = u ? e => {
        u(e, {...C});
      } : void 0, W = d ? e => {
        d(e, {...C});
      } : void 0, K = h ? e => {
        h(e, {...C});
      } : void 0, G = f ? e => {
        f(e, {...C});
      } : void 0;
      return t.jsx("svg", {style:{zIndex:L}, children:t.jsxs("g", {className:r(["react-flow__edge", `react-flow__edge-${E}`, C.className, w, {selected:C.selected, animated:C.animated, inactive:!P && !l, updating:O, selectable:P}]), onClick:e => {
        const {addSelectedEdges:t, unselectNodesAndEdges:n, multiSelectionActive:r} = R.getState();
        P && (R.setState({nodesSelectionActive:!1}), C.selected && r ? (n({nodes:[], edges:[C]}), z.current?.blur()) : t([o]));
        l && l(e, C);
      }, onDoubleClick:Y, onContextMenu:F, onMouseEnter:W, onMouseMove:K, onMouseLeave:G, onKeyDown:i ? e => {
        if (!S && io.includes(e.key) && P) {
          const {unselectNodesAndEdges:t, addSelectedEdges:n} = R.getState();
          "Escape" === e.key ? (z.current?.blur(), t({edges:[C]})) : n([o]);
        }
      } : void 0, tabIndex:i ? 0 : void 0, role:C.ariaRole ?? (i ? "group" : "img"), "aria-roledescription":"edge", "data-id":o, "data-testid":`rf__edge-${o}`, "aria-label":null === C.ariaLabel ? void 0 : C.ariaLabel || `Edge from ${C.source} to ${C.target}`, "aria-describedby":i ? `${"react-flow__edge-desc"}-${v}` : void 0, ref:z, ...C.domAttributes, children:[!A && t.jsx(M, {id:o, source:C.source, target:C.target, type:C.type, selected:C.selected, animated:C.animated, selectable:P, deletable:C.deletable ?? 
      !0, label:C.label, labelStyle:C.labelStyle, labelShowBg:C.labelShowBg, labelBgStyle:C.labelBgStyle, labelBgPadding:C.labelBgPadding, labelBgBorderRadius:C.labelBgBorderRadius, sourceX:$, sourceY:T, targetX:V, targetY:B, sourcePosition:j, targetPosition:H, data:C.data, style:C.style, sourceHandleId:C.sourceHandle, targetHandleId:C.targetHandle, markerStart:s, markerEnd:x, pathOptions:"pathOptions" in C ? C.pathOptions : void 0, interactionWidth:C.interactionWidth}), a && t.jsx(Ls, {edge:C, isReconnectable:a, 
      reconnectRadius:g, onReconnect:p, onReconnectStart:m, onReconnectEnd:y, sourceX:$, sourceY:T, targetX:V, targetY:B, sourcePosition:j, targetPosition:H, setUpdateHover:I, setReconnecting:D})]})});
    }
    function Vs({defaultMarkerColor:e, onlyRenderVisibleElements:o, rfId:r, edgeTypes:i, noPanClassName:a, onReconnect:s, onEdgeContextMenu:l, onEdgeMouseEnter:c, onEdgeMouseMove:u, onEdgeMouseLeave:d, onEdgeClick:h, reconnectRadius:f, onEdgeDoubleClick:g, onReconnectStart:p, onReconnectEnd:m, disableKeyboardA11y:y}) {
      const {edgesFocusable:v, edgesReconnectable:x, elementsSelectable:w, onError:b} = Ii(Ts, Yi);
      o = (C = o, Ii(n$jscomp$0.useCallback(e => {
        if (!C) {
          return e.edges.map(e => e.id);
        }
        const t = [];
        if (e.width && e.height) {
          for (const n of e.edges) {
            const o = e.nodeLookup.get(n.source), r = e.nodeLookup.get(n.target);
            o && r && fr({sourceNode:o, targetNode:r, width:e.width, height:e.height, transform:e.transform}) && t.push(n.id);
          }
        }
        return t;
      }, [C]), Yi));
      var C;
      return t.jsxs("div", {className:"react-flow__edges", children:[t.jsx(cs, {defaultColor:e, rfId:r}), o.map(e => t.jsx($s, {id:e, edgesFocusable:v, edgesReconnectable:x, elementsSelectable:w, noPanClassName:a, onReconnect:s, onContextMenu:l, onMouseEnter:c, onMouseMove:u, onMouseLeave:d, onClick:h, reconnectRadius:f, onDoubleClick:g, onReconnectStart:p, onReconnectEnd:m, rfId:r, onError:b, edgeTypes:i, disableKeyboardA11y:y}, e))]});
    }
    function Hs({children:e}) {
      const n = Ii(js);
      return t.jsx("div", {className:"react-flow__viewport xyflow__viewport react-flow__container", style:{transform:n}, children:e});
    }
    function Xs(e) {
      return e.connection.inProgress ? {...e.connection, to:Xo(e.connection.to, e.transform)} : {...e.connection};
    }
    function Ys(e) {
      e = function(e) {
        return e ? t => {
          t = Xs(t);
          return e(t);
        } : Xs;
      }(e);
      return Ii(e, Yi);
    }
    function Ws({containerStyle:e, style:n, type:o, component:i}) {
      const {nodesConnectable:a, width:s, height:l, isValid:c, inProgress:u} = Ii(Fs, Yi);
      return s && a && u ? t.jsx("svg", {style:e, width:s, height:l, className:"react-flow__connectionline react-flow__container", children:t.jsx("g", {className:r(["react-flow__connection", null === c ? null : c ? "valid" : "invalid"]), children:t.jsx(Ks, {style:n, type:o, CustomComponent:i, isValid:c})})}) : null;
    }
    function qs(e = Gs) {
      n$jscomp$0.useRef(e);
      Ai();
      n$jscomp$0.useEffect(() => {
      }, [e]);
    }
    function Us({nodeTypes:e, edgeTypes:o, onInit:r, onNodeClick:i, onEdgeClick:a, onNodeDoubleClick:s, onEdgeDoubleClick:l, onNodeMouseEnter:c, onNodeMouseMove:u, onNodeMouseLeave:d, onNodeContextMenu:h, onSelectionContextMenu:f, onSelectionStart:g, onSelectionEnd:p, connectionLineType:m, connectionLineStyle:y, connectionLineComponent:v, connectionLineContainerStyle:x, selectionKeyCode:w, selectionOnDrag:b, selectionMode:S, multiSelectionKeyCode:C, panActivationKeyCode:E, zoomActivationKeyCode:k, 
    deleteKeyCode:M, onlyRenderVisibleElements:N, elementsSelectable:_, defaultViewport:P, translateExtent:z, minZoom:O, maxZoom:I, preventScrolling:A, defaultMarkerColor:D, zoomOnScroll:R, zoomOnPinch:L, panOnScroll:$, panOnScrollSpeed:T, panOnScrollMode:V, zoomOnDoubleClick:B, panOnDrag:j, onPaneClick:H, onPaneMouseEnter:Z, onPaneMouseMove:X, onPaneMouseLeave:Y, onPaneScroll:F, onPaneContextMenu:W, paneClickDistance:K, nodeClickDistance:G, onEdgeContextMenu:q, onEdgeMouseEnter:U, onEdgeMouseMove:Q, 
    onEdgeMouseLeave:J, reconnectRadius:ee, onReconnect:te, onReconnectStart:ne, onReconnectEnd:oe, noDragClassName:re, noWheelClassName:ie, noPanClassName:ae, disableKeyboardA11y:se, nodeExtent:le, rfId:ce, viewport:ue, onViewportChange:de}) {
      return qs(e), qs(o), Ai(), n$jscomp$0.useRef(!1), n$jscomp$0.useEffect(() => {
      }, []), function(e) {
        const t = Ma(), o = n$jscomp$0.useRef(!1);
        n$jscomp$0.useEffect(() => {
          !o.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), o.current = !0);
        }, [e, t.viewportInitialized]);
      }(r), function(e) {
        const t = Ii(Zs), o = Ai();
        n$jscomp$0.useEffect(() => {
          e && (t?.(e), o.setState({transform:[e.x, e.y, e.zoom]}));
        }, [e, t]);
      }(ue), t.jsx(Ja, {onPaneClick:H, onPaneMouseEnter:Z, onPaneMouseMove:X, onPaneMouseLeave:Y, onPaneContextMenu:W, onPaneScroll:F, paneClickDistance:K, deleteKeyCode:M, selectionKeyCode:w, selectionOnDrag:b, selectionMode:S, onSelectionStart:g, onSelectionEnd:p, multiSelectionKeyCode:C, panActivationKeyCode:E, zoomActivationKeyCode:k, elementsSelectable:_, zoomOnScroll:R, zoomOnPinch:L, zoomOnDoubleClick:B, panOnScroll:$, panOnScrollSpeed:T, panOnScrollMode:V, panOnDrag:j, defaultViewport:P, 
      translateExtent:z, minZoom:O, maxZoom:I, onSelectionContextMenu:f, preventScrolling:A, noDragClassName:re, noWheelClassName:ie, noPanClassName:ae, disableKeyboardA11y:se, onViewportChange:de, isControlledViewport:!!ue, children:t.jsxs(Hs, {children:[t.jsx(Bs, {edgeTypes:o, onEdgeClick:a, onEdgeDoubleClick:l, onReconnect:te, onReconnectStart:ne, onReconnectEnd:oe, onlyRenderVisibleElements:N, onEdgeContextMenu:q, onEdgeMouseEnter:U, onEdgeMouseMove:Q, onEdgeMouseLeave:J, reconnectRadius:ee, 
      defaultMarkerColor:D, noPanClassName:ae, disableKeyboardA11y:se, rfId:ce}), t.jsx(Ws, {style:y, type:m, component:v, containerStyle:x}), t.jsx("div", {className:"react-flow__edgelabel-renderer"}), t.jsx(is, {nodeTypes:e, onNodeClick:i, onNodeDoubleClick:s, onNodeMouseEnter:c, onNodeMouseMove:u, onNodeMouseLeave:d, onNodeContextMenu:h, nodeClickDistance:G, onlyRenderVisibleElements:N, noPanClassName:ae, noDragClassName:re, disableKeyboardA11y:se, nodeExtent:le, rfId:ce}), t.jsx("div", {className:"react-flow__viewport-portal"})]})});
    }
    function tl({initialNodes:e, initialEdges:o, defaultNodes:r, defaultEdges:i, initialWidth:a, initialHeight:s, initialMinZoom:l, initialMaxZoom:c, initialFitViewOptions:u, fitView:d, nodeOrigin:h, nodeExtent:f, children:g}) {
      const [p] = n$jscomp$0.useState(() => el({nodes:e, edges:o, defaultNodes:r, defaultEdges:i, width:a, height:s, fitView:d, minZoom:l, maxZoom:c, fitViewOptions:u, nodeOrigin:h, nodeExtent:f}));
      return t.jsx(zi, {value:p, children:t.jsx(Ea, {children:g})});
    }
    function nl({children:e, nodes:o, edges:r, defaultNodes:i, defaultEdges:a, width:s, height:l, fitView:c, fitViewOptions:u, minZoom:d, maxZoom:h, nodeOrigin:f, nodeExtent:g}) {
      return n$jscomp$0.useContext(Pi) ? t.jsx(t.Fragment, {children:e}) : t.jsx(tl, {initialNodes:o, initialEdges:r, defaultNodes:i, defaultEdges:a, initialWidth:s, initialHeight:l, fitView:c, initialFitViewOptions:u, initialMinZoom:d, initialMaxZoom:h, nodeOrigin:f, nodeExtent:g, children:e});
    }
    function dl({dimensions:e, lineWidth:n, variant:o, className:i}) {
      return t.jsx("path", {strokeWidth:n, d:`M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className:r(["react-flow__background-pattern", o, i])});
    }
    function hl({radius:e, className:n}) {
      return t.jsx("circle", {cx:e, cy:e, r:e, className:r(["react-flow__background-pattern", "dots", n])});
    }
    function ml({id:o, variant:i = e$jscomp$0.BackgroundVariant.Dots, gap:a = 20, size:s, lineWidth:l = 1, offset:c = 0, color:u, bgColor:d, style:h, className:f, patternClassName:g}) {
      const p = n$jscomp$0.useRef(null), {transform:m, patternId:y} = Ii(pl, Yi);
      var v = s || gl[i];
      s = i === e$jscomp$0.BackgroundVariant.Dots;
      var w = i === e$jscomp$0.BackgroundVariant.Cross;
      a = Array.isArray(a) ? a : [a, a];
      a = [a[0] * m[2] || 1, a[1] * m[2] || 1];
      v *= m[2];
      const E = Array.isArray(c) ? c : [c, c];
      c = w ? [v, v] : a;
      w = [E[0] * m[2] || 1 + c[0] / 2, E[1] * m[2] || 1 + c[1] / 2];
      o = `${y}${o || ""}`;
      return t.jsxs("svg", {className:r(["react-flow__background", f]), style:{...h, ...Pa, "--xy-background-color-props":d, "--xy-background-pattern-color-props":u}, ref:p, "data-testid":"rf__background", children:[t.jsx("pattern", {id:o, x:m[0] % a[0], y:m[1] % a[1], width:a[0], height:a[1], patternUnits:"userSpaceOnUse", patternTransform:`translate(-${w[0]},-${w[1]})`, children:s ? t.jsx(hl, {radius:v / 2, className:g}) : t.jsx(dl, {dimensions:c, lineWidth:l, variant:i, className:g})}), t.jsx("rect", 
      {x:"0", y:"0", width:"100%", height:"100%", fill:`url(#${o})`})]});
    }
    function vl() {
      return t.jsx("svg", {xmlns:"http://www.w3.org/2000/svg", viewBox:"0 0 32 32", children:t.jsx("path", {d:"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z"})});
    }
    function xl() {
      return t.jsx("svg", {xmlns:"http://www.w3.org/2000/svg", viewBox:"0 0 32 5", children:t.jsx("path", {d:"M0 0h32v4.2H0z"})});
    }
    function wl() {
      return t.jsx("svg", {xmlns:"http://www.w3.org/2000/svg", viewBox:"0 0 32 30", children:t.jsx("path", {d:"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z"})});
    }
    function bl() {
      return t.jsx("svg", {xmlns:"http://www.w3.org/2000/svg", viewBox:"0 0 25 32", children:t.jsx("path", {d:"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z"})});
    }
    function Sl() {
      return t.jsx("svg", {xmlns:"http://www.w3.org/2000/svg", viewBox:"0 0 25 32", children:t.jsx("path", {d:"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z"})});
    }
    function Cl({children:e, className:n, ...o}) {
      return t.jsx("button", {type:"button", className:r(["react-flow__controls-button", n]), ...o, children:e});
    }
    function kl({style:e, showZoom:n = !0, showFitView:o = !0, showInteractive:i = !0, fitViewOptions:a, onZoomIn:s, onZoomOut:l, onFitView:c, onInteractiveChange:u, className:d, children:h, position:f = "bottom-left", orientation:g = "vertical", "aria-label":p}) {
      const m = Ai(), {isInteractive:y, minZoomReached:v, maxZoomReached:x, ariaLabelConfig:w} = Ii(El, Yi), {zoomIn:b, zoomOut:S, fitView:C} = Ma();
      return t.jsxs(Zi, {className:r(["react-flow__controls", "horizontal" === g ? "horizontal" : "vertical", d]), position:f, style:e, "data-testid":"rf__controls", "aria-label":p ?? w["controls.ariaLabel"], children:[n && t.jsxs(t.Fragment, {children:[t.jsx(Cl, {onClick:() => {
        b();
        s?.();
      }, className:"react-flow__controls-zoomin", title:w["controls.zoomIn.ariaLabel"], "aria-label":w["controls.zoomIn.ariaLabel"], disabled:x, children:t.jsx(vl, {})}), t.jsx(Cl, {onClick:() => {
        S();
        l?.();
      }, className:"react-flow__controls-zoomout", title:w["controls.zoomOut.ariaLabel"], "aria-label":w["controls.zoomOut.ariaLabel"], disabled:v, children:t.jsx(xl, {})})]}), o && t.jsx(Cl, {className:"react-flow__controls-fitview", onClick:() => {
        C(a);
        c?.();
      }, title:w["controls.fitView.ariaLabel"], "aria-label":w["controls.fitView.ariaLabel"], children:t.jsx(wl, {})}), i && t.jsx(Cl, {className:"react-flow__controls-interactive", onClick:() => {
        m.setState({nodesDraggable:!y, nodesConnectable:!y, elementsSelectable:!y});
        u?.(!y);
      }, title:w["controls.interactive.ariaLabel"], "aria-label":w["controls.interactive.ariaLabel"], children:y ? t.jsx(Sl, {}) : t.jsx(bl, {})}), h]});
    }
    function Dl({style:e, className:o, nodeStrokeColor:i, nodeColor:a, nodeClassName:s = "", nodeBorderRadius:l = 5, nodeStrokeWidth:c, nodeComponent:u, bgColor:d, maskColor:h, maskStrokeColor:f, maskStrokeWidth:g, position:p = "bottom-right", onClick:m, onNodeClick:y, pannable:v = !1, zoomable:x = !1, ariaLabel:w, inversePan:b, zoomStep:S = 1, offsetScale:C = 5}) {
      const E = Ai(), k = n$jscomp$0.useRef(null), {boundingRect:M, viewBB:N, rfId:_, panZoom:P, translateExtent:z, flowWidth:O, flowHeight:I, ariaLabelConfig:A} = Ii(Al, Yi), D = e?.width ?? 200, R = e?.height ?? 150, T = Math.max(M.width / D, M.height / R);
      var V = T * D, B = T * R;
      C *= T;
      const H = M.x - (V - M.width) / 2 - C, Z = M.y - (B - M.height) / 2 - C;
      V += 2 * C;
      B += 2 * C;
      const F = `react-flow__minimap-desc-${_}`, W = n$jscomp$0.useRef(0), K = n$jscomp$0.useRef();
      W.current = T;
      n$jscomp$0.useEffect(() => {
        if (k.current && P) {
          return K.current = function({domNode:e, panZoom:t, getTransform:n, getViewScale:o}) {
            const r = Se(e);
            return {update:function({translateExtent:e, width:i, height:a, zoomStep:s = 1, pannable:l = !0, zoomable:c = !0, inversePan:u = !1}) {
              let d = [0, 0];
              l = no().on("start", e => {
                "mousedown" !== e.sourceEvent.type && "touchstart" !== e.sourceEvent.type || (d = [e.sourceEvent.clientX ?? e.sourceEvent.touches[0].clientX, e.sourceEvent.clientY ?? e.sourceEvent.touches[0].clientY]);
              }).on("zoom", l ? r => {
                const s = n();
                if (("mousemove" === r.sourceEvent.type || "touchmove" === r.sourceEvent.type) && t) {
                  var l = [r.sourceEvent.clientX ?? r.sourceEvent.touches[0].clientX, r.sourceEvent.clientY ?? r.sourceEvent.touches[0].clientY];
                  r = [l[0] - d[0], l[1] - d[1]];
                  d = l;
                  l = o() * Math.max(s[2], Math.log(s[2])) * (u ? -1 : 1);
                  t.setViewportConstrained({x:s[0] - r[0] * l, y:s[1] - r[1] * l, zoom:s[2]}, [[0, 0], [i, a]], e);
                }
              } : null).on("zoom.wheel", c ? e => {
                if ("wheel" === e.sourceEvent.type && t) {
                  var o = n(), r = e.sourceEvent.ctrlKey && Ko() ? 10 : 1;
                  t.scaleTo(o[2] * Math.pow(2, -e.sourceEvent.deltaY * (1 === e.sourceEvent.deltaMode ? .05 : e.sourceEvent.deltaMode ? 1 : .002) * s * r));
                }
              } : null);
              r.call(l, {});
            }, destroy:function() {
              r.on("zoom", null);
            }, pointer:Ce};
          }({domNode:k.current, panZoom:P, getTransform:() => E.getState().transform, getViewScale:() => W.current}), () => {
            K.current?.destroy();
          };
        }
      }, [P]);
      n$jscomp$0.useEffect(() => {
        K.current?.update({translateExtent:z, width:O, height:I, inversePan:b, pannable:v, zoomStep:S, zoomable:x});
      }, [v, x, b, S, z, O, I]);
      const G = m ? e => {
        const [t, n] = K.current?.pointer(e) || [0, 0];
        m(e, {x:t, y:n});
      } : void 0, q = y ? n$jscomp$0.useCallback((e, t) => {
        t = E.getState().nodeLookup.get(t).internals.userNode;
        y(e, t);
      }, []) : void 0;
      w = w ?? A["minimap.ariaLabel"];
      return t.jsx(Zi, {position:p, style:{...e, "--xy-minimap-background-color-props":"string" == typeof d ? d : void 0, "--xy-minimap-mask-background-color-props":"string" == typeof h ? h : void 0, "--xy-minimap-mask-stroke-color-props":"string" == typeof f ? f : void 0, "--xy-minimap-mask-stroke-width-props":"number" == typeof g ? g * T : void 0, "--xy-minimap-node-background-color-props":"string" == typeof a ? a : void 0, "--xy-minimap-node-stroke-color-props":"string" == typeof i ? i : void 0, 
      "--xy-minimap-node-stroke-width-props":"number" == typeof c ? c : void 0}, className:r(["react-flow__minimap", o]), "data-testid":"rf__minimap", children:t.jsxs("svg", {width:D, height:R, viewBox:`${H} ${Z} ${V} ${B}`, className:"react-flow__minimap-svg", role:"img", "aria-labelledby":F, ref:k, onClick:G, children:[w && t.jsx("title", {id:F, children:w}), t.jsx(Ol, {onClick:q, nodeColor:a, nodeStrokeColor:i, nodeBorderRadius:l, nodeClassName:s, nodeStrokeWidth:c, nodeComponent:u}), t.jsx("path", 
      {className:"react-flow__minimap-mask", d:`M${H - C},${Z - C}h${V + 2 * C}v${B + 2 * C}h${-V - 2 * C}z\n        M${N.x},${N.y}h${N.width}v${N.height}h${-N.width}z`, fillRule:"evenodd", pointerEvents:"none"})]})});
    }
    function Vl({children:e}) {
      const t = Ii(Tl);
      return t ? o.createPortal(e, t) : null;
    }
    var i = {value:() => {
    }};
    s.prototype = a.prototype = {constructor:s, on:function(e, t) {
      var n, r = this._, i = (e + "").trim().split(/^|\s+/).map(function(e) {
        var t = "", n = e.indexOf(".");
        if (0 <= n && (t = e.slice(n + 1), e = e.slice(0, n)), e && !r.hasOwnProperty(e)) {
          throw Error("unknown type: " + e);
        }
        return {type:e, name:t};
      }), a = -1, s = i.length;
      if (!(2 > arguments.length)) {
        if (null != t && "function" != typeof t) {
          throw Error("invalid callback: " + t);
        }
        for (; ++a < s;) {
          if (n = (e = i[a]).type) {
            r[n] = c(r[n], e.name, t);
          } else if (null == t) {
            for (n in r) {
              r[n] = c(r[n], e.name, null);
            }
          }
        }
        return this;
      }
      for (; ++a < s;) {
        if ((n = (e = i[a]).type) && (n = l(r[n], e.name))) {
          return n;
        }
      }
    }, copy:function() {
      var e = {}, t = this._, n;
      for (n in t) {
        e[n] = t[n].slice();
      }
      return new s(e);
    }, call:function(e, t) {
      if (0 < (n = arguments.length - 2)) {
        for (var n, o, r = Array(n), i = 0; i < n; ++i) {
          r[i] = arguments[i + 2];
        }
      }
      if (!this._.hasOwnProperty(e)) {
        throw Error("unknown type: " + e);
      }
      i = 0;
      for (n = (o = this._[e]).length; i < n; ++i) {
        o[i].value.apply(t, r);
      }
    }, apply:function(e, t, n) {
      if (!this._.hasOwnProperty(e)) {
        throw Error("unknown type: " + e);
      }
      e = this._[e];
      for (var r = 0, i = e.length; r < i; ++r) {
        e[r].value.apply(t, n);
      }
    }};
    var d = {svg:"http://www.w3.org/2000/svg", xhtml:"http://www.w3.org/1999/xhtml", xlink:"http://www.w3.org/1999/xlink", xml:"http://www.w3.org/XML/1998/namespace", xmlns:"http://www.w3.org/2000/xmlns/"}, C = Array.prototype.find, k = Array.prototype.filter;
    _.prototype = {constructor:_, appendChild:function(e) {
      return this._parent.insertBefore(e, this._next);
    }, insertBefore:function(e, t) {
      return this._parent.insertBefore(e, t);
    }, querySelector:function(e) {
      return this._parent.querySelector(e);
    }, querySelectorAll:function(e) {
      return this._parent.querySelectorAll(e);
    }};
    q.prototype = {add:function(e) {
      0 > this._names.indexOf(e) && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
    }, remove:function(e) {
      e = this._names.indexOf(e);
      0 <= e && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
    }, contains:function(e) {
      return 0 <= this._names.indexOf(e);
    }};
    var xe = [null];
    we.prototype = be.prototype = {constructor:we, select:function(e) {
      "function" != typeof e && (e = y(e));
      for (var t = this._groups, n = t.length, o = Array(n), r = 0; r < n; ++r) {
        for (var i, a, s = t[r], l = s.length, c = o[r] = Array(l), u = 0; u < l; ++u) {
          (i = s[u]) && (a = e.call(i, i.__data__, u, s)) && ("__data__" in i && (a.__data__ = i.__data__), c[u] = a);
        }
      }
      return new we(o, this._parents);
    }, selectAll:function(e) {
      e = "function" == typeof e ? w(e) : x(e);
      for (var t = this._groups, n = t.length, o = [], r = [], i = 0; i < n; ++i) {
        for (var a, s = t[i], l = s.length, c = 0; c < l; ++c) {
          (a = s[c]) && (o.push(e.call(a, a.__data__, c, s)), r.push(a));
        }
      }
      return new we(o, r);
    }, selectChild:function(e) {
      return this.select(null == e ? E : function(e) {
        return function() {
          return C.call(this.children, e);
        };
      }("function" == typeof e ? e : S(e)));
    }, selectChildren:function(e) {
      return this.selectAll(null == e ? M : function(e) {
        return function() {
          return k.call(this.children, e);
        };
      }("function" == typeof e ? e : S(e)));
    }, filter:function(e) {
      "function" != typeof e && (e = b(e));
      for (var t = this._groups, n = t.length, o = Array(n), r = 0; r < n; ++r) {
        for (var i, a = t[r], s = a.length, l = o[r] = [], c = 0; c < s; ++c) {
          (i = a[c]) && e.call(i, i.__data__, c, a) && l.push(i);
        }
      }
      return new we(o, this._parents);
    }, data:function(e, t) {
      if (!arguments.length) {
        return Array.from(this, O);
      }
      var n, o = t ? z : P, r = this._parents, i = this._groups;
      "function" != typeof e && (n = e, e = function() {
        return n;
      });
      for (var a = i.length, s = Array(a), l = Array(a), c = Array(a), u = 0; u < a; ++u) {
        var d = r[u], h = i[u], f = h.length, g = I(e.call(d, d && d.__data__, u, r)), p = g.length, m = l[u] = Array(p), y = s[u] = Array(p);
        o(d, h, m, y, c[u] = Array(f), g, t);
        for (g = f = 0; f < p; ++f) {
          if (d = m[f]) {
            for (f >= g && (g = f + 1); !(h = y[g]) && ++g < p;) {
            }
            d._next = h || null;
          }
        }
      }
      return (s = new we(s, r))._enter = l, s._exit = c, s;
    }, enter:function() {
      return new we(this._enter || this._groups.map(N), this._parents);
    }, exit:function() {
      return new we(this._exit || this._groups.map(N), this._parents);
    }, join:function(e, t, n) {
      var o = this.enter(), r = this, i = this.exit();
      return "function" == typeof e ? (o = e(o)) && (o = o.selection()) : o = o.append(e + ""), null != t && (r = t(r)) && (r = r.selection()), null == n ? i.remove() : n(i), o && r ? o.merge(r).order() : r;
    }, merge:function(e) {
      var t = e.selection ? e.selection() : e;
      e = this._groups;
      t = t._groups;
      for (var r = e.length, a = Math.min(r, t.length), s = Array(r), l = 0; l < a; ++l) {
        for (var c, u = e[l], d = t[l], h = u.length, f = s[l] = Array(h), g = 0; g < h; ++g) {
          (c = u[g] || d[g]) && (f[g] = c);
        }
      }
      for (; l < r; ++l) {
        s[l] = e[l];
      }
      return new we(s, this._parents);
    }, selection:function() {
      return this;
    }, order:function() {
      for (var e = this._groups, t = -1, n = e.length; ++t < n;) {
        for (var o, r = e[t], i = r.length - 1, a = r[i]; 0 <= --i;) {
          (o = r[i]) && (a && 4 ^ o.compareDocumentPosition(a) && a.parentNode.insertBefore(o, a), a = o);
        }
      }
      return this;
    }, sort:function(e) {
      function t(t, n) {
        return t && n ? e(t.__data__, n.__data__) : !t - !n;
      }
      e || (e = A);
      for (var n = this._groups, o = n.length, r = Array(o), i = 0; i < o; ++i) {
        for (var a, s = n[i], l = s.length, c = r[i] = Array(l), u = 0; u < l; ++u) {
          (a = s[u]) && (c[u] = a);
        }
        c.sort(t);
      }
      return (new we(r, this._parents)).order();
    }, call:function() {
      var e = arguments[0];
      return arguments[0] = this, e.apply(null, arguments), this;
    }, nodes:function() {
      return Array.from(this);
    }, node:function() {
      for (var e = this._groups, t = 0, n = e.length; t < n; ++t) {
        for (var o = e[t], r = 0, i = o.length; r < i; ++r) {
          var a = o[r];
          if (a) {
            return a;
          }
        }
      }
      return null;
    }, size:function() {
      let e = 0;
      for (const t of this) {
        ++e;
      }
      return e;
    }, empty:function() {
      return !this.node();
    }, each:function(e) {
      for (var t = this._groups, n = 0, o = t.length; n < o; ++n) {
        for (var r, i = t[n], a = 0, s = i.length; a < s; ++a) {
          (r = i[a]) && e.call(r, r.__data__, a, i);
        }
      }
      return this;
    }, attr:function(e, t) {
      var n = h(e);
      if (2 > arguments.length) {
        var o = this.node();
        return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n);
      }
      return this.each((null == t ? n.local ? R : D : "function" == typeof t ? n.local ? V : T : n.local ? $ : L)(n, t));
    }, style:function(e, t, n) {
      return 1 < arguments.length ? this.each((null == t ? j : "function" == typeof t ? Z : H)(e, t, null == n ? "" : n)) : X(this.node(), e);
    }, property:function(e, t) {
      return 1 < arguments.length ? this.each((null == t ? Y : "function" == typeof t ? W : F)(e, t)) : this.node()[e];
    }, classed:function(e, t) {
      var n = (e + "").trim().split(/^|\s+/);
      if (2 > arguments.length) {
        for (var o = G(this.node()), r = -1, i = n.length; ++r < i;) {
          if (!o.contains(n[r])) {
            return !1;
          }
        }
        return !0;
      }
      return this.each(("function" == typeof t ? te : t ? J : ee)(n, t));
    }, text:function(e) {
      return arguments.length ? this.each(null == e ? ne : ("function" == typeof e ? re : oe)(e)) : this.node().textContent;
    }, html:function(e) {
      return arguments.length ? this.each(null == e ? ie : ("function" == typeof e ? se : ae)(e)) : this.node().innerHTML;
    }, raise:function() {
      return this.each(le);
    }, lower:function() {
      return this.each(ce);
    }, append:function(e) {
      var t = "function" == typeof e ? e : p(e);
      return this.select(function() {
        return this.appendChild(t.apply(this, arguments));
      });
    }, insert:function(e, t) {
      var n = "function" == typeof e ? e : p(e), o = null == t ? ue : "function" == typeof t ? t : y(t);
      return this.select(function() {
        return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null);
      });
    }, remove:function() {
      return this.each(de);
    }, clone:function(e) {
      return this.select(e ? fe : he);
    }, datum:function(e) {
      return arguments.length ? this.property("__data__", e) : this.node().__data__;
    }, on:function(e, t, n) {
      var o, r, i = function(e) {
        return e.trim().split(/^|\s+/).map(function(e) {
          var t = "", n = e.indexOf(".");
          return 0 <= n && (t = e.slice(n + 1), e = e.slice(0, n)), {type:e, name:t};
        });
      }(e + ""), a = i.length;
      if (!(2 > arguments.length)) {
        s = t ? pe : ge;
        for (o = 0; o < a; ++o) {
          this.each(s(i[o], t, n));
        }
        return this;
      }
      var s = this.node().__on;
      if (s) {
        for (var l, c = 0, u = s.length; c < u; ++c) {
          for (o = 0, l = s[c]; o < a; ++o) {
            if ((r = i[o]).type === l.type && r.name === l.name) {
              return l.value;
            }
          }
        }
      }
    }, dispatch:function(e, t) {
      return this.each(("function" == typeof t ? ve : ye)(e, t));
    }, [Symbol.iterator]:function*() {
      for (var e = this._groups, t = 0, n = e.length; t < n; ++t) {
        for (var o, r = e[t], i = 0, a = r.length; i < a; ++i) {
          (o = r[i]) && (yield o);
        }
      }
    }};
    const Ee = {passive:!1}, ke = {capture:!0, passive:!1};
    var ze = e => () => e;
    Oe.prototype.on = function() {
      var e = this._.on.apply(this._, arguments);
      return e === this._ ? this : e;
    };
    var je = 1 / .7, Ye = /^#([0-9a-f]{3,8})$/, Fe = RegExp("^rgb\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*\\)$"), We = RegExp("^rgb\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*\\)$"), Ke = RegExp("^rgba\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"), Ge = RegExp("^rgba\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"), 
    qe = RegExp("^hsl\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*\\)$"), Ue = RegExp("^hsla\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"), Qe = {aliceblue:15792383, antiquewhite:16444375, aqua:65535, aquamarine:8388564, azure:15794175, 
    beige:16119260, bisque:16770244, black:0, blanchedalmond:16772045, blue:255, blueviolet:9055202, brown:10824234, burlywood:14596231, cadetblue:6266528, chartreuse:8388352, chocolate:13789470, coral:16744272, cornflowerblue:6591981, cornsilk:16775388, crimson:14423100, cyan:65535, darkblue:139, darkcyan:35723, darkgoldenrod:12092939, darkgray:11119017, darkgreen:25600, darkgrey:11119017, darkkhaki:12433259, darkmagenta:9109643, darkolivegreen:5597999, darkorange:16747520, darkorchid:10040012, 
    darkred:9109504, darksalmon:15308410, darkseagreen:9419919, darkslateblue:4734347, darkslategray:3100495, darkslategrey:3100495, darkturquoise:52945, darkviolet:9699539, deeppink:16716947, deepskyblue:49151, dimgray:6908265, dimgrey:6908265, dodgerblue:2003199, firebrick:11674146, floralwhite:16775920, forestgreen:2263842, fuchsia:16711935, gainsboro:14474460, ghostwhite:16316671, gold:16766720, goldenrod:14329120, gray:8421504, green:32768, greenyellow:11403055, grey:8421504, honeydew:15794160, 
    hotpink:16738740, indianred:13458524, indigo:4915330, ivory:16777200, khaki:15787660, lavender:15132410, lavenderblush:16773365, lawngreen:8190976, lemonchiffon:16775885, lightblue:11393254, lightcoral:15761536, lightcyan:14745599, lightgoldenrodyellow:16448210, lightgray:13882323, lightgreen:9498256, lightgrey:13882323, lightpink:16758465, lightsalmon:16752762, lightseagreen:2142890, lightskyblue:8900346, lightslategray:7833753, lightslategrey:7833753, lightsteelblue:11584734, lightyellow:16777184, 
    lime:65280, limegreen:3329330, linen:16445670, magenta:16711935, maroon:8388608, mediumaquamarine:6737322, mediumblue:205, mediumorchid:12211667, mediumpurple:9662683, mediumseagreen:3978097, mediumslateblue:8087790, mediumspringgreen:64154, mediumturquoise:4772300, mediumvioletred:13047173, midnightblue:1644912, mintcream:16121850, mistyrose:16770273, moccasin:16770229, navajowhite:16768685, navy:128, oldlace:16643558, olive:8421376, olivedrab:7048739, orange:16753920, orangered:16729344, orchid:14315734, 
    palegoldenrod:15657130, palegreen:10025880, paleturquoise:11529966, palevioletred:14381203, papayawhip:16773077, peachpuff:16767673, peru:13468991, pink:16761035, plum:14524637, powderblue:11591910, purple:8388736, rebeccapurple:6697881, red:16711680, rosybrown:12357519, royalblue:4286945, saddlebrown:9127187, salmon:16416882, sandybrown:16032864, seagreen:3050327, seashell:16774638, sienna:10506797, silver:12632256, skyblue:8900331, slateblue:6970061, slategray:7372944, slategrey:7372944, snow:16775930, 
    springgreen:65407, steelblue:4620980, tan:13808780, teal:32896, thistle:14204888, tomato:16737095, turquoise:4251856, violet:15631086, wheat:16113331, white:16777215, whitesmoke:16119285, yellow:16776960, yellowgreen:10145074};
    $e(Ve, tt, {copy(e) {
      return Object.assign(new this.constructor(), this, e);
    }, displayable() {
      return this.rgb().displayable();
    }, hex:Je, formatHex:Je, formatHex8:function() {
      return this.rgb().formatHex8();
    }, formatHsl:function() {
      return ht(this).formatHsl();
    }, formatRgb:et, toString:et});
    $e(it, rt, Te(Ve, {brighter(e) {
      return e = null == e ? je : Math.pow(je, e), new it(this.r * e, this.g * e, this.b * e, this.opacity);
    }, darker(e) {
      return e = null == e ? .7 : Math.pow(.7, e), new it(this.r * e, this.g * e, this.b * e, this.opacity);
    }, rgb() {
      return this;
    }, clamp() {
      return new it(ct(this.r), ct(this.g), ct(this.b), lt(this.opacity));
    }, displayable() {
      return -.5 <= this.r && 255.5 > this.r && -.5 <= this.g && 255.5 > this.g && -.5 <= this.b && 255.5 > this.b && 0 <= this.opacity && 1 >= this.opacity;
    }, hex:at, formatHex:at, formatHex8:function() {
      return `#${ut(this.r)}${ut(this.g)}${ut(this.b)}${ut(255 * (isNaN(this.opacity) ? 1 : this.opacity))}`;
    }, formatRgb:st, toString:st}));
    $e(ft, function(e, t, n, o) {
      return 1 === arguments.length ? ht(e) : new ft(e, t, n, null == o ? 1 : o);
    }, Te(Ve, {brighter(e) {
      return e = null == e ? je : Math.pow(je, e), new ft(this.h, this.s, this.l * e, this.opacity);
    }, darker(e) {
      return e = null == e ? .7 : Math.pow(.7, e), new ft(this.h, this.s, this.l * e, this.opacity);
    }, rgb() {
      var e = this.h % 360 + 360 * (0 > this.h), t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l;
      t = n + (.5 > n ? n : 1 - n) * t;
      n = 2 * n - t;
      return new it(mt(240 <= e ? e - 240 : e + 120, n, t), mt(e, n, t), mt(120 > e ? e + 240 : e - 120, n, t), this.opacity);
    }, clamp() {
      return new ft(gt(this.h), pt(this.s), pt(this.l), lt(this.opacity));
    }, displayable() {
      return (0 <= this.s && 1 >= this.s || isNaN(this.s)) && 0 <= this.l && 1 >= this.l && 0 <= this.opacity && 1 >= this.opacity;
    }, formatHsl() {
      const e = lt(this.opacity);
      return `${1 === e ? "hsl(" : "hsla("}${gt(this.h)}, ${100 * pt(this.s)}%, ${100 * pt(this.l)}%${1 === e ? ")" : `, ${e})`}`;
    }}));
    var yt = e => () => e, wt = function e(t) {
      function o(e, t) {
        var o = n((e = rt(e)).r, (t = rt(t)).r), r = n(e.g, t.g), i = n(e.b, t.b), a = xt(e.opacity, t.opacity);
        return function(t) {
          return e.r = o(t), e.g = r(t), e.b = i(t), e.opacity = a(t), e + "";
        };
      }
      var n = vt(t);
      return o.gamma = e, o;
    }(1), Mt = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Nt = new RegExp(Mt.source, "g"), zt, Ot = 180 / Math.PI, It = {translateX:0, translateY:0, rotate:0, skewX:0, scaleX:1, scaleY:1}, Rt = Dt(function(e) {
      e = new ("function" == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(e + "");
      return e.isIdentity ? It : At(e.a, e.b, e.c, e.d, e.e, e.f);
    }, "px, ", "px)", "deg)"), Lt = Dt(function(e) {
      return null == e ? It : (zt || (zt = document.createElementNS("http://www.w3.org/2000/svg", "g")), zt.setAttribute("transform", e), (e = zt.transform.baseVal.consolidate()) ? At((e = e.matrix).a, e.b, e.c, e.d, e.e, e.f) : It);
    }, ", ", ")", ")"), Tt, Vt, Bt = function e(t, n, o) {
      function r(e, r) {
        var s = e[0], l = e[1], c = e[2];
        e = r[2];
        var f = r[0] - s, g = r[1] - l, p = f * f + g * g;
        if (1E-12 > p) {
          var a = Math.log(e / c) / t;
          e = function(e) {
            return [s + e * f, l + e * g, c * Math.exp(t * e * a)];
          };
        } else {
          var m = Math.sqrt(p);
          r = (e * e - c * c + o * p) / (2 * c * n * m);
          e = (e * e - c * c - o * p) / (2 * e * n * m);
          var x = Math.log(Math.sqrt(r * r + 1) - r);
          a = (Math.log(Math.sqrt(e * e + 1) - e) - x) / t;
          e = function(e$jscomp$0) {
            var o;
            e$jscomp$0 *= a;
            var i = $t(x), JSCompiler_temp_const = i * (o = t * e$jscomp$0 + x, ((o = Math.exp(2 * o)) - 1) / (o + 1)), e = x;
            o = ((e = Math.exp(e)) - 1 / e) / 2;
            JSCompiler_temp_const = c / (n * m) * (JSCompiler_temp_const - o);
            return [s + JSCompiler_temp_const * f, l + JSCompiler_temp_const * g, c * i / $t(t * e$jscomp$0 + x)];
          };
        }
        return e.duration = 1E3 * a * t / Math.SQRT2, e;
      }
      return r.rho = function(t) {
        t = Math.max(.001, +t);
        var o = t * t;
        return e(t, o, o * o);
      }, r;
    }(Math.SQRT2, 2, 4), jt = 0, Ht = 0, Zt = 0, Yt = 0, Ft = 0, Wt = 0, Kt = "object" == typeof performance && performance.now ? performance : Date, Gt = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
      setTimeout(e, 17);
    };
    Qt.prototype = Jt.prototype = {constructor:Qt, restart:function(e, t, n) {
      if ("function" != typeof e) {
        throw new TypeError("callback is not a function");
      }
      n = (null == n ? qt() : +n) + (null == t ? 0 : +t);
      this._next || Vt === this || (Vt ? Vt._next = this : Tt = this, Vt = this);
      this._call = e;
      this._time = n;
      nn();
    }, stop:function() {
      this._call && (this._call = null, this._time = 1 / 0, nn());
    }};
    var rn = a("start", "end", "cancel", "interrupt"), an = [], Rn = be.prototype.constructor, $n = 0, Bn = be.prototype;
    Tn.prototype = {constructor:Tn, select:function(e) {
      var t = this._name, n = this._id;
      "function" != typeof e && (e = y(e));
      for (var o = this._groups, r = o.length, i = Array(r), a = 0; a < r; ++a) {
        for (var s, l, c = o[a], u = c.length, d = i[a] = Array(u), h = 0; h < u; ++h) {
          (s = c[h]) && (l = e.call(s, s.__data__, h, c)) && ("__data__" in s && (l.__data__ = s.__data__), d[h] = l, gn(d[h], t, n, h, d, yn(s, n)));
        }
      }
      return new Tn(i, this._parents, t, n);
    }, selectAll:function(e) {
      var t = this._name, n = this._id;
      "function" != typeof e && (e = x(e));
      for (var o = this._groups, r = o.length, i = [], a = [], s = 0; s < r; ++s) {
        for (var l, c = o[s], u = c.length, d = 0; d < u; ++d) {
          if (l = c[d]) {
            for (var h, f = e.call(l, l.__data__, d, c), g = yn(l, n), p = 0, m = f.length; p < m; ++p) {
              (h = f[p]) && gn(h, t, n, p, f, g);
            }
            i.push(f);
            a.push(l);
          }
        }
      }
      return new Tn(i, a, t, n);
    }, selectChild:Bn.selectChild, selectChildren:Bn.selectChildren, filter:function(e) {
      "function" != typeof e && (e = b(e));
      for (var t = this._groups, n = t.length, o = Array(n), r = 0; r < n; ++r) {
        for (var i, a = t[r], s = a.length, l = o[r] = [], c = 0; c < s; ++c) {
          (i = a[c]) && e.call(i, i.__data__, c, a) && l.push(i);
        }
      }
      return new Tn(o, this._parents, this._name, this._id);
    }, merge:function(e) {
      if (e._id !== this._id) {
        throw Error();
      }
      var t = this._groups;
      e = e._groups;
      for (var o = t.length, i = Math.min(o, e.length), a = Array(o), s = 0; s < i; ++s) {
        for (var l, c = t[s], u = e[s], d = c.length, h = a[s] = Array(d), f = 0; f < d; ++f) {
          (l = c[f] || u[f]) && (h[f] = l);
        }
      }
      for (; s < o; ++s) {
        a[s] = t[s];
      }
      return new Tn(a, this._parents, this._name, this._id);
    }, selection:function() {
      return new Rn(this._groups, this._parents);
    }, transition:function() {
      for (var e = this._name, t = this._id, n = ++$n, o = this._groups, r = o.length, i = 0; i < r; ++i) {
        for (var a, s = o[i], l = s.length, c = 0; c < l; ++c) {
          if (a = s[c]) {
            var u = yn(a, t);
            gn(a, e, n, c, s, {time:u.time + u.delay + u.duration, delay:0, duration:u.duration, ease:u.ease});
          }
        }
      }
      return new Tn(o, this._parents, e, n);
    }, call:Bn.call, nodes:Bn.nodes, node:Bn.node, size:Bn.size, empty:Bn.empty, each:Bn.each, on:function(e, t) {
      var n = this._id;
      return 2 > arguments.length ? yn(this.node(), n).on.on(e) : this.each(function(e, t, n) {
        var o, r, i = function(e) {
          return (e + "").trim().split(/^|\s+/).every(function(e) {
            var t = e.indexOf(".");
            return 0 <= t && (e = e.slice(0, t)), !e || "start" === e;
          });
        }(t) ? pn : mn;
        return function() {
          var a = i(this, e), s = a.on;
          s !== o && (r = (o = s).copy()).on(t, n);
          a.on = r;
        };
      }(n, e, t));
    }, attr:function(e, t) {
      var n = h(e), o = "transform" === n ? Lt : Sn;
      return this.attrTween(e, "function" == typeof t ? (n.local ? _n : Nn)(n, o, bn(this, "attr." + e, t)) : null == t ? (n.local ? En : Cn)(n) : (n.local ? Mn : kn)(n, o, t));
    }, attrTween:function(e, t) {
      var n = "attr." + e;
      if (2 > arguments.length) {
        return (n = this.tween(n)) && n._value;
      }
      if (null == t) {
        return this.tween(n, null);
      }
      if ("function" != typeof t) {
        throw Error();
      }
      var o = h(e);
      return this.tween(n, (o.local ? Pn : zn)(o, t));
    }, style:function(e, t, n) {
      var o = "transform" == (e += "") ? Rt : Sn;
      return null == t ? this.styleTween(e, function(e, t) {
        var n, o, r;
        return function() {
          var i = X(this, e), a = (this.style.removeProperty(e), X(this, e));
          return i === a ? null : i === n && a === o ? r : r = t(n = i, o = a);
        };
      }(e, o)).on("end.style." + e, Ln(e)) : "function" == typeof t ? this.styleTween(e, function(e, t, n) {
        var o, r, i;
        return function() {
          var a = X(this, e), s = n(this), l = s + "";
          return null == s && (this.style.removeProperty(e), l = s = X(this, e)), a === l ? null : a === o && l === r ? i : (r = l, i = t(o = a, s));
        };
      }(e, o, bn(this, "style." + e, t))).each(function(e, t) {
        var n, o, r, i, a = "style." + t, s = "end." + a;
        return function() {
          var l = mn(this, e), c = l.on, u = null == l.value[a] ? i || (i = Ln(t)) : void 0;
          c === n && r === u || (o = (n = c).copy()).on(s, r = u);
          l.on = o;
        };
      }(this._id, e)) : this.styleTween(e, function(e, t, n) {
        var o, r, i = n + "";
        return function() {
          var a = X(this, e);
          return a === i ? null : a === o ? r : r = t(o = a, n);
        };
      }(e, o, t), n).on("end.style." + e, null);
    }, styleTween:function(e, t, n) {
      var o = "style." + (e += "");
      if (2 > arguments.length) {
        return (o = this.tween(o)) && o._value;
      }
      if (null == t) {
        return this.tween(o, null);
      }
      if ("function" != typeof t) {
        throw Error();
      }
      return this.tween(o, function(e, t, n) {
        function i() {
          var i = t.apply(this, arguments);
          return i !== r && (o = (r = i) && function(e, t, n) {
            return function(o) {
              this.style.setProperty(e, t.call(this, o), n);
            };
          }(e, i, n)), o;
        }
        var o, r;
        return i._value = t, i;
      }(e, t, null == n ? "" : n));
    }, text:function(e) {
      return this.tween("text", "function" == typeof e ? function(e) {
        return function() {
          var t = e(this);
          this.textContent = null == t ? "" : t;
        };
      }(bn(this, "text", e)) : function(e) {
        return function() {
          this.textContent = e;
        };
      }(null == e ? "" : e + ""));
    }, textTween:function(e) {
      var t = "text";
      if (1 > arguments.length) {
        return (t = this.tween(t)) && t._value;
      }
      if (null == e) {
        return this.tween(t, null);
      }
      if ("function" != typeof e) {
        throw Error();
      }
      return this.tween(t, function(e) {
        function o() {
          var o = e.apply(this, arguments);
          return o !== n && (t = (n = o) && function(e) {
            return function(t) {
              this.textContent = e.call(this, t);
            };
          }(o)), t;
        }
        var t, n;
        return o._value = e, o;
      }(e));
    }, remove:function() {
      return this.on("end.remove", function(e) {
        return function() {
          var t = this.parentNode, n;
          for (n in this.__transition) {
            if (+n !== e) {
              return;
            }
          }
          t && t.removeChild(this);
        };
      }(this._id));
    }, tween:function(e, t) {
      var n = this._id;
      if (e += "", 2 > arguments.length) {
        for (var r = yn(this.node(), n).tween, i = 0, a = r.length; i < a; ++i) {
          if ((n = r[i]).name === e) {
            return n.value;
          }
        }
        return null;
      }
      return this.each((null == t ? xn : wn)(n, e, t));
    }, delay:function(e) {
      var t = this._id;
      return arguments.length ? this.each(("function" == typeof e ? On : In)(t, e)) : yn(this.node(), t).delay;
    }, duration:function(e) {
      var t = this._id;
      return arguments.length ? this.each(("function" == typeof e ? An : Dn)(t, e)) : yn(this.node(), t).duration;
    }, ease:function(e) {
      var t = this._id;
      return arguments.length ? this.each(function(e, t) {
        if ("function" != typeof t) {
          throw Error();
        }
        return function() {
          mn(this, e).ease = t;
        };
      }(t, e)) : yn(this.node(), t).ease;
    }, easeVarying:function(e) {
      if ("function" != typeof e) {
        throw Error();
      }
      return this.each(function(e, t) {
        return function() {
          var n = t.apply(this, arguments);
          if ("function" != typeof n) {
            throw Error();
          }
          mn(this, e).ease = n;
        };
      }(this._id, e));
    }, end:function() {
      var e, t, n = this, o = n._id, r = n.size();
      return new Promise(function(i, a) {
        var s = {value:a}, l = {value:function() {
          0 == --r && i();
        }};
        n.each(function() {
          var n = mn(this, o), r = n.on;
          r !== e && ((t = (e = r).copy())._.cancel.push(s), t._.interrupt.push(s), t._.end.push(l));
          n.on = t;
        });
        0 === r && i();
      });
    }, [Symbol.iterator]:Bn[Symbol.iterator]};
    var jn = {time:null, delay:0, duration:250, ease:function(e) {
      return (1 >= (e *= 2) ? e * e * e : (e -= 2) * e * e + 2) / 2;
    }};
    be.prototype.interrupt = function(e) {
      return this.each(function() {
        vn(this, e);
      });
    };
    be.prototype.transition = function(e) {
      var t, n;
      e instanceof Tn ? (t = e._id, e = e._name) : (t = ++$n, (n = jn).time = qt(), e = null == e ? null : e + "");
      for (var o = this._groups, r = o.length, i = 0; i < r; ++i) {
        for (var a, s = o[i], l = s.length, c = 0; c < l; ++c) {
          if (a = s[c]) {
            var JSCompiler_temp_const = a, JSCompiler_temp_const$jscomp$0 = e, JSCompiler_temp_const$jscomp$1 = t, JSCompiler_temp_const$jscomp$2 = c, JSCompiler_temp_const$jscomp$3 = s, JSCompiler_temp;
            if (!(JSCompiler_temp = n)) {
              for (JSCompiler_temp = void 0; !(JSCompiler_temp = a.__transition) || !(JSCompiler_temp = JSCompiler_temp[t]);) {
                if (!(a = a.parentNode)) {
                  throw Error(`transition ${t} not found`);
                }
              }
            }
            gn(JSCompiler_temp_const, JSCompiler_temp_const$jscomp$0, JSCompiler_temp_const$jscomp$1, JSCompiler_temp_const$jscomp$2, JSCompiler_temp_const$jscomp$3, JSCompiler_temp);
          }
        }
      }
      return new Tn(o, this._parents, e, t);
    };
    var Zn = e => () => e;
    Yn.prototype = {constructor:Yn, scale:function(e) {
      return 1 === e ? this : new Yn(this.k * e, this.x, this.y);
    }, translate:function(e, t) {
      return 0 === e & 0 === t ? this : new Yn(this.k, this.x + this.k * e, this.y + this.k * t);
    }, apply:function(e) {
      return [e[0] * this.k + this.x, e[1] * this.k + this.y];
    }, applyX:function(e) {
      return e * this.k + this.x;
    }, applyY:function(e) {
      return e * this.k + this.y;
    }, invert:function(e) {
      return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
    }, invertX:function(e) {
      return (e - this.x) / this.k;
    }, invertY:function(e) {
      return (e - this.y) / this.k;
    }, rescaleX:function(e) {
      return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
    }, rescaleY:function(e) {
      return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
    }, toString:function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }};
    var Fn = new Yn(1, 0, 0);
    Wn.prototype = Yn.prototype;
    const oo = {error001:() => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001", error002:() => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.", error003:e => `Node type "${e}" not found. Using fallback type "default".`, error004:() => "The React Flow parent container needs a width and a height to render the graph.", 
    error005:() => "Only child nodes can use a parent extent.", error006:() => "Can't create edge. An edge needs a source and a target.", error007:e => `The old edge with id=${e} does not exist.`, error009:e => `Marker type "${e}" doesn't exist.`, error008:(e, {id:t, sourceHandle:n, targetHandle:o}) => `Couldn't create edge for ${e} handle id: "${"source" === e ? n : o}", edge id: ${t}.`, error010:() => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.", error011:e => 
    `Edge type "${e}" not found. Using fallback type "default".`, error012:e => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`, error013:(e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`, error014:() => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.", 
    error015:() => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."}, ro = [[Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY], [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]], io = ["Enter", " ", "Escape"], ao = {"node.a11yDescription.default":"Press enter or space to select a node. Press delete to remove it and escape to cancel.", "node.a11yDescription.keyboardDisabled":"Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.", 
    "node.a11yDescription.ariaLiveMessage":({direction:e, x:t, y:n}) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`, "edge.a11yDescription.default":"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.", "controls.ariaLabel":"Control Panel", "controls.zoomIn.ariaLabel":"Zoom In", "controls.zoomOut.ariaLabel":"Zoom Out", "controls.fitView.ariaLabel":"Fit View", "controls.interactive.ariaLabel":"Toggle Interactivity", "minimap.ariaLabel":"Mini Map", 
    "handle.ariaLabel":"Handle"};
    var so, lo, co;
    e$jscomp$0.ConnectionMode = void 0;
    (so = e$jscomp$0.ConnectionMode || (e$jscomp$0.ConnectionMode = {})).Strict = "strict";
    so.Loose = "loose";
    e$jscomp$0.PanOnScrollMode = void 0;
    (lo = e$jscomp$0.PanOnScrollMode || (e$jscomp$0.PanOnScrollMode = {})).Free = "free";
    lo.Vertical = "vertical";
    lo.Horizontal = "horizontal";
    e$jscomp$0.SelectionMode = void 0;
    (co = e$jscomp$0.SelectionMode || (e$jscomp$0.SelectionMode = {})).Partial = "partial";
    co.Full = "full";
    const uo = {inProgress:!1, isValid:null, from:null, fromHandle:null, fromPosition:null, fromNode:null, to:null, toHandle:null, toPosition:null, toNode:null};
    var ho, fo, go;
    e$jscomp$0.ConnectionLineType = void 0;
    (ho = e$jscomp$0.ConnectionLineType || (e$jscomp$0.ConnectionLineType = {})).Bezier = "default";
    ho.Straight = "straight";
    ho.Step = "step";
    ho.SmoothStep = "smoothstep";
    ho.SimpleBezier = "simplebezier";
    e$jscomp$0.MarkerType = void 0;
    (fo = e$jscomp$0.MarkerType || (e$jscomp$0.MarkerType = {})).Arrow = "arrow";
    fo.ArrowClosed = "arrowclosed";
    e$jscomp$0.Position = void 0;
    (go = e$jscomp$0.Position || (e$jscomp$0.Position = {})).Left = "left";
    go.Top = "top";
    go.Right = "right";
    go.Bottom = "bottom";
    const po = {[e$jscomp$0.Position.Left]:e$jscomp$0.Position.Right, [e$jscomp$0.Position.Right]:e$jscomp$0.Position.Left, [e$jscomp$0.Position.Top]:e$jscomp$0.Position.Bottom, [e$jscomp$0.Position.Bottom]:e$jscomp$0.Position.Top}, xo = e => "id" in e && "source" in e && "target" in e, wo = e => "id" in e && "internals" in e && !("source" in e) && !("target" in e), bo = (e, t = [0, 0]) => {
      const {width:n, height:o} = qo(e);
      t = e.origin ?? t;
      return {x:e.position.x - n * t[0], y:e.position.y - o * t[1]};
    }, So = (e, t = {nodeOrigin:[0, 0]}) => {
      if (0 === e.length) {
        return {x:0, y:0, width:0, height:0};
      }
      e = e.reduce((e, n) => {
        const o = "string" == typeof n;
        let r = t.nodeLookup || o ? void 0 : n;
        t.nodeLookup && (r = o ? t.nodeLookup.get(n) : wo(n) ? n : t.nodeLookup.get(n.id));
        n = r ? $o(r, t.nodeOrigin) : {x:0, y:0, x2:0, y2:0};
        return Ao(e, n);
      }, {x:1 / 0, y:1 / 0, x2:-1 / 0, y2:-1 / 0});
      return Ro(e);
    }, Co = (e, t = {}) => {
      if (0 === e.size) {
        return {x:0, y:0, width:0, height:0};
      }
      let n = {x:1 / 0, y:1 / 0, x2:-1 / 0, y2:-1 / 0};
      return e.forEach(e => {
        if (void 0 === t.filter || t.filter(e)) {
          e = $o(e), n = Ao(n, e);
        }
      }), Ro(n);
    }, Eo = (e$jscomp$0, t$jscomp$0, [n$jscomp$0, o$jscomp$0, r] = [0, 0, 1], i = !1, a = !1) => {
      t$jscomp$0 = {...Xo(t$jscomp$0, [n$jscomp$0, o$jscomp$0, r]), width:t$jscomp$0.width / r, height:t$jscomp$0.height / r};
      n$jscomp$0 = [];
      for (const t of e$jscomp$0.values()) {
        const {measured:e, selectable:n = !0, hidden:o = !1} = t;
        a && !n || o || (o$jscomp$0 = e.width ?? t.width ?? t.initialWidth ?? null, r = e.height ?? t.height ?? t.initialHeight ?? null, e$jscomp$0 = Vo(t$jscomp$0, Lo(t)), o$jscomp$0 = (o$jscomp$0 ?? 0) * (r ?? 0), r = i && 0 < e$jscomp$0, (!t.internals.handleBounds || r || e$jscomp$0 >= o$jscomp$0 || t.dragging) && n$jscomp$0.push(t));
      }
      return n$jscomp$0;
    }, ko = (e, t) => {
      const n = new Set();
      return e.forEach(e => {
        n.add(e.id);
      }), t.filter(e => n.has(e.source) || n.has(e.target));
    }, _o = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Po = (e = {x:0, y:0}, t, n) => ({x:_o(e.x, t[0][0], t[1][0] - (n?.width ?? 0)), y:_o(e.y, t[0][1], t[1][1] - (n?.height ?? 0))}), Oo = (e, t, n) => e < t ? _o(Math.abs(e - t), 1, t) / t : e > n ? -_o(Math.abs(e - n), 1, t) / t : 0, Io = (e, t, n = 15, o = 40) => [Oo(e.x, o, t.width - o) * n, Oo(e.y, o, t.height - o) * n], Ao = (e, t) => ({x:Math.min(e.x, t.x), y:Math.min(e.y, t.y), x2:Math.max(e.x2, t.x2), y2:Math.max(e.y2, t.y2)}), Do = 
    ({x:e, y:t, width:n, height:o}) => ({x:e, y:t, x2:e + n, y2:t + o}), Ro = ({x:e, y:t, x2:n, y2:o}) => ({x:e, y:t, width:n - e, height:o - t}), Lo = (e, t = [0, 0]) => {
      const {x:n, y:o} = wo(e) ? e.internals.positionAbsolute : bo(e, t);
      return {x:n, y:o, width:e.measured?.width ?? e.width ?? e.initialWidth ?? 0, height:e.measured?.height ?? e.height ?? e.initialHeight ?? 0};
    }, $o = (e, t = [0, 0]) => {
      const {x:n, y:o} = wo(e) ? e.internals.positionAbsolute : bo(e, t);
      return {x:n, y:o, x2:n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0), y2:o + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)};
    }, To = (e, t) => Ro(Ao(Do(e), Do(t))), Vo = (e, t) => Math.ceil(Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)) * Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y))), Bo = e => jo(e.width) && jo(e.height) && jo(e.x) && jo(e.y), jo = e => !isNaN(e) && isFinite(e), Ho = (e, t) => {
    }, Zo = (e, t = [1, 1]) => ({x:t[0] * Math.round(e.x / t[0]), y:t[1] * Math.round(e.y / t[1])}), Xo = ({x:e, y:t}, [n, o, r], i = !1, a = [1, 1]) => {
      e = {x:(e - n) / r, y:(t - o) / r};
      return i ? Zo(e, a) : e;
    }, Yo = ({x:e, y:t}, [n, o, r]) => ({x:e * r + n, y:t * r + o}), Wo = (e, t, n, o, r, i) => {
      i = function(e, t, n) {
        if ("string" == typeof e || "number" == typeof e) {
          var o = Fo(e, n);
          e = Fo(e, t);
          return {top:o, right:e, bottom:o, left:e, x:2 * e, y:2 * o};
        }
        if ("object" == typeof e) {
          o = Fo(e.top ?? e.y ?? 0, n);
          n = Fo(e.bottom ?? e.y ?? 0, n);
          const i = Fo(e.left ?? e.x ?? 0, t);
          e = Fo(e.right ?? e.x ?? 0, t);
          return {top:o, right:e, bottom:n, left:i, x:i + e, y:o + n};
        }
        return {top:0, right:0, bottom:0, left:0, x:0, y:0};
      }(i, t, n);
      o = _o(Math.min((t - i.x) / e.width, (n - i.y) / e.height), o, r);
      r = t / 2 - (e.x + e.width / 2) * o;
      const h = n / 2 - (e.y + e.height / 2) * o;
      e = function(e, t, n, o, r, i) {
        const {x:a, y:s} = Yo(e, [t, n, o]), {x:l, y:c} = Yo({x:e.x + e.width, y:e.y + e.height}, [t, n, o]);
        return {left:Math.floor(a), top:Math.floor(s), right:Math.floor(r - l), bottom:Math.floor(i - c)};
      }(e, r, h, o, t, n);
      return {x:r - Math.min(e.left - i.left, 0) + Math.min(e.right - i.right, 0), y:h - Math.min(e.top - i.top, 0) + Math.min(e.bottom - i.bottom, 0), zoom:o};
    }, Ko = () => "undefined" != typeof navigator && 0 <= navigator?.userAgent?.indexOf("Mac"), tr = e => ({width:e.offsetWidth, height:e.offsetHeight}), or = ["INPUT", "SELECT", "TEXTAREA"], ar = (e, t) => {
      const n = "clientX" in e;
      return {x:(n ? e.clientX : e.touches?.[0].clientX) - (t?.left ?? 0), y:(n ? e.clientY : e.touches?.[0].clientY) - (t?.top ?? 0)};
    }, sr = (e, t, n, o, r) => (t = t.querySelectorAll(`.${e}`)) && t.length ? Array.from(t).map(t => {
      const i = t.getBoundingClientRect();
      return {id:t.getAttribute("data-handleid"), type:e, nodeId:r, position:t.getAttribute("data-handlepos"), x:(i.left - n.left) / o, y:(i.top - n.top) / o, ...tr(t)};
    }) : null, gr = ({source:e, sourceHandle:t, target:n, targetHandle:o}) => `xy-edge__${e}${t || ""}-${n}${o || ""}`, pr = (e, t) => {
      if (!e.source || !e.target) {
        return t;
      }
      let n;
      return n = xo(e) ? {...e} : {...e, id:gr(e)}, ((e, t) => t.some(t => !(t.source !== e.source || t.target !== e.target || t.sourceHandle !== e.sourceHandle && (t.sourceHandle || e.sourceHandle) || t.targetHandle !== e.targetHandle && (t.targetHandle || e.targetHandle))))(n, t) ? t : (null === n.sourceHandle && delete n.sourceHandle, null === n.targetHandle && delete n.targetHandle, t.concat(n));
    }, yr = {[e$jscomp$0.Position.Left]:{x:-1, y:0}, [e$jscomp$0.Position.Right]:{x:1, y:0}, [e$jscomp$0.Position.Top]:{x:0, y:-1}, [e$jscomp$0.Position.Bottom]:{x:0, y:1}}, vr = ({source:t, sourcePosition:n = e$jscomp$0.Position.Bottom, target:o}) => n === e$jscomp$0.Position.Left || n === e$jscomp$0.Position.Right ? t.x < o.x ? {x:1, y:0} : {x:-1, y:0} : t.y < o.y ? {x:0, y:1} : {x:0, y:-1}, Nr = {nodeOrigin:[0, 0], nodeExtent:ro, elevateNodesOnSelect:!0, defaults:{}}, _r = {...Nr, checkEquality:!0}, 
    Fr = () => !0, Kr = {onPointerDown:function(t, {connectionMode:n$jscomp$0, connectionRadius:o$jscomp$0, handleId:r$jscomp$0, nodeId:i, edgeUpdaterType:a, isTarget:s, domNode:l, nodeLookup:c, lib:u, autoPanOnConnect:d, flowId:h, panBy:f, cancelConnection:g, onConnectStart:p, onConnect:m, onConnectEnd:y, isValidConnection:v = Fr, onReconnectEnd:x, updateConnection:w, getTransform:b, getFromHandle:S, autoPanSpeed:C, dragThreshold:E = 1, handleDomNode:k}) {
      function B() {
        if (d && I) {
          var [e, t] = Io(R, I, C);
          f({x:e, y:t});
          _ = requestAnimationFrame(B);
        }
      }
      function X() {
        A = !0;
        w(Z);
        p?.(t, {nodeId:i, handleId:r$jscomp$0, handleType:O});
      }
      function Y(e) {
        if (!A) {
          const {x:t, y:n} = ar(e);
          var o = t - P, r = n - z;
          if (!(o * o + r * r > E * E)) {
            return;
          }
          X();
        }
        if (!S() || !j) {
          return void F(e);
        }
        o = b();
        R = ar(e, I);
        N = Zr(Xo(R, o, !1, [1, 1]), o$jscomp$0, c, j);
        L || (B(), L = !0);
        e = Wr(e, {handle:N, connectionMode:n$jscomp$0, fromNodeId:i, fromHandleId:r$jscomp$0, fromType:s ? "target" : "source", isValidConnection:v, doc:M, lib:u, flowId:h, nodeLookup:c});
        V = e.handleDomNode;
        $ = e.connection;
        r = !!N;
        var t = e.isValid;
        let n = null;
        T = (t ? n = !0 : r && !t && (n = !1), n);
        o = {...Z, isValid:T, to:e.toHandle && T ? Yo({x:e.toHandle.x, y:e.toHandle.y}, o) : R, toHandle:e.toHandle, toPosition:T && e.toHandle ? e.toHandle.position : po[j.position], toNode:e.toHandle ? c.get(e.toHandle.nodeId) : null};
        T && N && Z.toHandle && o.toHandle && Z.toHandle.type === o.toHandle.type && Z.toHandle.nodeId === o.toHandle.nodeId && Z.toHandle.id === o.toHandle.id && Z.to.x === o.to.x && Z.to.y === o.to.y || (w(o), Z = o);
      }
      function F(e) {
        if (!("touches" in e && 0 < e.touches.length)) {
          if (A) {
            (N || V) && $ && T && m?.($);
            const {inProgress:t, ...n} = Z, o = {...n, toPosition:Z.toHandle ? Z.toPosition : null};
            y?.(e, o);
            a && x?.(e, o);
          }
          g();
          cancelAnimationFrame(_);
          T = L = !1;
          V = $ = null;
          M.removeEventListener("mousemove", Y);
          M.removeEventListener("mouseup", F);
          M.removeEventListener("touchmove", Y);
          M.removeEventListener("touchend", F);
        }
      }
      const M = t.target?.getRootNode?.() || window?.document;
      let N, _ = 0;
      const {x:P, y:z} = ar(t), O = Yr(a, k), I = l?.getBoundingClientRect();
      let A = !1;
      if (I && O && (l = Xr(i, O, r$jscomp$0, c, n$jscomp$0))) {
        var R = ar(t, I), L = !1, $ = null, T = !1, V = null, j = {...l, nodeId:i, type:O, position:l.position};
        l = c.get(i);
        var Z = {inProgress:!0, isValid:null, from:Cr(l, j, e$jscomp$0.Position.Left, !0), fromHandle:j, fromPosition:j.position, fromNode:l, to:R, toHandle:null, toPosition:po[j.position], toNode:null};
        0 === E && X();
        M.addEventListener("mousemove", Y);
        M.addEventListener("mouseup", F);
        M.addEventListener("touchmove", Y);
        M.addEventListener("touchend", F);
      }
    }, isValid:Wr}, Gr = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, qr = e => ({x:e.x, y:e.y, zoom:e.k}), Ur = ({x:e, y:t, zoom:n}) => Fn.translate(e, t).scale(n), Jr = (e, t) => 2 === t && Array.isArray(e) && e.includes(2), ei = e => (1 >= (e *= 2) ? e * e * e : (e -= 2) * e * e + 2) / 2, ti = (e, t = 0, n = ei, o = () => {
    }) => {
      const r = "number" == typeof t && 0 < t;
      return r || o(), r ? e.transition().duration(t).ease(n).on("end", o) : e;
    }, ni = e => {
      const t = e.ctrlKey && Ko() ? 10 : 1;
      return -e.deltaY * (1 === e.deltaMode ? .05 : e.deltaMode ? 1 : .002) * t;
    };
    var ri;
    e$jscomp$0.ResizeControlVariant = void 0;
    (ri = e$jscomp$0.ResizeControlVariant || (e$jscomp$0.ResizeControlVariant = {})).Line = "line";
    ri.Handle = "handle";
    const ii = ["top-left", "top-right", "bottom-left", "bottom-right"], ai = ["top", "right", "bottom", "left"], di = {width:0, height:0, x:0, y:0}, hi = {...di, pointerX:0, pointerY:0, aspectRatio:1};
    var mi, yi, vi, JSCompiler_object_inline_exports_1634 = {}, wi = {};
    var JSCompiler_object_inline_exports_1635 = {};
    var Si = {};
    JSCompiler_object_inline_exports_1634 = function() {
      if (vi) {
        return wi;
      }
      vi = 1;
      var t = Ci(), o = "function" == typeof Object.is ? Object.is : function(e, t) {
        return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t;
      }, r = t.useSyncExternalStore, i = n$jscomp$0.useRef, a = n$jscomp$0.useEffect, s = n$jscomp$0.useMemo, l = n$jscomp$0.useDebugValue;
      return wi.useSyncExternalStoreWithSelector = function(e, t, n, c, u) {
        var d = i(null);
        if (null === d.current) {
          var h = {hasValue:!1, value:null};
          d.current = h;
        } else {
          h = d.current;
        }
        d = s(function() {
          function e(e) {
            if (!a) {
              if (a = !0, r = e, e = c(e), void 0 !== u && h.hasValue) {
                var t = h.value;
                if (u(t, e)) {
                  return i = t;
                }
              }
              return i = e;
            }
            if (t = i, o(r, e)) {
              return t;
            }
            var n = c(e);
            return void 0 !== u && u(t, n) ? t : (r = e, i = n);
          }
          var r, i, a = !1, s = void 0 === n ? null : n;
          return [function() {
            return e(t());
          }, null === s ? void 0 : function() {
            return e(s());
          }];
        }, [t, n, c, u]);
        var f = r(e, d[0], d[1]);
        return a(function() {
          h.hasValue = !0;
          h.value = f;
        }, [f]), l(f), f;
      }, wi;
    }();
    var Ei = function(e) {
      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }(JSCompiler_object_inline_exports_1634);
    const ki = e => {
      let t;
      const n = new Set(), o = (e$jscomp$0, o) => {
        e$jscomp$0 = "function" == typeof e$jscomp$0 ? e$jscomp$0(t) : e$jscomp$0;
        if (!Object.is(e$jscomp$0, t)) {
          const e = t;
          t = (null != o ? o : "object" != typeof e$jscomp$0) ? e$jscomp$0 : Object.assign({}, t, e$jscomp$0);
          n.forEach(n => n(t, e));
        }
      }, r = () => t, i = {setState:o, getState:r, subscribe:e => (n.add(e), () => n.delete(e)), destroy:() => {
        console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.");
        n.clear();
      }};
      return t = e(o, r, i), i;
    }, {useSyncExternalStoreWithSelector:Mi} = Ei, _i = (e, t) => {
      const n = e ? ki(e) : ki;
      e = (e, o = t) => Ni(n, e, o);
      return Object.assign(e, n), e;
    }, Pi = n$jscomp$0.createContext(null), zi = Pi.Provider, Oi = oo.error001(), Di = {display:"none"}, Ri = {position:"absolute", width:1, height:1, margin:-1, border:0, padding:0, overflow:"hidden", clip:"rect(0px, 0px, 0px, 0px)", clipPath:"inset(100%)"}, Vi = e => e.ariaLiveMessage, Bi = e => e.ariaLabelConfig, Zi = n$jscomp$0.forwardRef(({position:e = "top-left", children:n, className:o, style:i, ...a}, s) => {
      e = `${e}`.split("-");
      return t.jsx("div", {className:r(["react-flow__panel", o, ...e]), style:i, ref:s, ...a, children:n});
    });
    Zi.displayName = "Panel";
    const Fi = e => {
      const t = [], n = [];
      for (const [, n] of e.nodeLookup) {
        n.selected && t.push(n.internals.userNode);
      }
      for (const [, t] of e.edgeLookup) {
        t.selected && n.push(t);
      }
      return {selectedNodes:t, selectedEdges:n};
    }, Wi = e => e.id, qi = e => !!e.onSelectionChangeHandlers, Qi = [0, 0], Ji = {x:0, y:0, zoom:1}, ea = "nodes edges defaultNodes defaultEdges onConnect onConnectStart onConnectEnd onClickConnectStart onClickConnectEnd nodesDraggable autoPanOnNodeFocus nodesConnectable nodesFocusable edgesFocusable edgesReconnectable elevateNodesOnSelect elevateEdgesOnSelect minZoom maxZoom nodeExtent onNodesChange onEdgesChange elementsSelectable connectionMode snapGrid snapToGrid translateExtent connectOnClick defaultEdgeOptions fitView fitViewOptions onNodesDelete onEdgesDelete onDelete onNodeDrag onNodeDragStart onNodeDragStop onSelectionDrag onSelectionDragStart onSelectionDragStop onMoveStart onMove onMoveEnd noPanClassName nodeOrigin autoPanOnConnect autoPanOnNodeDrag onError connectionRadius isValidConnection selectNodesOnDrag nodeDragThreshold connectionDragThreshold onBeforeDelete debug autoPanSpeed paneClickDistance ariaLabelConfig rfId".split(" "), 
    ta = e => ({setNodes:e.setNodes, setEdges:e.setEdges, setMinZoom:e.setMinZoom, setMaxZoom:e.setMaxZoom, setTranslateExtent:e.setTranslateExtent, setNodeExtent:e.setNodeExtent, reset:e.reset, setDefaultNodesAndEdges:e.setDefaultNodesAndEdges, setPaneClickDistance:e.setPaneClickDistance}), na = {translateExtent:ro, nodeOrigin:Qi, minZoom:.5, maxZoom:2, elementsSelectable:!0, noPanClassName:"nopan", rfId:"1", paneClickDistance:0}, ia = "undefined" != typeof document ? document : null, ca = () => 
    {
      const e = Ai();
      return n$jscomp$0.useMemo(() => ({zoomIn:t => {
        const {panZoom:n} = e.getState();
        return n ? n.scaleBy(1.2, {duration:t?.duration}) : Promise.resolve(!1);
      }, zoomOut:t => {
        const {panZoom:n} = e.getState();
        return n ? n.scaleBy(1 / 1.2, {duration:t?.duration}) : Promise.resolve(!1);
      }, zoomTo:(t, n) => {
        const {panZoom:o} = e.getState();
        return o ? o.scaleTo(t, {duration:n?.duration}) : Promise.resolve(!1);
      }, getZoom:() => e.getState().transform[2], setViewport:async(t, n) => {
        const {transform:[o, r, i], panZoom:a} = e.getState();
        return a ? (await a.setViewport({x:t.x ?? o, y:t.y ?? r, zoom:t.zoom ?? i}, n), Promise.resolve(!0)) : Promise.resolve(!1);
      }, getViewport:() => {
        const [t, n, o] = e.getState().transform;
        return {x:t, y:n, zoom:o};
      }, setCenter:async(t, n, o) => e.getState().setCenter(t, n, o), fitBounds:async(t, n) => {
        const {width:o, height:r, minZoom:i, maxZoom:a, panZoom:s} = e.getState();
        t = Wo(t, o, r, i, a, n?.padding ?? .1);
        return s ? (await s.setViewport(t, {duration:n?.duration, ease:n?.ease, interpolate:n?.interpolate}), Promise.resolve(!0)) : Promise.resolve(!1);
      }, screenToFlowPosition:(t, n = {}) => {
        const {transform:o, snapGrid:r, snapToGrid:i, domNode:a} = e.getState();
        if (!a) {
          return t;
        }
        const {x:s, y:l} = a.getBoundingClientRect();
        return Xo({x:t.x - s, y:t.y - l}, o, n.snapToGrid ?? i, n.snapGrid ?? r);
      }, flowToScreenPosition:t => {
        const {transform:n, domNode:o} = e.getState();
        if (!o) {
          return t;
        }
        const {x:r, y:i} = o.getBoundingClientRect();
        t = Yo(t, n);
        return {x:t.x + r, y:t.y + i};
      }}), []);
    }, va = e => "id" in e && "position" in e && !("source" in e) && !("target" in e), ba = "undefined" != typeof window ? n$jscomp$0.useLayoutEffect : n$jscomp$0.useEffect, Ca = n$jscomp$0.createContext(null), ka = e => !!e.panZoom, Na = e => e.selected, _a = "undefined" != typeof window ? window : void 0, Pa = {position:"absolute", width:"100%", height:"100%", top:0, left:0}, za = e => ({userSelectionActive:e.userSelectionActive, lib:e.lib, connectionInProgress:e.connection.inProgress}), Ia = e => 
    ({userSelectionActive:e.userSelectionActive, userSelectionRect:e.userSelectionRect}), Da = (e, t) => n => {
      n.target === t.current && e?.(n);
    }, Ra = e => ({userSelectionActive:e.userSelectionActive, elementsSelectable:e.elementsSelectable, connectionInProgress:e.connection.inProgress, dragging:e.paneDragging}), Va = e => t => t.selected && (t.draggable || e && void 0 === t.draggable), ja = n$jscomp$0.createContext(null), Ha = ja.Provider;
    ja.Consumer;
    const Xa = e => ({connectOnClick:e.connectOnClick, noPanClassName:e.noPanClassName, rfId:e.rfId}), Ya = n$jscomp$0.memo(n$jscomp$0.forwardRef(function({type:n = "source", position:o = e$jscomp$0.Position.Top, isValidConnection:i, isConnectable:a = !0, isConnectableStart:s = !0, isConnectableEnd:l = !0, id:c, onConnect:u, children:d, className:h, onMouseDown:f, onTouchStart:g, ...p}, m) {
      const y = c || null, v = "target" === n, x = Ai(), w = n$jscomp$0.useContext(ja), {connectOnClick:b, noPanClassName:S, rfId:C} = Ii(Xa, Yi), {connectingFrom:E, connectingTo:k, clickConnecting:M, isPossibleEndHandle:N, connectionInProcess:_, clickConnectionInProcess:P, valid:z} = Ii(((t, n, o) => r => {
        const {connectionClickStartHandle:i, connectionMode:a, connection:s} = r, {fromHandle:l, toHandle:c, isValid:u} = s;
        r = c?.nodeId === t && c?.id === n && c?.type === o;
        return {connectingFrom:l?.nodeId === t && l?.id === n && l?.type === o, connectingTo:r, clickConnecting:i?.nodeId === t && i?.id === n && i?.type === o, isPossibleEndHandle:a === e$jscomp$0.ConnectionMode.Strict ? l?.type !== o : t !== l?.nodeId || n !== l?.id, connectionInProcess:!!l, clickConnectionInProcess:!!i, valid:r && u};
      })(w, y, n), Yi);
      w || x.getState().onError?.("010", oo.error010());
      const O = e$jscomp$0 => {
        const {defaultEdgeOptions:t, onConnect:n, hasDefaultEdges:o} = x.getState();
        e$jscomp$0 = {...t, ...e$jscomp$0};
        if (o) {
          const {edges:e, setEdges:t} = x.getState();
          t(pr(e$jscomp$0, e));
        }
        n?.(e$jscomp$0);
        u?.(e$jscomp$0);
      };
      c = e => {
        if (w) {
          var t = "clientX" in e.nativeEvent;
          if (s && (t && 0 === e.button || !t)) {
            const t = x.getState();
            Kr.onPointerDown(e.nativeEvent, {handleDomNode:e.currentTarget, autoPanOnConnect:t.autoPanOnConnect, connectionMode:t.connectionMode, connectionRadius:t.connectionRadius, domNode:t.domNode, nodeLookup:t.nodeLookup, lib:t.lib, isTarget:v, handleId:y, nodeId:w, flowId:t.rfId, panBy:t.panBy, cancelConnection:t.cancelConnection, onConnectStart:t.onConnectStart, onConnectEnd:t.onConnectEnd, updateConnection:t.updateConnection, onConnect:O, isValidConnection:i || t.isValidConnection, getTransform:() => 
            x.getState().transform, getFromHandle:() => x.getState().connection.fromHandle, autoPanSpeed:t.autoPanSpeed, dragThreshold:t.connectionDragThreshold});
          }
          t ? f?.(e) : g?.(e);
        }
      };
      return t.jsx("div", {"data-handleid":y, "data-nodeid":w, "data-handlepos":o, "data-id":`${C}-${w}-${y}-${n}`, className:r(["react-flow__handle", `react-flow__handle-${o}`, "nodrag", S, h, {source:!v, target:v, connectable:a, connectablestart:s, connectableend:l, clickconnecting:M, connectingfrom:E, connectingto:k, valid:z, connectionindicator:a && (!_ || N) && (_ || P ? l : s)}]), onMouseDown:c, onTouchStart:c, onClick:b ? e => {
        const {onClickConnectStart:t, onClickConnectEnd:o, connectionClickStartHandle:r, connectionMode:a, isValidConnection:l, lib:c, rfId:u, nodeLookup:d, connection:h} = x.getState();
        if (w && (r || s)) {
          if (!r) {
            return t?.(e.nativeEvent, {nodeId:w, handleId:y, handleType:n}), void x.setState({connectionClickStartHandle:{nodeId:w, type:n, id:y}});
          }
          var f = e.target?.getRootNode?.() || window?.document, {connection:p, isValid:m} = Kr.isValid(e.nativeEvent, {handle:{nodeId:w, id:y, type:n}, connectionMode:a, fromNodeId:r.nodeId, fromHandleId:r.id || null, fromType:r.type, isValidConnection:i || l, flowId:u, doc:f, lib:c, nodeLookup:d});
          m && p && O(p);
          f = structuredClone(h);
          delete f.inProgress;
          f.toPosition = f.toHandle ? f.toHandle.position : null;
          o?.(e, f);
          x.setState({connectionClickStartHandle:null});
        }
      } : void 0, ref:m, ...p, children:d});
    })), Fa = {ArrowUp:{x:0, y:-1}, ArrowDown:{x:0, y:1}, ArrowLeft:{x:-1, y:0}, ArrowRight:{x:1, y:0}}, Wa = {input:function({data:n, isConnectable:o, sourcePosition:r = e$jscomp$0.Position.Bottom}) {
      return t.jsxs(t.Fragment, {children:[n?.label, t.jsx(Ya, {type:"source", position:r, isConnectable:o})]});
    }, default:function({data:n, isConnectable:o, targetPosition:r = e$jscomp$0.Position.Top, sourcePosition:i = e$jscomp$0.Position.Bottom}) {
      return t.jsxs(t.Fragment, {children:[t.jsx(Ya, {type:"target", position:r, isConnectable:o}), n?.label, t.jsx(Ya, {type:"source", position:i, isConnectable:o})]});
    }, output:function({data:n, isConnectable:o, targetPosition:r = e$jscomp$0.Position.Top}) {
      return t.jsxs(t.Fragment, {children:[t.jsx(Ya, {type:"target", position:r, isConnectable:o}), n?.label]});
    }, group:function() {
      return null;
    }}, Ka = e => {
      const {width:t, height:n, x:o, y:r} = Co(e.nodeLookup, {filter:e => !!e.selected});
      return {width:!isNaN(t) && isFinite(t) ? t : null, height:!isNaN(n) && isFinite(n) ? n : null, userSelectionActive:e.userSelectionActive, transformString:`translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${o}px,${r}px)`};
    }, qa = "undefined" != typeof window ? window : void 0, Ua = e => ({nodesSelectionActive:e.nodesSelectionActive, userSelectionActive:e.userSelectionActive});
    Qa.displayName = "FlowRenderer";
    const Ja = n$jscomp$0.memo(Qa), es = e => t => e ? Eo(t.nodeLookup, {x:0, y:0, width:t.width, height:t.height}, t.transform, !0).map(e => e.id) : Array.from(t.nodeLookup.keys()), ts = e => e.updateNodeInternals, os = e => ({nodesDraggable:e.nodesDraggable, nodesConnectable:e.nodesConnectable, nodesFocusable:e.nodesFocusable, elementsSelectable:e.elementsSelectable, onError:e.onError});
    rs.displayName = "NodeRenderer";
    const is = n$jscomp$0.memo(rs), as = {[e$jscomp$0.MarkerType.Arrow]:({color:e = "none", strokeWidth:n = 1}) => t.jsx("polyline", {className:"arrow", style:{strokeWidth:n, ...(e && {stroke:e})}, strokeLinecap:"round", fill:"none", strokeLinejoin:"round", points:"-5,-4 0,0 -5,4"}), [e$jscomp$0.MarkerType.ArrowClosed]:({color:e = "none", strokeWidth:n = 1}) => t.jsx("polyline", {className:"arrowclosed", style:{strokeWidth:n, ...(e && {stroke:e, fill:e})}, strokeLinecap:"round", strokeLinejoin:"round", 
    points:"-5,-4 0,0 -5,4 -5,-4"})}, ss = ({id:e, type:o, color:r, width:i = 12.5, height:a = 12.5, markerUnits:s = "strokeWidth", strokeWidth:l, orient:c = "auto-start-reverse"}) => (o = function(e) {
      const t = Ai();
      return n$jscomp$0.useMemo(() => Object.prototype.hasOwnProperty.call(as, e) ? as[e] : (t.getState().onError?.("009", oo.error009(e)), null), [e]);
    }(o)) ? t.jsx("marker", {className:"react-flow__arrowhead", id:e, markerWidth:`${i}`, markerHeight:`${a}`, viewBox:"-10 -10 20 20", markerUnits:s, orient:c, refX:"0", refY:"0", children:t.jsx(o, {color:r, strokeWidth:l})}) : null, ls = ({defaultColor:e, rfId:o}) => {
      const r = Ii(e => e.edges), i = Ii(e => e.defaultEdgeOptions), a = n$jscomp$0.useMemo(() => function(e, {id:t, defaultColor:n, defaultMarkerStart:o, defaultMarkerEnd:r}) {
        const i = new Set();
        return e.reduce((e, a) => ([a.markerStart || o, a.markerEnd || r].forEach(o => {
          if (o && "object" == typeof o) {
            const r = kr(o, t);
            i.has(r) || (e.push({id:r, color:o.color || n, ...o}), i.add(r));
          }
        }), e), []).sort((e, t) => e.id.localeCompare(t.id));
      }(r, {id:o, defaultColor:e, defaultMarkerStart:i?.markerStart, defaultMarkerEnd:i?.markerEnd}), [r, i, o, e]);
      return a.length ? t.jsx("svg", {className:"react-flow__marker", "aria-hidden":"true", children:t.jsx("defs", {children:a.map(e => t.jsx(ss, {id:e.id, type:e.type, color:e.color, width:e.width, height:e.height, markerUnits:e.markerUnits, strokeWidth:e.strokeWidth, orient:e.orient}, e.id))})}) : null;
    };
    ls.displayName = "MarkerDefinitions";
    var cs = n$jscomp$0.memo(ls);
    us.displayName = "EdgeText";
    const ds = n$jscomp$0.memo(us), ms = ps({isInternal:!1}), ys = ps({isInternal:!0});
    ms.displayName = "SimpleBezierEdge";
    ys.displayName = "SimpleBezierEdgeInternal";
    const xs = vs({isInternal:!1}), ws = vs({isInternal:!0});
    xs.displayName = "SmoothStepEdge";
    ws.displayName = "SmoothStepEdgeInternal";
    const Ss = bs({isInternal:!1}), Cs = bs({isInternal:!0});
    Ss.displayName = "StepEdge";
    Cs.displayName = "StepEdgeInternal";
    const ks = Es({isInternal:!1}), Ms = Es({isInternal:!0});
    ks.displayName = "StraightEdge";
    Ms.displayName = "StraightEdgeInternal";
    const _s = Ns({isInternal:!1}), Ps = Ns({isInternal:!0});
    _s.displayName = "BezierEdge";
    Ps.displayName = "BezierEdgeInternal";
    const zs = {default:Ps, straight:Ms, step:Cs, smoothstep:ws, simplebezier:ys}, Os = {sourceX:null, sourceY:null, targetX:null, targetY:null, sourcePosition:null, targetPosition:null}, Ts = e => ({edgesFocusable:e.edgesFocusable, edgesReconnectable:e.edgesReconnectable, elementsSelectable:e.elementsSelectable, connectionMode:e.connectionMode, onError:e.onError});
    Vs.displayName = "EdgeRenderer";
    const Bs = n$jscomp$0.memo(Vs), js = e => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`, Zs = e => e.panZoom?.syncViewport, Fs = e => ({nodesConnectable:e.nodesConnectable, isValid:e.connection.isValid, inProgress:e.connection.inProgress, width:e.width, height:e.height}), Ks = ({style:n, type:o = e$jscomp$0.ConnectionLineType.Bezier, CustomComponent:r, isValid:i}) => {
      const {inProgress:a, from:s, fromNode:l, fromHandle:c, fromPosition:u, to:d, toNode:h, toHandle:f, toPosition:g} = Ys();
      if (a) {
        if (r) {
          return t.jsx(r, {connectionLineType:o, connectionLineStyle:n, fromNode:l, fromHandle:c, fromX:s.x, fromY:s.y, toX:d.x, toY:d.y, fromPosition:u, toPosition:g, connectionStatus:null === i ? null : i ? "valid" : "invalid", toNode:h, toHandle:f});
        }
        r = "";
        r = {sourceX:s.x, sourceY:s.y, sourcePosition:u, targetX:d.x, targetY:d.y, targetPosition:g};
        switch(o) {
          case e$jscomp$0.ConnectionLineType.Bezier:
            [r] = dr(r);
            break;
          case e$jscomp$0.ConnectionLineType.SimpleBezier:
            [r] = gs(r);
            break;
          case e$jscomp$0.ConnectionLineType.Step:
            [r] = wr({...r, borderRadius:0});
            break;
          case e$jscomp$0.ConnectionLineType.SmoothStep:
            [r] = wr(r);
            break;
          default:
            [r] = mr(r);
        }
        return t.jsx("path", {d:r, fill:"none", className:"react-flow__connection-path", style:n});
      }
    };
    Ks.displayName = "ConnectionLine";
    const Gs = {};
    Us.displayName = "GraphView";
    const Qs = n$jscomp$0.memo(Us), Js = ({nodes:t, edges:n, defaultNodes:o, defaultEdges:r, width:i, height:a, fitView:s, fitViewOptions:l, minZoom:c = .5, maxZoom:u = 2, nodeOrigin:d, nodeExtent:h} = {}) => {
      const f = new Map(), g = new Map(), p = new Map(), m = new Map();
      n = r ?? n ?? [];
      t = o ?? t ?? [];
      d = d ?? [0, 0];
      h = h ?? ro;
      Lr(p, m, n);
      const b = Or(t, f, g, {nodeOrigin:d, nodeExtent:h, elevateNodesOnSelect:!1});
      var S = [0, 0, 1];
      if (s && i && a) {
        S = Co(f, {filter:e => !(!e.width && !e.initialWidth || !e.height && !e.initialHeight)});
        const {x:t, y:n, zoom:o} = Wo(S, i, a, c, u, l?.padding ?? .1);
        S = [t, n, o];
      }
      return {rfId:"1", width:i ?? 0, height:a ?? 0, transform:S, nodes:t, nodesInitialized:b, nodeLookup:f, parentLookup:g, edges:n, edgeLookup:m, connectionLookup:p, onNodesChange:null, onEdgesChange:null, hasDefaultNodes:void 0 !== o, hasDefaultEdges:void 0 !== r, panZoom:null, minZoom:c, maxZoom:u, translateExtent:ro, nodeExtent:h, nodesSelectionActive:!1, userSelectionActive:!1, userSelectionRect:null, connectionMode:e$jscomp$0.ConnectionMode.Strict, domNode:null, paneDragging:!1, noPanClassName:"nopan", 
      nodeOrigin:d, nodeDragThreshold:1, connectionDragThreshold:1, snapGrid:[15, 15], snapToGrid:!1, nodesDraggable:!0, nodesConnectable:!0, nodesFocusable:!0, edgesFocusable:!0, edgesReconnectable:!0, elementsSelectable:!0, elevateNodesOnSelect:!0, elevateEdgesOnSelect:!1, selectNodesOnDrag:!0, multiSelectionActive:!1, fitViewQueued:s ?? !1, fitViewOptions:l, fitViewResolver:null, connection:{...uo}, connectionClickStartHandle:null, connectOnClick:!0, ariaLiveMessage:"", autoPanOnConnect:!0, autoPanOnNodeDrag:!0, 
      autoPanOnNodeFocus:!0, autoPanSpeed:15, connectionRadius:20, onError:Ho, isValidConnection:void 0, onSelectionChangeHandlers:[], lib:"react", debug:!1, ariaLabelConfig:ao};
    }, el = ({nodes:e, edges:t, defaultNodes:n, defaultEdges:o, width:r, height:i, fitView:a, fitViewOptions:s, minZoom:l, maxZoom:c, nodeOrigin:u, nodeExtent:d}) => {
      var f, h;
      return h = (h, f) => {
        async function g() {
          const {nodeLookup:e, panZoom:t, fitViewOptions:n, fitViewResolver:o, width:r, height:i, minZoom:a, maxZoom:s} = f();
          t && (await Mo({nodes:e, width:r, height:i, panZoom:t, minZoom:a, maxZoom:s}, n), o?.resolve(!0), h({fitViewResolver:null}));
        }
        return {...Js({nodes:e, edges:t, width:r, height:i, fitView:a, fitViewOptions:s, minZoom:l, maxZoom:c, nodeOrigin:u, nodeExtent:d, defaultNodes:n, defaultEdges:o}), setNodes:e => {
          const {nodeLookup:t, parentLookup:n, nodeOrigin:o, elevateNodesOnSelect:r, fitViewQueued:i} = f(), a = Or(e, t, n, {nodeOrigin:o, nodeExtent:d, elevateNodesOnSelect:r, checkEquality:!0});
          i && a ? (g(), h({nodes:e, nodesInitialized:a, fitViewQueued:!1, fitViewOptions:void 0})) : h({nodes:e, nodesInitialized:a});
        }, setEdges:e => {
          const {connectionLookup:t, edgeLookup:n} = f();
          Lr(t, n, e);
          h({edges:e});
        }, setDefaultNodesAndEdges:(e, t) => {
          if (e) {
            const {setNodes:t} = f();
            t(e);
            h({hasDefaultNodes:!0});
          }
          t && ({setEdges:e} = f(), e(t), h({hasDefaultEdges:!0}));
        }, updateNodeInternals:e => {
          const {triggerNodeChanges:t, nodeLookup:n, parentLookup:o, domNode:r, nodeOrigin:i, nodeExtent:a, debug:s, fitViewQueued:l} = f(), {changes:c, updatedInternals:u} = function(e, t, n, o$jscomp$0, r, i) {
            var a$jscomp$0 = o$jscomp$0?.querySelector(".xyflow__viewport"), s = !1;
            if (!a$jscomp$0) {
              return {changes:[], updatedInternals:s};
            }
            o$jscomp$0 = [];
            a$jscomp$0 = window.getComputedStyle(a$jscomp$0);
            ({m22:a$jscomp$0} = new window.DOMMatrixReadOnly(a$jscomp$0.transform));
            const d = [];
            for (const o of e.values()) {
              e = t.get(o.id);
              if (!e) {
                continue;
              }
              if (e.hidden) {
                t.set(e.id, {...e, internals:{...e.internals, handleBounds:void 0}});
                s = !0;
                continue;
              }
              const a = tr(o.nodeElement), c = e.measured.width !== a.width || e.measured.height !== a.height;
              if (a.width && a.height && (c || !e.internals.handleBounds || o.force)) {
                s = o.nodeElement.getBoundingClientRect();
                var f = Go(e.extent) ? e.extent : i;
                let {positionAbsolute:g} = e.internals;
                e.parentId && "parent" === e.extent ? g = zo(g, a, t.get(e.parentId)) : f && (g = Po(g, f, a));
                f = {...e, measured:a, internals:{...e.internals, positionAbsolute:g, handleBounds:{source:sr("source", o.nodeElement, s, a$jscomp$0, e.id), target:sr("target", o.nodeElement, s, a$jscomp$0, e.id)}}};
                t.set(e.id, f);
                e.parentId && Ir(f, t, n, {nodeOrigin:r});
                s = !0;
                c && (o$jscomp$0.push({id:e.id, type:"dimensions", dimensions:a}), e.expandParent && e.parentId && d.push({id:e.id, parentId:e.parentId, rect:Lo(f, r)}));
              }
            }
            0 < d.length && (t = Dr(d, t, n, r), o$jscomp$0.push(...t));
            return {changes:o$jscomp$0, updatedInternals:s};
          }(e, n, o, r, i, a);
          u && (function(e$jscomp$0, t, n$jscomp$0) {
            n$jscomp$0 = Pr(Nr, n$jscomp$0);
            for (const n of e$jscomp$0.values()) {
              if (n.parentId) {
                Ir(n, e$jscomp$0, t, n$jscomp$0);
              } else {
                var e = bo(n, n$jscomp$0.nodeOrigin);
                const t = Go(n.extent) ? n.extent : n$jscomp$0.nodeExtent;
                e = Po(e, t, qo(n));
                n.internals.positionAbsolute = e;
              }
            }
          }(n, o, {nodeOrigin:i, nodeExtent:a}), l ? (g(), h({fitViewQueued:!1, fitViewOptions:void 0})) : h({}), 0 < c?.length && (s && console.log("React Flow: trigger node changes", c), t?.(c)));
        }, updateNodePositions:(e, t$jscomp$0 = !1) => {
          const n = [], o = [], {nodeLookup:r, triggerNodeChanges:i} = f();
          for (const [i, a] of e) {
            e = r.get(i);
            const s = !!(e?.expandParent && e?.parentId && a?.position), l = {id:i, type:"position", position:s ? {x:Math.max(0, a.position.x), y:Math.max(0, a.position.y)} : a.position, dragging:t$jscomp$0};
            s && e.parentId && n.push({id:i, parentId:e.parentId, rect:{...a.internals.positionAbsolute, width:a.measured.width ?? 0, height:a.measured.height ?? 0}});
            o.push(l);
          }
          if (0 < n.length) {
            const {parentLookup:e, nodeOrigin:t} = f();
            t$jscomp$0 = Dr(n, r, e, t);
            o.push(...t$jscomp$0);
          }
          i(o);
        }, triggerNodeChanges:e => {
          const {onNodesChange:t, setNodes:n, nodes:o, hasDefaultNodes:r, debug:i} = f();
          e?.length && (r && n(ua(e, o)), i && console.log("React Flow: trigger node changes", e), t?.(e));
        }, triggerEdgeChanges:e => {
          const {onEdgesChange:t, setEdges:n, edges:o, hasDefaultEdges:r, debug:i} = f();
          e?.length && (r && n(ua(e, o)), i && console.log("React Flow: trigger edge changes", e), t?.(e));
        }, addSelectedNodes:e => {
          const {multiSelectionActive:t, edgeLookup:n, nodeLookup:o, triggerNodeChanges:r, triggerEdgeChanges:i} = f();
          t ? r(e.map(e => ga(e, !0))) : (r(pa(o, new Set([...e]), !0)), i(pa(n)));
        }, addSelectedEdges:e => {
          const {multiSelectionActive:t, edgeLookup:n, nodeLookup:o, triggerNodeChanges:r, triggerEdgeChanges:i} = f();
          t ? i(e.map(e => ga(e, !0))) : (i(pa(n, new Set([...e]))), r(pa(o, new Set(), !0)));
        }, unselectNodesAndEdges:({nodes:e, edges:t} = {}) => {
          const {edges:n, nodes:o, nodeLookup:r, triggerNodeChanges:i, triggerEdgeChanges:a} = f();
          t = t || n;
          e = (e || o).map(e => {
            const t = r.get(e.id);
            return t && (t.selected = !1), ga(e.id, !1);
          });
          t = t.map(e => ga(e.id, !1));
          i(e);
          a(t);
        }, setMinZoom:e => {
          const {panZoom:t, maxZoom:n} = f();
          t?.setScaleExtent([e, n]);
          h({minZoom:e});
        }, setMaxZoom:e => {
          const {panZoom:t, minZoom:n} = f();
          t?.setScaleExtent([n, e]);
          h({maxZoom:e});
        }, setTranslateExtent:e => {
          f().panZoom?.setTranslateExtent(e);
          h({translateExtent:e});
        }, setPaneClickDistance:e => {
          f().panZoom?.setClickDistance(e);
        }, resetSelectedElements:() => {
          const {edges:e, nodes:t, triggerNodeChanges:n, triggerEdgeChanges:o, elementsSelectable:r} = f();
          if (r) {
            var i = t.reduce((e, t) => t.selected ? [...e, ga(t.id, !1)] : e, []), a = e.reduce((e, t) => t.selected ? [...e, ga(t.id, !1)] : e, []);
            n(i);
            o(a);
          }
        }, setNodeExtent:e => {
          const {nodes:t, nodeLookup:n, parentLookup:o, nodeOrigin:r, elevateNodesOnSelect:i, nodeExtent:a} = f();
          e[0][0] === a[0][0] && e[0][1] === a[0][1] && e[1][0] === a[1][0] && e[1][1] === a[1][1] || (Or(t, n, o, {nodeOrigin:r, nodeExtent:e, elevateNodesOnSelect:i, checkEquality:!1}), h({nodeExtent:e}));
        }, panBy:e => {
          const {transform:t, width:n, height:o, panZoom:r, translateExtent:i} = f();
          return async function({delta:e, panZoom:t, transform:n, translateExtent:o, width:r, height:i}) {
            if (!t || !e.x && !e.y) {
              return Promise.resolve(!1);
            }
            e = await t.setViewportConstrained({x:n[0] + e.x, y:n[1] + e.y, zoom:n[2]}, [[0, 0], [r, i]], o);
            return Promise.resolve(!!e && (e.x !== n[0] || e.y !== n[1] || e.k !== n[2]));
          }({delta:e, panZoom:r, transform:t, translateExtent:i, width:n, height:o});
        }, setCenter:async(e, t, n) => {
          const {width:o, height:r, maxZoom:i, panZoom:a} = f();
          if (!a) {
            return Promise.resolve(!1);
          }
          const s = void 0 !== n?.zoom ? n.zoom : i;
          return await a.setViewport({x:o / 2 - e * s, y:r / 2 - t * s, zoom:s}, {duration:n?.duration, ease:n?.ease, interpolate:n?.interpolate}), Promise.resolve(!0);
        }, cancelConnection:() => {
          h({connection:{...uo}});
        }, updateConnection:e => {
          h({connection:e});
        }, reset:() => h({...Js()})};
      }, f = Object.is, h ? _i(h, f) : _i;
    }, ol = {width:"100%", height:"100%", overflow:"hidden", position:"relative", zIndex:0};
    var rl = n$jscomp$0.forwardRef(function({nodes:o, edges:i, defaultNodes:a, defaultEdges:s, className:l, nodeTypes:c, edgeTypes:u, onNodeClick:d, onEdgeClick:h, onInit:f, onMove:g, onMoveStart:p, onMoveEnd:m, onConnect:y, onConnectStart:v, onConnectEnd:x, onClickConnectStart:w, onClickConnectEnd:b, onNodeMouseEnter:S, onNodeMouseMove:C, onNodeMouseLeave:E, onNodeContextMenu:k, onNodeDoubleClick:M, onNodeDragStart:N, onNodeDrag:_, onNodeDragStop:P, onNodesDelete:z, onEdgesDelete:O, onDelete:I, 
    onSelectionChange:A, onSelectionDragStart:D, onSelectionDrag:R, onSelectionDragStop:L, onSelectionContextMenu:$, onSelectionStart:T, onSelectionEnd:V, onBeforeDelete:B, connectionMode:j, connectionLineType:H = e$jscomp$0.ConnectionLineType.Bezier, connectionLineStyle:Z, connectionLineComponent:X, connectionLineContainerStyle:Y, deleteKeyCode:F = "Backspace", selectionKeyCode:W = "Shift", selectionOnDrag:K = !1, selectionMode:G = e$jscomp$0.SelectionMode.Full, panActivationKeyCode:q = "Space", 
    multiSelectionKeyCode:U = Ko() ? "Meta" : "Control", zoomActivationKeyCode:Q = Ko() ? "Meta" : "Control", snapToGrid:J, snapGrid:ee, onlyRenderVisibleElements:te = !1, selectNodesOnDrag:ne, nodesDraggable:oe, autoPanOnNodeFocus:re, nodesConnectable:ie, nodesFocusable:ae, nodeOrigin:se = Qi, edgesFocusable:le, edgesReconnectable:ce, elementsSelectable:ue = !0, defaultViewport:de = Ji, minZoom:he = .5, maxZoom:fe = 2, translateExtent:ge = ro, preventScrolling:pe = !0, nodeExtent:me, defaultMarkerColor:ye = 
    "#b1b1b7", zoomOnScroll:ve = !0, zoomOnPinch:xe = !0, panOnScroll:we = !1, panOnScrollSpeed:be = .5, panOnScrollMode:Se = e$jscomp$0.PanOnScrollMode.Free, zoomOnDoubleClick:Ce = !0, panOnDrag:Ee = !0, onPaneClick:ke, onPaneMouseEnter:Me, onPaneMouseMove:Ne, onPaneMouseLeave:_e, onPaneScroll:Pe, onPaneContextMenu:ze, paneClickDistance:Oe = 0, nodeClickDistance:Ie = 0, children:Ae, onReconnect:De, onReconnectStart:Re, onReconnectEnd:Le, onEdgeContextMenu:$e, onEdgeDoubleClick:Te, onEdgeMouseEnter:Ve, 
    onEdgeMouseMove:Be, onEdgeMouseLeave:je, reconnectRadius:He = 10, onNodesChange:Ze, onEdgesChange:Xe, noDragClassName:Ye = "nodrag", noWheelClassName:Fe = "nowheel", noPanClassName:We = "nopan", fitView:Ke, fitViewOptions:Ge, connectOnClick:qe, attributionPosition:Ue, proOptions:Qe, defaultEdgeOptions:Je, elevateNodesOnSelect:et, elevateEdgesOnSelect:tt, disableKeyboardA11y:nt = !1, autoPanOnConnect:ot, autoPanOnNodeDrag:rt, autoPanSpeed:it, connectionRadius:at, isValidConnection:st, onError:lt, 
    style:ct, id:ut, nodeDragThreshold:dt, connectionDragThreshold:ht, viewport:ft, onViewportChange:gt, width:pt, height:mt, colorMode:yt = "light", debug:vt, onScroll:xt, ariaLabelConfig:wt, ...bt}, St) {
      const Ct = ut || "1", Et = function(e) {
        const [t, o] = n$jscomp$0.useState("system" === e ? null : e);
        return n$jscomp$0.useEffect(() => {
          if ("system" !== e) {
            return void o(e);
          }
          const t = ra(), n = () => o(t?.matches ? "dark" : "light");
          return n(), t?.addEventListener("change", n), () => {
            t?.removeEventListener("change", n);
          };
        }, [e]), null !== t ? t : ra()?.matches ? "dark" : "light";
      }(yt), kt = n$jscomp$0.useCallback(e => {
        e.currentTarget.scrollTo({top:0, left:0, behavior:"instant"});
        xt?.(e);
      }, [xt]);
      return t.jsx("div", {"data-testid":"rf__wrapper", ...bt, onScroll:kt, style:{...ct, ...ol}, ref:St, className:r(["react-flow", l, Et]), id:ut, role:"application", children:t.jsxs(nl, {nodes:o, edges:i, width:pt, height:mt, fitView:Ke, fitViewOptions:Ge, minZoom:he, maxZoom:fe, nodeOrigin:se, nodeExtent:me, children:[t.jsx(Qs, {onInit:f, onNodeClick:d, onEdgeClick:h, onNodeMouseEnter:S, onNodeMouseMove:C, onNodeMouseLeave:E, onNodeContextMenu:k, onNodeDoubleClick:M, nodeTypes:c, edgeTypes:u, 
      connectionLineType:H, connectionLineStyle:Z, connectionLineComponent:X, connectionLineContainerStyle:Y, selectionKeyCode:W, selectionOnDrag:K, selectionMode:G, deleteKeyCode:F, multiSelectionKeyCode:U, panActivationKeyCode:q, zoomActivationKeyCode:Q, onlyRenderVisibleElements:te, defaultViewport:de, translateExtent:ge, minZoom:he, maxZoom:fe, preventScrolling:pe, zoomOnScroll:ve, zoomOnPinch:xe, zoomOnDoubleClick:Ce, panOnScroll:we, panOnScrollSpeed:be, panOnScrollMode:Se, panOnDrag:Ee, onPaneClick:ke, 
      onPaneMouseEnter:Me, onPaneMouseMove:Ne, onPaneMouseLeave:_e, onPaneScroll:Pe, onPaneContextMenu:ze, paneClickDistance:Oe, nodeClickDistance:Ie, onSelectionContextMenu:$, onSelectionStart:T, onSelectionEnd:V, onReconnect:De, onReconnectStart:Re, onReconnectEnd:Le, onEdgeContextMenu:$e, onEdgeDoubleClick:Te, onEdgeMouseEnter:Ve, onEdgeMouseMove:Be, onEdgeMouseLeave:je, reconnectRadius:He, defaultMarkerColor:ye, noDragClassName:Ye, noWheelClassName:Fe, noPanClassName:We, rfId:Ct, disableKeyboardA11y:nt, 
      nodeExtent:me, viewport:ft, onViewportChange:gt}), t.jsx(oa, {nodes:o, edges:i, defaultNodes:a, defaultEdges:s, onConnect:y, onConnectStart:v, onConnectEnd:x, onClickConnectStart:w, onClickConnectEnd:b, nodesDraggable:oe, autoPanOnNodeFocus:re, nodesConnectable:ie, nodesFocusable:ae, edgesFocusable:le, edgesReconnectable:ce, elementsSelectable:ue, elevateNodesOnSelect:et, elevateEdgesOnSelect:tt, minZoom:he, maxZoom:fe, nodeExtent:me, onNodesChange:Ze, onEdgesChange:Xe, snapToGrid:J, snapGrid:ee, 
      connectionMode:j, translateExtent:ge, connectOnClick:qe, defaultEdgeOptions:Je, fitView:Ke, fitViewOptions:Ge, onNodesDelete:z, onEdgesDelete:O, onDelete:I, onNodeDragStart:N, onNodeDrag:_, onNodeDragStop:P, onSelectionDrag:R, onSelectionDragStart:D, onSelectionDragStop:L, onMove:g, onMoveStart:p, onMoveEnd:m, noPanClassName:We, nodeOrigin:se, rfId:Ct, autoPanOnConnect:ot, autoPanOnNodeDrag:rt, autoPanSpeed:it, onError:lt, connectionRadius:at, isValidConnection:st, selectNodesOnDrag:ne, nodeDragThreshold:dt, 
      connectionDragThreshold:ht, onBeforeDelete:B, paneClickDistance:Oe, debug:vt, ariaLabelConfig:wt}), t.jsx(Ui, {onSelectionChange:A}), Ae, t.jsx(Xi, {proOptions:Qe, position:Ue}), t.jsx(Hi, {rfId:Ct, disableKeyboardA11y:nt})]})});
    });
    const il = e => e.domNode?.querySelector(".react-flow__edgelabel-renderer"), al = e => e.domNode?.querySelector(".react-flow__viewport-portal"), sl = e => e.nodes, ll = e => e.edges, cl = e => ({x:e.transform[0], y:e.transform[1], zoom:e.transform[2]}), ul = oo.error014();
    var fl;
    e$jscomp$0.BackgroundVariant = void 0;
    (fl = e$jscomp$0.BackgroundVariant || (e$jscomp$0.BackgroundVariant = {})).Lines = "lines";
    fl.Dots = "dots";
    fl.Cross = "cross";
    const gl = {[e$jscomp$0.BackgroundVariant.Dots]:1, [e$jscomp$0.BackgroundVariant.Lines]:1, [e$jscomp$0.BackgroundVariant.Cross]:6}, pl = e => ({transform:e.transform, patternId:`pattern-${e.rfId}`});
    ml.displayName = "Background";
    const yl = n$jscomp$0.memo(ml), El = e => ({isInteractive:e.nodesDraggable || e.nodesConnectable || e.elementsSelectable, minZoomReached:e.transform[2] <= e.minZoom, maxZoomReached:e.transform[2] >= e.maxZoom, ariaLabelConfig:e.ariaLabelConfig});
    kl.displayName = "Controls";
    const Ml = n$jscomp$0.memo(kl), Nl = n$jscomp$0.memo(function({id:e, x:n, y:o, width:i, height:a, style:s, color:l, strokeColor:c, strokeWidth:u, className:d, borderRadius:h, shapeRendering:f, selected:g, onClick:p}) {
      const {background:m, backgroundColor:y} = s || {};
      s = l || m || y;
      return t.jsx("rect", {className:r(["react-flow__minimap-node", {selected:g}, d]), x:n, y:o, rx:h, ry:h, width:i, height:a, style:{fill:s, stroke:c, strokeWidth:u}, shapeRendering:f, onClick:p ? t => p(t, e) : void 0});
    }), _l = e => e.nodes.map(e => e.id), Pl = e => e instanceof Function ? e : () => e, zl = n$jscomp$0.memo(function({id:e, nodeColorFunc:n, nodeStrokeColorFunc:o, nodeClassNameFunc:r, nodeBorderRadius:i, nodeStrokeWidth:a, shapeRendering:s, NodeComponent:l, onClick:c}) {
      const {node:u, x:d, y:h, width:f, height:g} = Ii(t => {
        ({internals:t} = t.nodeLookup.get(e));
        const o = t.userNode, {x:r, y:i} = t.positionAbsolute, {width:a, height:s} = qo(o);
        return {node:o, x:r, y:i, width:a, height:s};
      }, Yi);
      return u && !u.hidden && Uo(u) ? t.jsx(l, {x:d, y:h, width:f, height:g, style:u.style, selected:!!u.selected, className:r(u), color:n(u), borderRadius:i, strokeColor:o(u), strokeWidth:a, shapeRendering:s, onClick:c, id:u.id}) : null;
    });
    var Ol = n$jscomp$0.memo(function({nodeStrokeColor:e, nodeColor:n, nodeClassName:o = "", nodeBorderRadius:r = 5, nodeStrokeWidth:i, nodeComponent:a = Nl, onClick:s}) {
      const l = Ii(_l, Yi), c = Pl(n), u = Pl(e), d = Pl(o), h = "undefined" == typeof window || window.chrome ? "crispEdges" : "geometricPrecision";
      return t.jsx(t.Fragment, {children:l.map(e => t.jsx(zl, {id:e, nodeColorFunc:c, nodeStrokeColorFunc:u, nodeClassNameFunc:d, nodeBorderRadius:r, nodeStrokeWidth:i, NodeComponent:a, onClick:s, shapeRendering:h}, e))});
    });
    const Il = e => !e.hidden, Al = e => {
      const t = {x:-e.transform[0] / e.transform[2], y:-e.transform[1] / e.transform[2], width:e.width / e.transform[2], height:e.height / e.transform[2]};
      return {viewBB:t, boundingRect:0 < e.nodeLookup.size ? To(Co(e.nodeLookup, {filter:Il}), t) : t, rfId:e.rfId, panZoom:e.panZoom, translateExtent:e.translateExtent, flowWidth:e.width, flowHeight:e.height, ariaLabelConfig:e.ariaLabelConfig};
    };
    Dl.displayName = "MiniMap";
    const Rl = n$jscomp$0.memo(Dl), Ll = {[e$jscomp$0.ResizeControlVariant.Line]:"right", [e$jscomp$0.ResizeControlVariant.Handle]:"bottom-right"}, $l = n$jscomp$0.memo(function({nodeId:o, position:i, variant:a = e$jscomp$0.ResizeControlVariant.Handle, className:s, style:l, children:c, color:u, minWidth:d = 10, minHeight:h = 10, maxWidth:f = Number.MAX_VALUE, maxHeight:g = Number.MAX_VALUE, keepAspectRatio:p = !1, resizeDirection:m, autoScale:y = !0, shouldResize:v, onResizeStart:x, onResize:w, onResizeEnd:b}) {
      var S = n$jscomp$0.useContext(ja);
      const C = "string" == typeof o ? o : S, E = Ai(), k = n$jscomp$0.useRef(null);
      o = a === e$jscomp$0.ResizeControlVariant.Handle;
      S = Ii(n$jscomp$0.useCallback((_ = o && y, e => _ ? `${Math.max(1 / e.transform[2], 1)}` : void 0), [o, y]), Yi);
      var _;
      const P = n$jscomp$0.useRef(null), z = i ?? Ll[a];
      n$jscomp$0.useEffect(() => {
        if (k.current && C) {
          return P.current || (P.current = gi({domNode:k.current, nodeId:C, getStoreItems:() => {
            const {nodeLookup:e, transform:t, snapGrid:n, snapToGrid:o, nodeOrigin:r, domNode:i} = E.getState();
            return {nodeLookup:e, transform:t, snapGrid:n, snapToGrid:o, nodeOrigin:r, paneDomNode:i};
          }, onChange:(e, t) => {
            const {triggerNodeChanges:n, nodeLookup:o, parentLookup:r, nodeOrigin:i} = E.getState(), a = [], s = {x:e.x, y:e.y};
            var l = o.get(C);
            if (l && l.expandParent && l.parentId) {
              const t = l.origin ?? i, n = e.width ?? l.measured.width ?? 0, c = e.height ?? l.measured.height ?? 0;
              l = Dr([{id:l.id, parentId:l.parentId, rect:{width:n, height:c, ...Qo({x:e.x ?? l.position.x, y:e.y ?? l.position.y}, {width:n, height:c}, l.parentId, o, t)}}], o, r, i);
              a.push(...l);
              s.x = e.x ? Math.max(t[0] * n, e.x) : void 0;
              s.y = e.y ? Math.max(t[1] * c, e.y) : void 0;
            }
            void 0 !== s.x && void 0 !== s.y && a.push({id:C, type:"position", position:{...s}});
            void 0 !== e.width && void 0 !== e.height && a.push({id:C, type:"dimensions", resizing:!0, setAttributes:!m || ("horizontal" === m ? "width" : "height"), dimensions:{width:e.width, height:e.height}});
            for (const e of t) {
              a.push({...e, type:"position"});
            }
            n(a);
          }, onEnd:({width:e, height:t}) => {
            e = {id:C, type:"dimensions", resizing:!1, dimensions:{width:e, height:t}};
            E.getState().triggerNodeChanges([e]);
          }})), P.current.update({controlPosition:z, boundaries:{minWidth:d, minHeight:h, maxWidth:f, maxHeight:g}, keepAspectRatio:p, resizeDirection:m, onResizeStart:x, onResize:w, onResizeEnd:b, shouldResize:v}), () => {
            P.current?.destroy();
          };
        }
      }, [z, d, h, f, g, p, x, w, b, v]);
      i = z.split("-");
      return t.jsx("div", {className:r(["react-flow__resize-control", "nodrag", ...i, a, s]), ref:k, style:{...l, scale:S, ...(u && {[o ? "backgroundColor" : "borderColor"]:u})}, children:c});
    }), Tl = e => e.domNode?.querySelector(".react-flow__renderer"), jl = (e, t$jscomp$0) => {
      if (e.size !== t$jscomp$0.size) {
        return !1;
      }
      for (const [n, o] of e) {
        e = o;
        var t = t$jscomp$0.get(n);
        if (e?.internals.positionAbsolute.x !== t?.internals.positionAbsolute.x || e?.internals.positionAbsolute.y !== t?.internals.positionAbsolute.y || e?.measured.width !== t?.measured.width || e?.measured.height !== t?.measured.height || e?.selected !== t?.selected || e?.internals.z !== t?.internals.z) {
          return !1;
        }
      }
      return !0;
    }, Hl = e => ({x:e.transform[0], y:e.transform[1], zoom:e.transform[2], selectedNodesCount:e.nodes.filter(e => e.selected).length});
    e$jscomp$0.Background = yl;
    e$jscomp$0.BaseEdge = hs;
    e$jscomp$0.BezierEdge = _s;
    e$jscomp$0.ControlButton = Cl;
    e$jscomp$0.Controls = Ml;
    e$jscomp$0.EdgeLabelRenderer = function({children:e}) {
      const t = Ii(il);
      return t ? o.createPortal(e, t) : null;
    };
    e$jscomp$0.EdgeText = ds;
    e$jscomp$0.Handle = Ya;
    e$jscomp$0.MiniMap = Rl;
    e$jscomp$0.MiniMapNode = Nl;
    e$jscomp$0.NodeResizeControl = $l;
    e$jscomp$0.NodeResizer = function({nodeId:n, isVisible:o = !0, handleClassName:r, handleStyle:i, lineClassName:a, lineStyle:s, color:l, minWidth:c = 10, minHeight:u = 10, maxWidth:d = Number.MAX_VALUE, maxHeight:h = Number.MAX_VALUE, keepAspectRatio:f = !1, autoScale:g = !0, shouldResize:p, onResizeStart:m, onResize:y, onResizeEnd:v}) {
      return o ? t.jsxs(t.Fragment, {children:[ai.map(o => t.jsx($l, {className:a, style:s, nodeId:n, position:o, variant:e$jscomp$0.ResizeControlVariant.Line, color:l, minWidth:c, minHeight:u, maxWidth:d, maxHeight:h, onResizeStart:m, keepAspectRatio:f, autoScale:g, shouldResize:p, onResize:y, onResizeEnd:v}, o)), ii.map(e => t.jsx($l, {className:r, style:i, nodeId:n, position:e, color:l, minWidth:c, minHeight:u, maxWidth:d, maxHeight:h, onResizeStart:m, keepAspectRatio:f, autoScale:g, shouldResize:p, 
      onResize:y, onResizeEnd:v}, e))]}) : null;
    };
    e$jscomp$0.NodeToolbar = function({nodeId:o, children:i, className:a, style:s, isVisible:l, position:c = e$jscomp$0.Position.Top, offset:u = 10, align:d = "center", ...h}) {
      const f = n$jscomp$0.useContext(ja);
      var g = n$jscomp$0.useCallback(e => (Array.isArray(o) ? o : [o || f || ""]).reduce((t, n) => {
        n = e.nodeLookup.get(n);
        return n && t.set(n.id, n), t;
      }, new Map()), [o, f]);
      g = Ii(g, jl);
      const {x:m, y, zoom:v, selectedNodesCount:x} = Ii(Hl, Yi);
      if (("boolean" == typeof l ? !l : 1 !== g.size || !g.values().next().value?.selected || 1 !== x) || !g.size) {
        return null;
      }
      l = Co(g);
      g = Array.from(g.values());
      const S = Math.max(...g.map(e => e.internals.z + 1));
      s = {position:"absolute", transform:Mr(l, {x:m, y, zoom:v}, c, u, d), zIndex:S, ...s};
      return t.jsx(Vl, {children:t.jsx("div", {style:s, className:r(["react-flow__node-toolbar", a]), ...h, "data-id":g.reduce((e, t) => `${e}${t.id} `, "").trim(), children:i})});
    };
    e$jscomp$0.Panel = Zi;
    e$jscomp$0.ReactFlow = rl;
    e$jscomp$0.ReactFlowProvider = tl;
    e$jscomp$0.SimpleBezierEdge = ms;
    e$jscomp$0.SmoothStepEdge = xs;
    e$jscomp$0.StepEdge = Ss;
    e$jscomp$0.StraightEdge = ks;
    e$jscomp$0.ViewportPortal = function({children:e}) {
      const t = Ii(al);
      return t ? o.createPortal(e, t) : null;
    };
    e$jscomp$0.addEdge = pr;
    e$jscomp$0.applyEdgeChanges = function(e, t) {
      return ua(e, t);
    };
    e$jscomp$0.applyNodeChanges = function(e, t) {
      return ua(e, t);
    };
    e$jscomp$0.getBezierEdgeCenter = lr;
    e$jscomp$0.getBezierPath = dr;
    e$jscomp$0.getConnectedEdges = ko;
    e$jscomp$0.getEdgeCenter = hr;
    e$jscomp$0.getIncomers = (e, t, n) => {
      if (!e.id) {
        return [];
      }
      const o = new Set();
      return n.forEach(t => {
        t.target === e.id && o.add(t.source);
      }), t.filter(e => o.has(e.id));
    };
    e$jscomp$0.getNodesBounds = So;
    e$jscomp$0.getOutgoers = (e, t, n) => {
      if (!e.id) {
        return [];
      }
      const o = new Set();
      return n.forEach(t => {
        t.source === e.id && o.add(t.target);
      }), t.filter(e => o.has(e.id));
    };
    e$jscomp$0.getSimpleBezierPath = gs;
    e$jscomp$0.getSmoothStepPath = wr;
    e$jscomp$0.getStraightPath = mr;
    e$jscomp$0.getViewportForBounds = Wo;
    e$jscomp$0.isEdge = e => xo(e);
    e$jscomp$0.isNode = va;
    e$jscomp$0.reconnectEdge = (e, t, n, o = {shouldReplaceId:!0}) => {
      const {id:r, ...i} = e;
      if (!t.source || !t.target || !n.find(t => t.id === e.id)) {
        return n;
      }
      t = {...i, id:o.shouldReplaceId ? gr(t) : r, source:t.source, target:t.target, sourceHandle:t.sourceHandle, targetHandle:t.targetHandle};
      return n.filter(e => e.id !== r).concat(t);
    };
    e$jscomp$0.useConnection = Ys;
    e$jscomp$0.useEdges = function() {
      return Ii(ll, Yi);
    };
    e$jscomp$0.useEdgesState = function(e) {
      const [t, o] = n$jscomp$0.useState(e);
      e = n$jscomp$0.useCallback(e => o(t => ua(e, t)), []);
      return [t, o, e];
    };
    e$jscomp$0.useHandleConnections = function({type:e, id:t, nodeId:o, onConnect:r, onDisconnect:i}) {
      console.warn("[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections");
      const a = n$jscomp$0.useContext(ja), s = o ?? a, l = n$jscomp$0.useRef(null), c = Ii(n => n.connectionLookup.get(`${s}-${e}${t ? `-${t}` : ""}`), mo);
      return n$jscomp$0.useEffect(() => {
        if (l.current && l.current !== c) {
          const e = c ?? new Map();
          yo(l.current, e, i);
          yo(e, l.current, r);
        }
        l.current = c ?? new Map();
      }, [c, r, i]), n$jscomp$0.useMemo(() => Array.from(c?.values() ?? []), [c]);
    };
    e$jscomp$0.useInternalNode = function(e) {
      return Ii(n$jscomp$0.useCallback(t => t.nodeLookup.get(e), [e]), Yi);
    };
    e$jscomp$0.useKeyPress = aa;
    e$jscomp$0.useNodeConnections = function({id:e, handleType:t, handleId:o, onConnect:r, onDisconnect:i} = {}) {
      const a = n$jscomp$0.useContext(ja), s = e ?? a;
      if (!s) {
        throw Error(ul);
      }
      const l = n$jscomp$0.useRef(null), c = Ii(e => e.connectionLookup.get(`${s}${t ? o ? `-${t}-${o}` : `-${t}` : ""}`), mo);
      return n$jscomp$0.useEffect(() => {
        if (l.current && l.current !== c) {
          const e = c ?? new Map();
          yo(l.current, e, i);
          yo(e, l.current, r);
        }
        l.current = c ?? new Map();
      }, [c, r, i]), n$jscomp$0.useMemo(() => Array.from(c?.values() ?? []), [c]);
    };
    e$jscomp$0.useNodeId = () => n$jscomp$0.useContext(ja);
    e$jscomp$0.useNodes = function() {
      return Ii(sl, Yi);
    };
    e$jscomp$0.useNodesData = function(e) {
      return Ii(n$jscomp$0.useCallback(t => {
        const n = [], o = Array.isArray(e);
        var r = o ? e : [e];
        for (const e of r) {
          (r = t.nodeLookup.get(e)) && n.push({id:r.id, type:r.type, data:r.data});
        }
        return o ? n : n[0] ?? null;
      }, [e]), $r);
    };
    e$jscomp$0.useNodesInitialized = function(e = {includeHiddenNodes:!1}) {
      return Ii((e => t => {
        if (!e.includeHiddenNodes) {
          return t.nodesInitialized;
        }
        if (0 === t.nodeLookup.size) {
          return !1;
        }
        for (const [, {internals:e}] of t.nodeLookup) {
          if (void 0 === e.handleBounds || !Uo(e.userNode)) {
            return !1;
          }
        }
        return !0;
      })(e));
    };
    e$jscomp$0.useNodesState = function(e) {
      const [t, o] = n$jscomp$0.useState(e);
      e = n$jscomp$0.useCallback(e => o(t => ua(e, t)), []);
      return [t, o, e];
    };
    e$jscomp$0.useOnSelectionChange = function({onChange:e}) {
      const t = Ai();
      n$jscomp$0.useEffect(() => {
        const n = [...t.getState().onSelectionChangeHandlers, e];
        return t.setState({onSelectionChangeHandlers:n}), () => {
          const n = t.getState().onSelectionChangeHandlers.filter(t => t !== e);
          t.setState({onSelectionChangeHandlers:n});
        };
      }, [e]);
    };
    e$jscomp$0.useOnViewportChange = function({onStart:e, onChange:t, onEnd:o}) {
      const r = Ai();
      n$jscomp$0.useEffect(() => {
        r.setState({onViewportChangeStart:e});
      }, [e]);
      n$jscomp$0.useEffect(() => {
        r.setState({onViewportChange:t});
      }, [t]);
      n$jscomp$0.useEffect(() => {
        r.setState({onViewportChangeEnd:o});
      }, [o]);
    };
    e$jscomp$0.useReactFlow = Ma;
    e$jscomp$0.useStore = Ii;
    e$jscomp$0.useStoreApi = Ai;
    e$jscomp$0.useUpdateNodeInternals = function() {
      const e = Ai();
      return n$jscomp$0.useCallback(t => {
        const {domNode:n, updateNodeInternals:o} = e.getState();
        t = Array.isArray(t) ? t : [t];
        const i = new Map();
        t.forEach(e => {
          const t = n?.querySelector(`.react-flow__node[data-id="${e}"]`);
          t && i.set(e, {id:e, nodeElement:t, force:!0});
        });
        requestAnimationFrame(() => o(i, {triggerFitView:!1}));
      }, []);
    };
    e$jscomp$0.useViewport = function() {
      return Ii(cl, Yi);
    };
  });
};

//# sourceMappingURL=module$node_modules$$xyflow$react$dist$umd$index.js.map
