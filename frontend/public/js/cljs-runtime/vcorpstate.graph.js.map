{"version":3,"sources":["vcorpstate/graph.cljs"],"mappings":"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","names":["vcorpstate.graph/squad-columns","vcorpstate.graph/node-colors","vcorpstate.graph/create-collection-lookup-maps","squad-jobs","collection-to-producer","cljs.core.into","iter__5480__auto__","s__14914","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","xs__6360__auto__","cljs.core/first","iterys__5476__auto__","s__14916","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","cljs.core/count","b__14918","cljs.core/chunk-buffer","i__14917","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__14915","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","fs__5477__auto__","cljs.core.concat","iter__14913","job","output-slug","cljs.core.map","collection-to-consumers","cljs.core.reduce","acc","acc2","input-slug","cljs.core.update","cljs.core.fnil","cljs.core/conj","vcorpstate.graph/find-first-jobs-in-column","all-jobs-by-squad","is-first-column?","all-outputs-by-any-job","cljs.core/set","cljs.core.mapcat","jobs","p1__14919#","cljs.core/vals","cljs.core.filter","input-slugs","cljs.core/not-any?","cljs.core/some","vcorpstate.graph/build-simple-tree-chain","first-jobs","lookup-maps","map__14923","cljs.core/--destructure-map","cljs.core.get","build-chain","visited","cljs.core/contains?","visited'","cljs.core.conj","outputs","next-jobs","p1__14920#","p1__14921#","build-chain-fn","cljs.core.distinct","p1__14922#","vcorpstate.graph/position-workflow-chain","job-chain","column-x","y-start","y-step","idx","base-y","input-collections","output-collections","cljs.core.map_indexed","i-idx","o-idx","cljs.core.range","vcorpstate.graph/get-squad-x-position","squad-slug","p1__14924#","cljs.core._EQ_","or__5002__auto__","vcorpstate.graph/collection-status","collection","documents","collection-docs","p1__14925#","total","completed","p1__14926#","vcorpstate.graph/job-visual-status","vcorpstate.graph/build-collection-node","squads","y-offset","status","color","vcorpstate.graph/build-job-node","roles","position","role","visual-status","cljs.core.keyword","cljs.core/name","vcorpstate.graph/build-simple-column","cljs.core/not-empty","workflow-nodes","job-nodes","p1__14927#","collection-nodes","p1__14928#","result","p1__14929#","vcorpstate.graph/build-graph-data","collections","and__5000__auto__","js/console.log","jobs-by-squad","cljs.core/group-by","role-key","_","cljs.core/clj->js","column-results","p__14930","map__14931","slug","x","is-first?","cljs.core.remove","cljs.core/nil?","all-job-nodes","all-collection-nodes","react-flow-jobs","p__14932","map__14933","react-flow-collections","p__14934","map__14935","id","all-nodes","all-edges","cljs.core/chunk-first"],"sourcesContent":["(ns vcorpstate.graph\n  \"Graph builder functions - pure functions that build React Flow nodes from state\"\n  (:require [clojure.set]))\n\n;; ====================================\n;; LAYOUT CONSTANTS\n;; ====================================\n\n(def squad-columns\n  \"Squad column layout - 7 independent vertical columns\"\n  [{:slug \"human\" :name \"Human Director\" :x 100}\n   {:slug \"pd\" :name \"Product Designer\" :x 250}\n   {:slug \"arch\" :name \"Architect\" :x 400} \n   {:slug \"fe\" :name \"FE Squad\" :x 550}\n   {:slug \"be\" :name \"BE Squad\" :x 700}\n   {:slug \"ai\" :name \"AI Squad\" :x 850}\n   {:slug \"qa\" :name \"QA Squad\" :x 1000}])\n\n(def node-colors\n  {:collection-input \"#3B82F6\"    ; Blue - input collections\n   :collection-output \"#10B981\"   ; Green - output collections  \n   :job \"#F59E0B\"                 ; Orange - jobs/processing\n   :job-completed \"#059669\"       ; Dark green - completed jobs\n   :job-paused \"#6B7280\"})        ; Gray - paused jobs\n\n;; ====================================\n;; SIMPLE TREE BUILDING ALGORITHM  \n;; ====================================\n\n;; Simple lookup maps for navigation\n(defn create-collection-lookup-maps\n  \"Create maps for easy navigation: collection \u2192 producer job, collection \u2192 consumer jobs\"\n  [squad-jobs]\n  (let [collection-to-producer (into {}\n                                    (for [job squad-jobs\n                                          output-slug (map :slug (:outputs job))]\n                                      [output-slug job]))\n        collection-to-consumers (reduce (fn [acc job]\n                                         (reduce (fn [acc2 input-slug]\n                                                  (update acc2 input-slug (fnil conj []) job))\n                                                acc (map :slug (:inputs job))))\n                                       {} squad-jobs)]\n    {:collection-to-producer collection-to-producer\n     :collection-to-consumers collection-to-consumers}))\n\n;; Simple first job detection (the key algorithm!)\n(defn find-first-jobs-in-column\n  \"Find the beginning jobs using the simple rule\"\n  [squad-jobs all-jobs-by-squad is-first-column?]\n  (let [;; Get all outputs produced by ANY job (for first column detection)\n        all-outputs-by-any-job (set (mapcat (fn [jobs] (mapcat #(map :slug (:outputs %)) jobs))\n                                           (vals all-jobs-by-squad)))]\n    (if is-first-column?\n      ;; Column 1: jobs whose inputs are NOT outputs of any other job\n      (filter (fn [job]\n               (let [input-slugs (map :slug (:inputs job))]\n                 (not-any? all-outputs-by-any-job input-slugs)))\n             squad-jobs)\n      ;; Other columns: jobs whose inputs ARE outputs from ANY other column\n      (filter (fn [job]\n               (let [input-slugs (set (map :slug (:inputs job)))]\n                 (some all-outputs-by-any-job input-slugs)))\n             squad-jobs))))\n\n;; Simple tree building by following the chain\n(defn build-simple-tree-chain\n  \"Build tree by following job \u2192 outputs \u2192 consuming jobs chain\"\n  [first-jobs lookup-maps]\n  (let [{:keys [collection-to-consumers]} lookup-maps\n        build-chain (fn build-chain-fn [job visited]\n                     (if (contains? visited (:id job))\n                       [] ; Avoid cycles\n                       (let [visited' (conj visited (:id job))\n                             outputs (map :slug (:outputs job))\n                             next-jobs (mapcat #(get collection-to-consumers % []) outputs)]\n                         (cons job (mapcat #(build-chain-fn % visited') next-jobs)))))]\n    (distinct (mapcat #(build-chain % #{}) first-jobs))))\n\n;; Position jobs and collections in workflow order\n(defn position-workflow-chain\n  \"Position jobs and collections in proper workflow order: input \u2192 job \u2192 output\"\n  [job-chain column-x]\n  (let [y-start 50\n        y-step 80]\n    (mapcat (fn [idx job]\n              (let [base-y (+ y-start (* idx y-step 3))  ; Space for input \u2192 job \u2192 output\n                    input-collections (map :slug (:inputs job))\n                    output-collections (map :slug (:outputs job))]\n                (concat\n                  ;; Input collections first\n                  (map-indexed (fn [i-idx input-slug]\n                                {:type :collection\n                                 :id (str \"collection-\" input-slug)\n                                 :position {:x column-x :y (+ base-y (* i-idx 25))}\n                                 :slug input-slug})\n                              input-collections)\n                  ;; Job in the middle\n                  [{:type :job\n                    :job job\n                    :position {:x column-x :y (+ base-y y-step)}}]\n                  ;; Output collections last  \n                  (map-indexed (fn [o-idx output-slug]\n                                {:type :collection\n                                 :id (str \"collection-\" output-slug) \n                                 :position {:x column-x :y (+ base-y (* 2 y-step) (* o-idx 25))}\n                                 :slug output-slug})\n                              output-collections))))\n            (range (count job-chain)) job-chain)))\n\n;; ====================================\n;; HELPER FUNCTIONS\n;; ====================================\n\n(defn get-squad-x-position\n  \"Get X position for a squad column\"\n  [squad-slug]\n  (-> (filter #(= (:slug %) squad-slug) squad-columns)\n      first\n      :x\n      (or 600))) ; Default fallback\n\n(defn collection-status\n  \"Calculate collection status based on documents\"\n  [collection documents]\n  (let [collection-docs (filter #(= (:document_collection_id %) (:id collection)) (vals documents))\n        total (count collection-docs)\n        completed (count (filter #(= (:status %) \"done\") collection-docs))]\n    (if (zero? total)\n      :empty\n      (if (= completed total)\n        :completed\n        :in-progress))))\n\n(defn job-visual-status\n  \"Get visual status for job (affects color)\"\n  [job]\n  (cond\n    (:completed job) :completed\n    (:paused job) :paused\n    :else :running))\n\n;; ====================================\n;; NODE BUILDERS\n;; ====================================\n\n(defn build-collection-node\n  \"Create a React Flow node for a document collection\"\n  [collection documents squads y-offset]\n  (let [status (collection-status collection documents)\n        color (if (= status :completed) \n                (:collection-output node-colors)\n                (:collection-input node-colors))]\n    {:id (str \"collection-\" (:id collection))\n     :type \"default\"\n     :position {:x 50 :y y-offset}\n     :data {:label (:name collection)\n            :description (:description collection)\n            :type :collection\n            :collection-id (:id collection)\n            :slug (:slug collection)\n            :status status}\n     :style {:backgroundColor color\n             :color \"white\"\n             :border \"none\"\n             :borderRadius \"6px\"\n             :padding \"8px 12px\"\n             :fontSize \"12px\"\n             :fontWeight \"500\"}}))\n\n(defn build-job-node\n  \"Create a React Flow node for a job - new simplified version\"\n  [job roles squads position]\n  (let [role (get roles (:role job))\n        squad-slug (or (:squad_slug role) \"arch\")\n        visual-status (job-visual-status job)\n        color (get node-colors (keyword (str \"job-\" (name visual-status))) (:job node-colors))]\n    {:id (str \"job-\" (:id job))\n     :type \"default\"\n     :position position\n     :data {:label (:name job)\n            :description (:description job)\n            :type :job\n            :job-id (:id job)\n            :role (:role job)\n            :slug (:slug job)\n            :squad squad-slug\n            :status visual-status}\n     :style {:backgroundColor color\n             :color \"white\"\n             :border \"none\"\n             :borderRadius \"6px\"\n             :padding \"8px 12px\"\n             :fontSize \"12px\"\n             :fontWeight \"500\"}}))\n\n\n;; ====================================\n;; SIMPLE COLUMN BUILDER\n;; ====================================\n\n(defn build-simple-column\n  \"Build column using the simple chain algorithm\"\n  [squad-slug squad-jobs all-jobs-by-squad column-x is-first-column?]\n  (when (not-empty squad-jobs)\n    (let [;; 1. Find first jobs using the simple rule\n          first-jobs (find-first-jobs-in-column squad-jobs all-jobs-by-squad is-first-column?)\n          ;; 2. Create lookup maps for navigation\n          lookup-maps (create-collection-lookup-maps squad-jobs)\n          \n          ;; 3. Build chain by following job \u2192 outputs \u2192 consuming jobs\n          job-chain (build-simple-tree-chain first-jobs lookup-maps)\n          \n          ;; 4. Position jobs and collections in workflow order: input \u2192 job \u2192 output  \n          workflow-nodes (position-workflow-chain job-chain column-x)\n          \n          ;; 5. Separate jobs and collections\n          job-nodes (filter #(= (:type %) :job) workflow-nodes)\n          collection-nodes (filter #(= (:type %) :collection) workflow-nodes)\n          \n          result {:job-nodes job-nodes\n                  :collection-nodes collection-nodes\n                  :job-chain job-chain\n                  :output-slugs (set (mapcat #(map :slug (:outputs %)) job-chain))}]\n      \n      result)))\n\n(defn build-graph-data\n  \"Build React Flow graph using simple column algorithm\"\n  [collections documents jobs squads roles]\n  (when (and collections jobs)\n    (js/console.log \"=== BUILD GRAPH DEBUG ===\")\n    (js/console.log \"Total jobs:\" (count (vals jobs)))\n    (js/console.log \"Total collections:\" (count (vals collections)))\n    (let [;; Group jobs by squad (simple)\n          jobs-by-squad (group-by (fn [job] \n                                   (let [role-key (:role job)\n                                         role (get roles role-key)]\n                                     (or (:squad_slug role) \"unknown\"))) \n                                 (vals jobs))\n          ;; Build each column independently (no need to pass outputs between them)\n          _ (js/console.log \"Jobs grouped by squad:\" (clj->js jobs-by-squad))\n          column-results (map (fn [{:keys [slug x]}]\n                               (let [is-first? (= slug \"human\")  ; First column\n                                     squad-jobs (get jobs-by-squad slug [])]\n                                 (js/console.log \"Building column\" slug \"with\" (count squad-jobs) \"jobs at x=\" x)\n                                 (build-simple-column slug squad-jobs jobs-by-squad x is-first?)))\n                             squad-columns)\n          _ (js/console.log \"Column results:\" (clj->js (remove nil? column-results)))\n          \n          ;; Combine all nodes\n          all-job-nodes (mapcat :job-nodes (remove nil? column-results))\n          all-collection-nodes (mapcat :collection-nodes (remove nil? column-results))\n          \n          ;; Convert to React Flow format\n          react-flow-jobs (map-indexed (fn [idx {:keys [job position]}]\n                                (js/console.log \"Job\" (:slug job) \"at position\" position)\n                                {:id (str \"job-\" (:id job))\n                                 :type \"default\"\n                                 :position (clj->js position)  ; Convert ClojureScript to JavaScript!\n                                 :data {:label (:name job) :type :job}\n                                 :style {:backgroundColor \"#f59e0b\" :color \"white\" \n                                        :border \"none\" :borderRadius \"6px\"\n                                        :padding \"8px 12px\" :fontSize \"12px\"}})\n                              all-job-nodes)\n          react-flow-collections (map (fn [{:keys [id position slug]}]\n                                       (js/console.log \"Collection\" slug \"at position\" position)\n                                       {:id id :position (clj->js position) :data {:label slug}\n                                        :style {:fontSize \"11px\" :color \"#666\"}}) \n                                     all-collection-nodes)\n          \n          all-nodes (concat react-flow-jobs react-flow-collections)\n          all-edges []] ; Simple for now - no edges\n      \n      {:nodes all-nodes\n       :edges all-edges})))"]}