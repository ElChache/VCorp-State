{"version":3,"sources":["vcorpstate/events/data.cljs"],"mappings":"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","names":["re_frame.core.reg_event_fx","p__13689","p__13690","map__13691","cljs.core/--destructure-map","cljs.core.get","vec__13692","cljs.core.nth","db","_","project-id","cljs.core/assoc-in","p__13695","vec__13696","vcorpstate.http/load-project-initial-data","p__13699","p__13700","map__13701","vec__13702","data","map__13705","collections","documents","jobs","squads","roles","timestamp","collections-by-id","cljs.core.into","cljs.core.map","c","documents-by-id","d","documents-by-slug","jobs-by-id","j","jobs-by-slug","squads-by-id","s","roles-by-short-name","r","updated-db","vcorpstate.events.data/build-job-dependency-tree","available-jobs","current-level-outputs","next-level-jobs","cljs.core.filter","job","input-slugs","cljs.core/set","clojure.set/subset?","cljs.core/empty?","remaining-jobs","cljs.core.remove","next-level-outputs","p1__13706#","cljs.core.mapcat","vcorpstate.events.data/compute-squad-columns","all-jobs","cljs.core/vec","get-squad-from-role","role-name","cljs.core.get_in","jobs-by-squad","p1__13707#","cljs.core/group-by","squad-dependency-trees","p__13711","vec__13712","squad","squad-jobs","squad-outputs","p1__13708#","root-jobs","clojure.set.intersection","root-outputs","p1__13709#","dependency-tree","root-job","p1__13710#","cljs.core/filterv","cljs.core/not-empty","cljs.core.mapv","p__13715","vec__13716","re_frame.core.reg_event_db","cljs.core/vals","graph-structure","p__13719","vec__13720","_error","p__13723","vec__13724","event","map__13727","document_id","new_status","p__13728","vec__13729","map__13732","job_id","completed","paused","p__13733","vec__13734","map__13737","collection_id","total","p__13738","vec__13739","map__13742","document"],"sourcesContent":["(ns vcorpstate.events.data\n  \"Data loading and real-time update events\"\n  (:require [re-frame.core :as rf]\n            [clojure.set :as set]\n            [vcorpstate.http :as http]))\n\n;; ====================================\n;; PROJECT DATA LOADING\n;; ====================================\n\n;; Load all project data when project is accessed\n(rf/reg-event-fx\n :data/load-project\n (fn [{:keys [db]} [_ project-id]]\n   {:db (assoc-in db [:app :loading?] true)\n    :dispatch-later [{:ms 100 :dispatch [:data/fetch-project project-id]}]}))\n\n;; HTTP call to fetch project data\n(rf/reg-event-fx\n :data/fetch-project\n (fn [_ [_ project-id]]\n   (http/load-project-initial-data project-id)\n   {}))\n\n;; Handle successful project data load\n(rf/reg-event-fx\n :data/project-loaded\n (fn [{:keys [db]} [_ data]]\n    (let [{:keys [collections documents jobs squads roles timestamp]} data\n         ;; Normalize data by ID for fast lookups\n         collections-by-id (into {} (map (fn [c] [(:id c) c])) collections)\n         documents-by-id (into {} (map (fn [d] [(:id d) d])) documents)\n         documents-by-slug (into {} (map (fn [d] [(:slug d) d])) documents) \n         jobs-by-id (into {} (map (fn [j] [(:id j) j])) jobs)\n         jobs-by-slug (into {} (map (fn [j] [(:slug j) j])) jobs)\n         squads-by-id (into {} (map (fn [s] [(:id s) s])) squads)\n         roles-by-short-name (into {} (map (fn [r] [(:short_name r) r])) roles)\n         updated-db (-> db\n                       (assoc-in [:data :collections] collections-by-id)\n                       (assoc-in [:data :documents] documents-by-id)\n                       (assoc-in [:data :documents-by-slug] documents-by-slug)\n                       (assoc-in [:data :jobs] jobs-by-id)\n                       (assoc-in [:data :jobs-by-slug] jobs-by-slug)\n                       (assoc-in [:data :squads] squads-by-id)\n                       (assoc-in [:data :roles] roles-by-short-name)\n                       (assoc-in [:app :loading?] false)\n                       (assoc-in [:data :last-updated] timestamp))]\n     {:db updated-db\n      :dispatch [:data/compute-graph-structure]})))\n\n(defn build-job-dependency-tree\n  \"Recursively builds a nested dependency tree for jobs within a squad.\n   \n   Args:\n     available-jobs - Vector of remaining jobs to process\n     current-level-outputs - Set of output slugs from current level\n   \n   Returns:\n     Map of job-slug -> nested-dependencies\"\n  [available-jobs current-level-outputs]\n  (let [;; Find jobs whose inputs are satisfied by current level outputs\n        next-level-jobs (filter (fn [job]\n                                 (let [input-slugs (set (map :slug (:inputs job)))]\n                                   (set/subset? input-slugs current-level-outputs)))\n                               available-jobs)]\n    (if (empty? next-level-jobs)\n      {}\n      (let [;; Remove processed jobs from available jobs\n            remaining-jobs (remove (set next-level-jobs) available-jobs)\n            ;; Get all outputs from this level\n            next-level-outputs (set (mapcat #(map :slug (:outputs %)) next-level-jobs))]\n        ;; Build nested structure: job-slug -> recursive dependencies\n        (into {}\n              (map (fn [job]\n                     [(:slug job) \n                      (build-job-dependency-tree remaining-jobs next-level-outputs)])\n                   next-level-jobs))))))\n\n(defn compute-squad-columns \n  \"Computes squad columns with nested job dependency trees for graph visualization.\n   \n   Each squad column shows the complete dependency flow from root jobs down through\n   all levels, where each level contains jobs whose inputs are satisfied by the\n   previous level's outputs within the same squad.\n   \n   Args:\n     jobs - Collection of job maps with :role, :inputs, :outputs, :id\n     roles - Map of role-name -> role data (including :squad_slug)\n   \n   Returns:\n     Vector of {:squad squad-name :jobs {job-slug {nested-deps...}}} maps\"\n  [jobs roles]\n  (let [all-jobs (vec jobs)\n        ;; Helper to get squad from role\n        get-squad-from-role (fn [role-name]\n                             (get-in roles [role-name :squad_slug]))\n        \n        ;; Group jobs by squad\n        jobs-by-squad (group-by #(get-squad-from-role (:role %)) all-jobs)\n        \n        ;; For each squad, build the complete dependency tree\n        squad-dependency-trees (into {} \n                                    (map (fn [[squad squad-jobs]]\n                                          (let [squad-outputs (set (mapcat #(map :slug (:outputs %)) squad-jobs))\n                                                ;; Find root jobs (inputs from outside squad)\n                                                root-jobs (filter (fn [job]\n                                                                  (let [input-slugs (set (map :slug (:inputs job)))]\n                                                                    (empty? (set/intersection input-slugs squad-outputs))))\n                                                                squad-jobs)\n                                                ;; Get outputs from root jobs to start dependency chain\n                                                root-outputs (set (mapcat #(map :slug (:outputs %)) root-jobs))\n                                                ;; Remaining jobs to process (excluding roots)\n                                                remaining-jobs (remove (set root-jobs) squad-jobs)\n                                                ;; Build nested dependency tree starting from roots\n                                                dependency-tree (into {}\n                                                                     (map (fn [root-job]\n                                                                           [(:slug root-job)\n                                                                            (build-job-dependency-tree remaining-jobs root-outputs)])\n                                                                          root-jobs))]\n                                            [squad dependency-tree]))\n                                        jobs-by-squad))]\n    \n    ;; Convert to expected format and remove empty squads\n    (filterv #(not-empty (:jobs %))\n             (mapv (fn [[squad dependency-tree]]\n                     {:squad squad :jobs dependency-tree})\n                   squad-dependency-trees))))\n\n;; Compute graph structure from jobs data\n(rf/reg-event-db\n :data/compute-graph-structure\n (fn [db _]\n   (let [jobs (vals (get-in db [:data :jobs]))\n         roles (get-in db [:data :roles])\n         graph-structure (compute-squad-columns jobs roles)]\n     (assoc-in db [:data :graph_structure] graph-structure))))\n\n;; Handle failed project data load\n(rf/reg-event-db\n :data/project-failed\n (fn [db [_ _error]]\n   (-> db\n       (assoc-in [:app :loading?] false)\n       (assoc-in [:app :error] \"Failed to load project data\"))))\n\n;; ====================================\n;; REAL-TIME DATA UPDATES\n;; ====================================\n\n;; Handle document status changes\n(rf/reg-event-db\n :data/document-status-changed\n (fn [db [_ event]]\n   (let [{:keys [document_id new_status]} event]\n     (assoc-in db [:data :documents document_id :status] new_status))))\n\n;; Handle job status changes\n(rf/reg-event-db\n :data/job-status-changed\n (fn [db [_ event]]\n   (let [{:keys [job_id completed paused]} event]\n     (-> db\n         (assoc-in [:data :jobs job_id :completed] completed)\n         (assoc-in [:data :jobs job_id :paused] paused)))))\n\n;; Handle collection progress updates\n(rf/reg-event-db\n :data/collection-progress-updated\n (fn [db [_ event]]\n   (let [{:keys [collection_id completed total]} event]\n     (assoc-in db [:data :collections collection_id :progress] \n               {:completed completed :total total}))))\n\n;; Handle new document creation\n(rf/reg-event-db\n :data/document-created\n (fn [db [_ event]]\n   (let [{:keys [document]} event]\n     (assoc-in db [:data :documents (:id document)] document))))"]}