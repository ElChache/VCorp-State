shadow$provide.module$node_modules$$headlessui$react$dist$headlessui_dev_cjs = function(global, require, module, exports) {
  function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
    const ref = (0,import_react2.useRef)(null);
    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
      ref.current = fn;
    }, [fn]);
    return (0,import_react2.useCallback)((...args) => {
      const f = ref.current;
      return null === f || void 0 === f ? void 0 : f(...args);
    }, []);
  }
  function $c87311424ea30a05$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    return "undefined" === typeof window || null == window.navigator ? !1 : (null === (_window_navigator_userAgentData = window.navigator.userAgentData) || void 0 === _window_navigator_userAgentData ? void 0 : _window_navigator_userAgentData.brands.some(brand => re.test(brand.brand))) || re.test(window.navigator.userAgent);
  }
  function $c87311424ea30a05$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return "undefined" !== typeof window && null != window.navigator ? re.test((null === (_window_navigator_userAgentData = window.navigator.userAgentData) || void 0 === _window_navigator_userAgentData ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : !1;
  }
  function $c87311424ea30a05$var$cached(fn) {
    let res = null;
    return () => {
      null == res && (res = fn());
      return res;
    };
  }
  function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
    let globalListeners = (0,import_react3.useRef)(new Map()), addGlobalListener = (0,import_react3.useCallback)((eventTarget, type, listener, options) => {
      let fn = (null === options || void 0 === options ? 0 : options.once) ? (...args) => {
        globalListeners.current.delete(listener);
        listener(...args);
      } : listener;
      globalListeners.current.set(listener, {type, eventTarget, fn, options});
      eventTarget.addEventListener(type, fn, options);
    }, []), removeGlobalListener = (0,import_react3.useCallback)((eventTarget, type, listener, options) => {
      var _globalListeners_current_get;
      let fn = (null === (_globalListeners_current_get = globalListeners.current.get(listener)) || void 0 === _globalListeners_current_get ? void 0 : _globalListeners_current_get.fn) || listener;
      eventTarget.removeEventListener(type, fn, options);
      globalListeners.current.delete(listener);
    }, []), removeAllGlobalListeners = (0,import_react3.useCallback)(() => {
      globalListeners.current.forEach((value, key) => {
        removeGlobalListener(value.eventTarget, value.type, key, value.options);
      });
    }, [removeGlobalListener]);
    (0,import_react3.useEffect)(() => removeAllGlobalListeners, [removeAllGlobalListeners]);
    return {addGlobalListener, removeGlobalListener, removeAllGlobalListeners};
  }
  function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
    nativeEvent.nativeEvent = nativeEvent;
    nativeEvent.isDefaultPrevented = () => nativeEvent.defaultPrevented;
    nativeEvent.isPropagationStopped = () => nativeEvent.cancelBubble;
    nativeEvent.persist = () => {
    };
    return nativeEvent;
  }
  function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
    let stateRef = (0,import_react4.useRef)({isFocused:!1, observer:null});
    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
      const state = stateRef.current;
      return () => {
        state.observer && (state.observer.disconnect(), state.observer = null);
      };
    }, []);
    let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52(e => {
      null === onBlur || void 0 === onBlur || onBlur(e);
    });
    return (0,import_react4.useCallback)(e => {
      if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
        stateRef.current.isFocused = !0;
        let target = e.target;
        target.addEventListener("focusout", e2 => {
          stateRef.current.isFocused = !1;
          target.disabled && (e2 = $8a9cb279dc87e130$export$525bc4921d56d4a(e2), dispatchBlur(e2));
          stateRef.current.observer && (stateRef.current.observer.disconnect(), stateRef.current.observer = null);
        }, {once:!0});
        stateRef.current.observer = new MutationObserver(() => {
          if (stateRef.current.isFocused && target.disabled) {
            var _stateRef_current_observer;
            null === (_stateRef_current_observer = stateRef.current.observer) || void 0 === _stateRef_current_observer || _stateRef_current_observer.disconnect();
            _stateRef_current_observer = target === document.activeElement ? null : document.activeElement;
            target.dispatchEvent(new FocusEvent("blur", {relatedTarget:_stateRef_current_observer}));
            target.dispatchEvent(new FocusEvent("focusout", {bubbles:!0, relatedTarget:_stateRef_current_observer}));
          }
        });
        stateRef.current.observer.observe(target, {attributes:!0, attributeFilter:["disabled"]});
      }
    }, [dispatchBlur]);
  }
  function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {
    for (let handler of $507fabe10e71c6fb$var$changeHandlers) {
      handler(modality, e);
    }
  }
  function $507fabe10e71c6fb$var$handleKeyboardEvent(e) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0;
    e.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e.altKey || e.ctrlKey || "Control" === e.key || "Shift" === e.key || "Meta" === e.key || ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e));
  }
  function $507fabe10e71c6fb$var$handlePointerEvent(e) {
    $507fabe10e71c6fb$var$currentModality = "pointer";
    if ("mousedown" === e.type || "pointerdown" === e.type) {
      $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e);
    }
  }
  function $507fabe10e71c6fb$var$handleClickEvent(e) {
    e = 0 === e.mozInputSource && e.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && e.pointerType ? "click" === e.type && 1 === e.buttons : 0 === e.detail && !e.pointerType;
    e && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
  }
  function $507fabe10e71c6fb$var$handleFocusEvent(e) {
    e.target !== window && e.target !== document && (0, !0) && e.isTrusted && ($507fabe10e71c6fb$var$hasEventBeforeFocus || $507fabe10e71c6fb$var$hasBlurredWindowRecently || ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e)), $507fabe10e71c6fb$var$hasBlurredWindowRecently = $507fabe10e71c6fb$var$hasEventBeforeFocus = !1);
  }
  function $507fabe10e71c6fb$var$handleWindowBlur() {
    0;
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !1;
    $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
  }
  function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
    if ("undefined" !== typeof window && !$507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) {
      var windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element), documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element), focus = windowObject.HTMLElement.prototype.focus;
      windowObject.HTMLElement.prototype.focus = function() {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = !0;
        focus.apply(this, arguments);
      };
      documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0);
      documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0);
      documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0);
      windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0);
      windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1);
      "undefined" !== typeof PointerEvent && (documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0));
      windowObject.addEventListener("beforeunload", () => {
        $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
      }, {once:!0});
      $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {focus});
    }
  }
  function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
    const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
    let loadListener;
    "loading" !== documentObject.readyState ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) : (loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    }, documentObject.addEventListener("DOMContentLoaded", loadListener));
    return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
  }
  function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents();
    (0,import_react5.useEffect)(() => {
      let handler = (modality, e) => {
        var isTextInput = !(null === opts || void 0 === opts || !opts.isTextInput);
        let document1 = $431fbd86ca7dc216$export$b204af158042fbac(null === e || void 0 === e ? void 0 : e.target);
        const IHTMLInputElement = "undefined" !== typeof window ? $431fbd86ca7dc216$export$f21a1ffae260145a(null === e || void 0 === e ? void 0 : e.target).HTMLInputElement : HTMLInputElement, IHTMLTextAreaElement = "undefined" !== typeof window ? $431fbd86ca7dc216$export$f21a1ffae260145a(null === e || void 0 === e ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement, IHTMLElement = "undefined" !== typeof window ? $431fbd86ca7dc216$export$f21a1ffae260145a(null === e || void 0 === e ? void 0 : 
        e.target).HTMLElement : HTMLElement, IKeyboardEvent = "undefined" !== typeof window ? $431fbd86ca7dc216$export$f21a1ffae260145a(null === e || void 0 === e ? void 0 : e.target).KeyboardEvent : KeyboardEvent;
        (isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable) && "keyboard" === modality && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key] || fn("pointer" !== $507fabe10e71c6fb$var$currentModality);
      };
      $507fabe10e71c6fb$var$changeHandlers.add(handler);
      return () => {
        $507fabe10e71c6fb$var$changeHandlers.delete(handler);
      };
    }, deps);
  }
  function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
    let {isDisabled, onFocus:onFocusProp, onBlur:onBlurProp, onFocusChange} = props;
    props = (0,import_react6.useCallback)(e => {
      if (e.target === e.currentTarget) {
        return onBlurProp && onBlurProp(e), onFocusChange && onFocusChange(!1), !0;
      }
    }, [onBlurProp, onFocusChange]);
    const onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(props), onFocus = (0,import_react6.useCallback)(e => {
      var ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e.target);
      ownerDocument = ownerDocument ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
      e.target === e.currentTarget && ownerDocument === e.nativeEvent.target && (onFocusProp && onFocusProp(e), onFocusChange && onFocusChange(!0), onSyntheticFocus(e));
    }, [onFocusChange, onFocusProp, onSyntheticFocus]);
    return {focusProps:{onFocus:!isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0, onBlur:isDisabled || !onBlurProp && !onFocusChange ? void 0 : props}};
  }
  function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
    let {isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange} = props, state = (0,import_react7.useRef)({isFocusWithin:!1}), {addGlobalListener, removeAllGlobalListeners} = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), onBlur = (0,import_react7.useCallback)(e => {
      e.currentTarget.contains(e.target) && state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget) && (state.current.isFocusWithin = !1, removeAllGlobalListeners(), onBlurWithin && onBlurWithin(e), onFocusWithinChange && onFocusWithinChange(!1));
    }, [onBlurWithin, onFocusWithinChange, state, removeAllGlobalListeners]), onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
    props = (0,import_react7.useCallback)(e => {
      if (e.currentTarget.contains(e.target)) {
        var ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e.target), activeElement2 = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument);
        if (!state.current.isFocusWithin && activeElement2 === e.nativeEvent.target) {
          onFocusWithin && onFocusWithin(e);
          onFocusWithinChange && onFocusWithinChange(!0);
          state.current.isFocusWithin = !0;
          onSyntheticFocus(e);
          let currentTarget = e.currentTarget;
          addGlobalListener(ownerDocument, "focus", e2 => {
            var JSCompiler_temp;
            if (JSCompiler_temp = state.current.isFocusWithin) {
              JSCompiler_temp = e2.target, JSCompiler_temp = !(JSCompiler_temp && currentTarget && currentTarget.contains(JSCompiler_temp));
            }
            JSCompiler_temp && (e2 = JSCompiler_temp = new ownerDocument.defaultView.FocusEvent("blur", {relatedTarget:e2.target}), Object.defineProperty(e2, "target", {value:currentTarget}), Object.defineProperty(e2, "currentTarget", {value:currentTarget}), e2 = $8a9cb279dc87e130$export$525bc4921d56d4a(JSCompiler_temp), onBlur(e2));
          }, {capture:!0});
        }
      }
    }, [onFocusWithin, onFocusWithinChange, onSyntheticFocus, addGlobalListener, onBlur]);
    return isDisabled ? {focusWithinProps:{onFocus:void 0, onBlur:void 0}} : {focusWithinProps:{onFocus:props, onBlur}};
  }
  function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0;
    setTimeout(() => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
    }, 50);
  }
  function $6179b936705e76d3$var$handleGlobalPointerEvent(e) {
    "touch" === e.pointerType && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
  }
  function $6179b936705e76d3$var$setupGlobalTouchEvents() {
    if ("undefined" !== typeof document) {
      return "undefined" !== typeof PointerEvent && document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent), $6179b936705e76d3$var$hoverCount++, () => {
        $6179b936705e76d3$var$hoverCount--;
        0 < $6179b936705e76d3$var$hoverCount || "undefined" !== typeof PointerEvent && document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
      };
    }
  }
  function $6179b936705e76d3$export$ae780daf29e6d456(props) {
    let {onHoverStart, onHoverChange, onHoverEnd, isDisabled} = props, [isHovered, setHovered] = (0,import_react8.useState)(!1), state = (0,import_react8.useRef)({isHovered:!1, ignoreEmulatedMouseEvents:!1, pointerType:"", target:null}).current;
    (0,import_react8.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
    let {addGlobalListener, removeAllGlobalListeners} = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), {hoverProps, triggerHoverEnd} = (0,import_react8.useMemo)(() => {
      let triggerHoverStart = (event, pointerType) => {
        state.pointerType = pointerType;
        if (!isDisabled && "touch" !== pointerType && !state.isHovered && event.currentTarget.contains(event.target)) {
          state.isHovered = !0;
          var target = event.currentTarget;
          state.target = target;
          addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", e => {
            var JSCompiler_temp;
            if (JSCompiler_temp = state.isHovered && state.target) {
              JSCompiler_temp = state.target;
              var otherNode = e.target;
              JSCompiler_temp = !(otherNode && JSCompiler_temp && JSCompiler_temp.contains(otherNode));
            }
            JSCompiler_temp && triggerHoverEnd2(e, e.pointerType);
          }, {capture:!0});
          onHoverStart && onHoverStart({type:"hoverstart", target, pointerType});
          onHoverChange && onHoverChange(!0);
          setHovered(!0);
        }
      }, triggerHoverEnd2 = (event, pointerType) => {
        event = state.target;
        state.pointerType = "";
        state.target = null;
        "touch" !== pointerType && state.isHovered && event && (state.isHovered = !1, removeAllGlobalListeners(), onHoverEnd && onHoverEnd({type:"hoverend", target:event, pointerType}), onHoverChange && onHoverChange(!1), setHovered(!1));
      }, hoverProps2 = {};
      "undefined" !== typeof PointerEvent && (hoverProps2.onPointerEnter = e => {
        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && "mouse" === e.pointerType || triggerHoverStart(e, e.pointerType);
      }, hoverProps2.onPointerLeave = e => {
        !isDisabled && e.currentTarget.contains(e.target) && triggerHoverEnd2(e, e.pointerType);
      });
      return {hoverProps:hoverProps2, triggerHoverEnd:triggerHoverEnd2};
    }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state, addGlobalListener, removeAllGlobalListeners]);
    (0,import_react8.useEffect)(() => {
      isDisabled && triggerHoverEnd({currentTarget:state.target}, state.pointerType);
    }, [isDisabled]);
    return {hoverProps, isHovered};
  }
  function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
    let {autoFocus = !1, isTextInput, within} = props, state = (0,import_react9.useRef)({isFocused:!1, isFocusVisible:autoFocus || "pointer" !== $507fabe10e71c6fb$var$currentModality}), [isFocused, setFocused] = (0,import_react9.useState)(!1), [isFocusVisibleState, setFocusVisible] = (0,import_react9.useState)(() => state.current.isFocused && state.current.isFocusVisible), updateState = (0,import_react9.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    var onFocusChange = (0,import_react9.useCallback)(isFocused2 => {
      state.current.isFocused = isFocused2;
      setFocused(isFocused2);
      updateState();
    }, [updateState]);
    $507fabe10e71c6fb$export$ec71b4b83ac08ec3(isFocusVisible => {
      state.current.isFocusVisible = isFocusVisible;
      updateState();
    }, [], {isTextInput});
    ({focusProps:props} = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({isDisabled:within, onFocusChange}));
    ({focusWithinProps:onFocusChange} = $9ab94262bd0047c7$export$420e68273165f4ec({isDisabled:!within, onFocusWithinChange:onFocusChange}));
    return {isFocused, isFocusVisible:isFocusVisibleState, focusProps:within ? onFocusChange : props};
  }
  function getOwnerDocument(element) {
    var _a3;
    return env.isServer ? null : null == element ? document : null != (_a3 = null == element ? void 0 : element.ownerDocument) ? _a3 : document;
  }
  function getRootNode(element) {
    var _a3, _b2;
    return env.isServer ? null : null == element ? document : null != (_b2 = null == (_a3 = null == element ? void 0 : element.getRootNode) ? void 0 : _a3.call(element)) ? _b2 : document;
  }
  function getActiveElement(element) {
    var _a3, _b2;
    return null != (_b2 = null == (_a3 = getRootNode(element)) ? void 0 : _a3.activeElement) ? _b2 : null;
  }
  function isActiveElement(element) {
    return getActiveElement(element) === element;
  }
  function microTask(cb) {
    "function" === typeof queueMicrotask ? queueMicrotask(cb) : Promise.resolve().then(cb).catch(e => setTimeout(() => {
      throw e;
    }));
  }
  function disposables() {
    let _disposables = [], api = {addEventListener(element, name, listener, options) {
      element.addEventListener(name, listener, options);
      return api.add(() => element.removeEventListener(name, listener, options));
    }, requestAnimationFrame(...args) {
      let raf = requestAnimationFrame(...args);
      return api.add(() => cancelAnimationFrame(raf));
    }, nextFrame(...args) {
      return api.requestAnimationFrame(() => api.requestAnimationFrame(...args));
    }, setTimeout(...args) {
      let timer = setTimeout(...args);
      return api.add(() => clearTimeout(timer));
    }, microTask(...args) {
      var JSCompiler_object_inline_current_272 = !0;
      microTask(() => {
        if (JSCompiler_object_inline_current_272) {
          args[0]();
        }
      });
      return api.add(() => {
        JSCompiler_object_inline_current_272 = !1;
      });
    }, style(node, property, value) {
      let previous = node.style.getPropertyValue(property);
      Object.assign(node.style, {[property]:value});
      return this.add(() => {
        Object.assign(node.style, {[property]:previous});
      });
    }, group(cb) {
      let d = disposables();
      cb(d);
      return this.add(() => d.dispose());
    }, add(cb) {
      _disposables.includes(cb) || _disposables.push(cb);
      return () => {
        let idx = _disposables.indexOf(cb);
        if (0 <= idx) {
          for (let dispose of _disposables.splice(idx, 1)) {
            dispose();
          }
        }
      };
    }, dispose() {
      for (let dispose of _disposables.splice(0)) {
        dispose();
      }
    }};
    return api;
  }
  function useDisposables() {
    let [d] = (0,import_react10.useState)(disposables);
    (0,import_react10.useEffect)(() => () => d.dispose(), [d]);
    return d;
  }
  function useLatestValue(value) {
    let cache = (0,import_react12.useRef)(value);
    useIsoMorphicEffect(() => {
      cache.current = value;
    }, [value]);
    return cache;
  }
  function useActivePress({disabled = !1} = {}) {
    let target = (0,import_react14.useRef)(null), [pressed, setPressed] = (0,import_react14.useState)(!1), d = useDisposables(), reset = useEvent(() => {
      target.current = null;
      setPressed(!1);
      d.dispose();
    }), handlePointerDown = useEvent(event => {
      d.dispose();
      null === target.current && (target.current = event.currentTarget, setPressed(!0), event = getOwnerDocument(event.currentTarget), d.addEventListener(event, "pointerup", reset, !1), d.addEventListener(event, "pointermove", event2 => {
        if (target.current) {
          var offsetX = event2.width / 2;
          let offsetY = event2.height / 2;
          event2 = {top:event2.clientY - offsetY, right:event2.clientX + offsetX, bottom:event2.clientY + offsetY, left:event2.clientX - offsetX};
          offsetX = target.current.getBoundingClientRect();
          setPressed(!event2 || !offsetX || event2.right < offsetX.left || event2.left > offsetX.right || event2.bottom < offsetX.top || event2.top > offsetX.bottom ? !1 : !0);
        }
      }, !1), d.addEventListener(event, "pointercancel", reset, !1));
    });
    return {pressed, pressProps:disabled ? {} : {onPointerDown:handlePointerDown, onPointerUp:reset, onClick:reset}};
  }
  function useSlot(object) {
    return (0,import_react15.useMemo)(() => object, Object.values(object));
  }
  function useDisabled() {
    return (0,import_react16.useContext)(DisabledContext);
  }
  function DisabledProvider({value, children}) {
    return import_react16.default.createElement(DisabledContext.Provider, {value}, children);
  }
  function classNames(...classes) {
    return Array.from(new Set(classes.flatMap(value => "string" === typeof value ? value.split(" ") : []))).filter(Boolean).join(" ");
  }
  function match(value, lookup, ...args) {
    if (value in lookup) {
      return value = lookup[value], "function" === typeof value ? value(...args) : value;
    }
    args = Error(`Tried to handle "${value}" but there is no handler defined. Only defined handlers are: ${Object.keys(lookup).map(key => `"${key}"`).join(", ")}.`);
    Error.captureStackTrace && Error.captureStackTrace(args, match);
    throw args;
  }
  function useRender() {
    let mergeRefs = useMergeRefsFn();
    return (0,import_react17.useCallback)(args => render({mergeRefs, ...args}), [mergeRefs]);
  }
  function render({ourProps, theirProps, slot, defaultTag, features, visible = !0, name, mergeRefs}) {
    mergeRefs = null != mergeRefs ? mergeRefs : defaultMergeRefs;
    ourProps = mergePropsAdvanced(theirProps, ourProps);
    if (visible) {
      return _render(ourProps, slot, defaultTag, name, mergeRefs);
    }
    features = null != features ? features : 0;
    if (features & 2) {
      let {static:isStatic = !1, ...rest} = ourProps;
      if (isStatic) {
        return _render(rest, slot, defaultTag, name, mergeRefs);
      }
    }
    if (features & 1) {
      let {unmount = !0, ...rest} = ourProps;
      return match(unmount ? 0 : 1, {[0]() {
        return null;
      }, [1]() {
        return _render({...rest, hidden:!0, style:{display:"none"}}, slot, defaultTag, name, mergeRefs);
      }});
    }
    return _render(ourProps, slot, defaultTag, name, mergeRefs);
  }
  function _render(props, slot = {}, tag, name, mergeRefs) {
    let {as:Component = tag, children, refName = "ref", ...rest} = omit(props, ["unmount", "static"]);
    props = void 0 !== props.ref ? {[refName]:props.ref} : {};
    tag = "function" === typeof children ? children(slot) : children;
    "className" in rest && rest.className && "function" === typeof rest.className && (rest.className = rest.className(slot));
    rest["aria-labelledby"] && rest["aria-labelledby"] === rest.id && (rest["aria-labelledby"] = void 0);
    let dataAttributes = {};
    if (slot) {
      let exposeState = !1, states = [];
      for (let [k, v] of Object.entries(slot)) {
        "boolean" === typeof v && (exposeState = !0), !0 === v && states.push(k.replace(/([A-Z])/g, m => `-${m.toLowerCase()}`));
      }
      if (exposeState) {
        dataAttributes["data-headlessui-state"] = states.join(" ");
        for (let state of states) {
          dataAttributes[`data-${state}`] = "";
        }
      }
    }
    if (isFragment(Component) && (0 < Object.keys(compact(rest)).length || 0 < Object.keys(compact(dataAttributes)).length)) {
      if (!(0,import_react17.isValidElement)(tag) || Array.isArray(tag) && 1 < tag.length || isFragment(tag.type)) {
        if (0 < Object.keys(compact(rest)).length) {
          throw Error(['Passing props on "Fragment"!\n', `The current component <${name} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(compact(rest)).concat(Object.keys(compact(dataAttributes))).map(line => `  - ${line}`).join("\n"), "\nYou can apply a few solutions:", ['Add an `as\x3d"..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(line => 
          `  - ${line}`).join("\n")].join("\n"));
        }
      } else {
        slot = tag.props;
        let childPropsClassName = null == slot ? void 0 : slot.className;
        slot = (slot = "function" === typeof childPropsClassName ? (...args) => classNames(childPropsClassName(...args), rest.className) : classNames(childPropsClassName, rest.className)) ? {className:slot} : {};
        name = mergePropsAdvanced(tag.props, compact(omit(rest, ["ref"])));
        for (let key in dataAttributes) {
          key in name && delete dataAttributes[key];
        }
        return (0,import_react17.cloneElement)(tag, Object.assign({}, name, dataAttributes, props, {ref:mergeRefs(getElementRef(tag), props.ref)}, slot));
      }
    }
    return (0,import_react17.createElement)(Component, Object.assign({}, omit(rest, ["ref"]), !isFragment(Component) && props, !isFragment(Component) && dataAttributes), tag);
  }
  function useMergeRefsFn() {
    let currentRefs = (0,import_react17.useRef)([]), mergedRef = (0,import_react17.useCallback)(value => {
      for (let ref of currentRefs.current) {
        null != ref && ("function" === typeof ref ? ref(value) : ref.current = value);
      }
    }, []);
    return (...refs) => {
      if (!refs.every(ref => null == ref)) {
        return currentRefs.current = refs, mergedRef;
      }
    };
  }
  function defaultMergeRefs(...refs) {
    return refs.every(ref => null == ref) ? void 0 : value => {
      for (let ref of refs) {
        null != ref && ("function" === typeof ref ? ref(value) : ref.current = value);
      }
    };
  }
  function mergePropsAdvanced(...listOfProps) {
    var _a3;
    if (0 === listOfProps.length) {
      return {};
    }
    if (1 === listOfProps.length) {
      return listOfProps[0];
    }
    let target = {}, eventHandlers = {};
    for (let props of listOfProps) {
      for (let prop in props) {
        prop.startsWith("on") && "function" === typeof props[prop] ? (null != (_a3 = eventHandlers[prop]) ? _a3 : eventHandlers[prop] = [], eventHandlers[prop].push(props[prop])) : target[prop] = props[prop];
      }
    }
    if (target.disabled || target["aria-disabled"]) {
      for (let eventName in eventHandlers) {
        /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(eventName) && (eventHandlers[eventName] = [e => {
          var _a4;
          return null == (_a4 = null == e ? void 0 : e.preventDefault) ? void 0 : _a4.call(e);
        }]);
      }
    }
    for (let eventName in eventHandlers) {
      Object.assign(target, {[eventName](event, ...args) {
        let handlers = eventHandlers[eventName];
        for (let handler of handlers) {
          if ((event instanceof Event || (null == event ? void 0 : event.nativeEvent) instanceof Event) && event.defaultPrevented) {
            break;
          }
          handler(event, ...args);
        }
      }});
    }
    return target;
  }
  function mergeProps(...listOfProps) {
    var _a3;
    if (0 === listOfProps.length) {
      return {};
    }
    if (1 === listOfProps.length) {
      return listOfProps[0];
    }
    let target = {}, eventHandlers = {};
    for (let props of listOfProps) {
      for (let prop in props) {
        prop.startsWith("on") && "function" === typeof props[prop] ? (null != (_a3 = eventHandlers[prop]) ? _a3 : eventHandlers[prop] = [], eventHandlers[prop].push(props[prop])) : target[prop] = props[prop];
      }
    }
    for (let eventName in eventHandlers) {
      Object.assign(target, {[eventName](...args) {
        let handlers = eventHandlers[eventName];
        for (let handler of handlers) {
          null == handler || handler(...args);
        }
      }});
    }
    return target;
  }
  function forwardRefWithAs(component) {
    var _a3;
    return Object.assign((0,import_react17.forwardRef)(component), {displayName:null != (_a3 = component.displayName) ? _a3 : component.name});
  }
  function compact(object) {
    object = Object.assign({}, object);
    for (let key in object) {
      void 0 === object[key] && delete object[key];
    }
    return object;
  }
  function omit(object, keysToOmit = []) {
    object = Object.assign({}, object);
    for (let key of keysToOmit) {
      key in object && delete object[key];
    }
    return object;
  }
  function getElementRef(element) {
    return "19" <= import_react17.default.version.split(".")[0] ? element.props.ref : element.ref;
  }
  function isFragment(element) {
    return element === import_react17.Fragment || element === Symbol.for("react.fragment");
  }
  function useControllable(controlledValue, onChange, defaultValue) {
    let [internalValue, setInternalValue] = (0,import_react18.useState)(defaultValue), isControlled = void 0 !== controlledValue;
    defaultValue = (0,import_react18.useRef)(isControlled);
    let didWarnOnUncontrolledToControlled = (0,import_react18.useRef)(!1), didWarnOnControlledToUncontrolled = (0,import_react18.useRef)(!1);
    !isControlled || defaultValue.current || didWarnOnUncontrolledToControlled.current ? isControlled || !defaultValue.current || didWarnOnControlledToUncontrolled.current || (didWarnOnControlledToUncontrolled.current = !0, defaultValue.current = isControlled, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")) : (didWarnOnUncontrolledToControlled.current = !0, defaultValue.current = 
    isControlled, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen."));
    return [isControlled ? controlledValue : internalValue, useEvent(value => {
      isControlled || (0,import_react_dom.flushSync)(() => setInternalValue(value));
      return null == onChange ? void 0 : onChange(value);
    })];
  }
  function useDefaultValue(value) {
    [value] = (0,import_react19.useState)(value);
    return value;
  }
  function objectToFormEntries(source = {}, parentKey = null, entries = []) {
    for (let [key, value] of Object.entries(source)) {
      append(entries, parentKey ? parentKey + "[" + key + "]" : key, value);
    }
    return entries;
  }
  function append(entries, key$jscomp$0, value) {
    if (Array.isArray(value)) {
      for (let [subkey, subvalue] of value.entries()) {
        value = key$jscomp$0;
        var key = subkey.toString();
        append(entries, value ? value + "[" + key + "]" : key, subvalue);
      }
    } else {
      value instanceof Date ? entries.push([key$jscomp$0, value.toISOString()]) : "boolean" === typeof value ? entries.push([key$jscomp$0, value ? "1" : "0"]) : "string" === typeof value ? entries.push([key$jscomp$0, value]) : "number" === typeof value ? entries.push([key$jscomp$0, `${value}`]) : null === value || void 0 === value ? entries.push([key$jscomp$0, ""]) : ("[object Object]" !== Object.prototype.toString.call(value) ? key = !1 : (key = Object.getPrototypeOf(value), key = null === key || 
      null === Object.getPrototypeOf(key)), key && !(0,import_react21.isValidElement)(value) && objectToFormEntries(value, key$jscomp$0, entries));
    }
  }
  function attemptSubmit(elementInForm) {
    var _a3, _b2;
    let form = null != (_a3 = null == elementInForm ? void 0 : elementInForm.form) ? _a3 : elementInForm.closest("form");
    if (form) {
      for (let element of form.elements) {
        if (element !== elementInForm && ("INPUT" === element.tagName && "submit" === element.type || "BUTTON" === element.tagName && "submit" === element.type || "INPUT" === element.nodeName && "image" === element.type)) {
          element.click();
          return;
        }
      }
      null == (_b2 = form.requestSubmit) || _b2.call(form);
    }
  }
  function FormFieldsProvider(props) {
    let [target, setTarget] = (0,import_react22.useState)(null);
    return import_react22.default.createElement(FormFieldsContext.Provider, {value:{target}}, props.children, import_react22.default.createElement(Hidden, {features:4, ref:setTarget}));
  }
  function HoistFormFields({children}) {
    var formFieldsContext = (0,import_react22.useContext)(FormFieldsContext);
    if (!formFieldsContext) {
      return import_react22.default.createElement(import_react22.default.Fragment, null, children);
    }
    ({target:formFieldsContext} = formFieldsContext);
    return formFieldsContext ? (0,import_react_dom2.createPortal)(import_react22.default.createElement(import_react22.default.Fragment, null, children), formFieldsContext) : null;
  }
  function FormFields({data, form:formId, disabled, onReset, overrides}) {
    let [form, setForm] = (0,import_react22.useState)(null), d = useDisposables();
    (0,import_react22.useEffect)(() => {
      if (onReset && form) {
        return d.addEventListener(form, "reset", onReset);
      }
    }, [form, formId, onReset]);
    return import_react22.default.createElement(HoistFormFields, null, import_react22.default.createElement(FormResolver, {setForm, formId}), objectToFormEntries(data).map(([name, value]) => import_react22.default.createElement(Hidden, {features:4, ...compact({key:name, as:"input", type:"hidden", hidden:!0, readOnly:!0, form:formId, disabled, name, value, ...overrides})})));
  }
  function FormResolver({setForm, formId}) {
    (0,import_react22.useEffect)(() => {
      if (formId) {
        let resolvedForm = document.getElementById(formId);
        resolvedForm && setForm(resolvedForm);
      }
    }, [setForm, formId]);
    return formId ? null : import_react22.default.createElement(Hidden, {features:4, as:"input", type:"hidden", hidden:!0, readOnly:!0, ref:el => {
      el && (el = el.closest("form")) && setForm(el);
    }});
  }
  function useProvidedId() {
    return (0,import_react23.useContext)(IdContext);
  }
  function IdProvider({id, children}) {
    return import_react23.default.createElement(IdContext.Provider, {value:id}, children);
  }
  function isNode(element) {
    return "object" !== typeof element || null === element ? !1 : "nodeType" in element;
  }
  function isElement(element) {
    return isNode(element) && "tagName" in element;
  }
  function isHTMLElement(element) {
    return isElement(element) && "accessKey" in element;
  }
  function isHTMLorSVGElement(element) {
    return isElement(element) && "tabIndex" in element;
  }
  function isHTMLInputElement(element) {
    return isHTMLElement(element) && "INPUT" === element.nodeName;
  }
  function isHTMLLabelElement(element) {
    return isHTMLElement(element) && "LABEL" === element.nodeName;
  }
  function isHTMLFieldSetElement(element) {
    return isHTMLElement(element) && "FIELDSET" === element.nodeName;
  }
  function isHTMLLegendElement(element) {
    return isHTMLElement(element) && "LEGEND" === element.nodeName;
  }
  function isDisabledReactIssue7711(element) {
    var parent = element.parentElement;
    for (element = null; parent && !isHTMLFieldSetElement(parent);) {
      isHTMLLegendElement(parent) && (element = parent), parent = parent.parentElement;
    }
    parent = "" === (null == parent ? void 0 : parent.getAttribute("disabled"));
    var JSCompiler_temp;
    if (JSCompiler_temp = parent) {
      a: {
        if (element) {
          for (element = element.previousElementSibling; null !== element;) {
            if (isHTMLLegendElement(element)) {
              JSCompiler_temp = !1;
              break a;
            }
            element = element.previousElementSibling;
          }
          JSCompiler_temp = !0;
        } else {
          JSCompiler_temp = !1;
        }
      }
    }
    return JSCompiler_temp ? !1 : parent;
  }
  function optionalRef(cb, isOptional = !0) {
    return Object.assign(cb, {[Optional]:isOptional});
  }
  function useSyncRefs(...refs) {
    let cache = (0,import_react24.useRef)(refs);
    (0,import_react24.useEffect)(() => {
      cache.current = refs;
    }, [refs]);
    let syncRefs = useEvent(value => {
      for (let ref of cache.current) {
        null != ref && ("function" === typeof ref ? ref(value) : ref.current = value);
      }
    });
    return refs.every(ref => null == ref || (null == ref ? void 0 : ref[Optional])) ? void 0 : syncRefs;
  }
  function useDescriptionContext() {
    var context = (0,import_react25.useContext)(DescriptionContext);
    if (null === context) {
      throw context = Error("You used a \x3cDescription /\x3e component, but it is not inside a relevant parent."), Error.captureStackTrace && Error.captureStackTrace(context, useDescriptionContext), context;
    }
    return context;
  }
  function useDescribedBy() {
    var _a3, _b2;
    return null != (_b2 = null == (_a3 = (0,import_react25.useContext)(DescriptionContext)) ? void 0 : _a3.value) ? _b2 : void 0;
  }
  function useDescriptions() {
    let [descriptionIds, setDescriptionIds] = (0,import_react25.useState)([]);
    return [0 < descriptionIds.length ? descriptionIds.join(" ") : void 0, (0,import_react25.useMemo)(() => function(props) {
      let register = useEvent(value => {
        setDescriptionIds(existing => [...existing, value]);
        return () => setDescriptionIds(existing => {
          existing = existing.slice();
          let idx = existing.indexOf(value);
          -1 !== idx && existing.splice(idx, 1);
          return existing;
        });
      }), contextBag = (0,import_react25.useMemo)(() => ({register, slot:props.slot, name:props.name, props:props.props, value:props.value}), [register, props.slot, props.name, props.props, props.value]);
      return import_react25.default.createElement(DescriptionContext.Provider, {value:contextBag}, props.children);
    }, [setDescriptionIds])];
  }
  function useLabelContext() {
    var context = (0,import_react26.useContext)(LabelContext);
    if (null === context) {
      throw context = Error("You used a \x3cLabel /\x3e component, but it is not inside a relevant parent."), Error.captureStackTrace && Error.captureStackTrace(context, useLabelContext), context;
    }
    return context;
  }
  function useLabelledBy(alwaysAvailableIds) {
    var _a3, _b2, _c;
    let labelIds = null != (_b2 = null == (_a3 = (0,import_react26.useContext)(LabelContext)) ? void 0 : _a3.value) ? _b2 : void 0;
    return 0 < (null != (_c = null == alwaysAvailableIds ? void 0 : alwaysAvailableIds.length) ? _c : 0) ? [labelIds, ...alwaysAvailableIds].filter(Boolean).join(" ") : labelIds;
  }
  function useLabels({inherit = !1} = {}) {
    let parentLabelledBy = useLabelledBy(), [labelIds, setLabelIds] = (0,import_react26.useState)([]);
    inherit = inherit ? [parentLabelledBy, ...labelIds].filter(Boolean) : labelIds;
    return [0 < inherit.length ? inherit.join(" ") : void 0, (0,import_react26.useMemo)(() => function(props) {
      let register = useEvent(value => {
        setLabelIds(existing => [...existing, value]);
        return () => setLabelIds(existing => {
          existing = existing.slice();
          let idx = existing.indexOf(value);
          -1 !== idx && existing.splice(idx, 1);
          return existing;
        });
      }), contextBag = (0,import_react26.useMemo)(() => ({register, slot:props.slot, name:props.name, props:props.props, value:props.value}), [register, props.slot, props.name, props.props, props.value]);
      return import_react26.default.createElement(LabelContext.Provider, {value:contextBag}, props.children);
    }, [setLabelIds])];
  }
  function useClose() {
    return (0,import_react28.useContext)(CloseContext);
  }
  function CloseProvider({value, children}) {
    return import_react28.default.createElement(CloseContext.Provider, {value}, children);
  }
  function memo(getDeps, fn, opts) {
    function memoizedFunction() {
      var _a4, _b2, _c, _d, depTime;
      opts.key && (null == (_a4 = opts.debug) ? 0 : _a4.call(opts)) && (depTime = Date.now());
      _a4 = getDeps();
      if (_a4.length === deps.length && !_a4.some((dep, index3) => deps[index3] !== dep)) {
        return result;
      }
      deps = _a4;
      var resultTime;
      opts.key && (null == (_b2 = opts.debug) ? 0 : _b2.call(opts)) && (resultTime = Date.now());
      result = fn(..._a4);
      opts.key && (null == (_c = opts.debug) ? 0 : _c.call(opts)) && (_b2 = Math.round(100 * (Date.now() - depTime)) / 100, resultTime = Math.round(100 * (Date.now() - resultTime)) / 100, _c = resultTime / 16, depTime = (str, num) => {
        for (str = String(str); str.length < num;) {
          str = " " + str;
        }
        return str;
      }, console.info(`%c\u23F1 ${depTime(resultTime, 5)} /${depTime(_b2, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * _c, 120))}deg 100% 31%);`, null == opts ? void 0 : opts.key));
      null == (_d = null == opts ? void 0 : opts.onChange) || _d.call(opts, result);
      return result;
    }
    var _a3;
    let deps = null != (_a3 = opts.initialDeps) ? _a3 : [], result;
    memoizedFunction.updateDeps = newDeps => {
      deps = newDeps;
    };
    return memoizedFunction;
  }
  function notUndefined(value, msg) {
    if (void 0 === value) {
      throw Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
    }
    return value;
  }
  function calculateRange({measurements, outerSize, scrollOffset, lanes}) {
    const lastIndex = measurements.length - 1;
    if (measurements.length <= lanes) {
      return {startIndex:0, endIndex:lastIndex};
    }
    let startIndex = findNearestBinarySearch(0, lastIndex, index3 => measurements[index3].start, scrollOffset), endIndex = startIndex;
    if (1 === lanes) {
      for (; endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize;) {
        endIndex++;
      }
    } else if (1 < lanes) {
      for (var endPerLane = Array(lanes).fill(0); endIndex < lastIndex && endPerLane.some(pos => pos < scrollOffset + outerSize);) {
        var item = measurements[endIndex];
        endPerLane[item.lane] = item.end;
        endIndex++;
      }
      for (endPerLane = Array(lanes).fill(scrollOffset + outerSize); 0 <= startIndex && endPerLane.some(pos => pos >= scrollOffset);) {
        item = measurements[startIndex], endPerLane[item.lane] = item.start, startIndex--;
      }
      startIndex = Math.max(0, startIndex - startIndex % lanes);
      endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
    }
    return {startIndex, endIndex};
  }
  function useVirtualizerBase(options) {
    const rerender = React11.useReducer(() => ({}), {})[1], resolvedOptions = {...options, onChange:(instance2, sync) => {
      var _a3;
      sync ? (0,import_react_dom3.flushSync)(rerender) : rerender();
      null == (_a3 = options.onChange) || _a3.call(options, instance2, sync);
    }}, [instance] = React11.useState(() => new Virtualizer(resolvedOptions));
    instance.setOptions(resolvedOptions);
    useIsomorphicLayoutEffect(() => instance._didMount(), []);
    useIsomorphicLayoutEffect(() => instance._willUpdate());
    return instance;
  }
  function defaultBy(a, z) {
    return null !== a && null !== z && "object" === typeof a && "object" === typeof z && "id" in a && "id" in z ? a.id === z.id : a === z;
  }
  function useByComparator(by = defaultBy) {
    return (0,import_react30.useCallback)((a, z) => "string" === typeof by ? (null == a ? void 0 : a[by]) === (null == z ? void 0 : z[by]) : by(a, z), [by]);
  }
  function computeSize(element) {
    if (null === element) {
      return {width:0, height:0};
    }
    let {width, height} = element.getBoundingClientRect();
    return {width, height};
  }
  function useElementSize(enabled, element, unit = !1) {
    let [size3, setSize] = (0,import_react31.useState)(() => computeSize(element));
    useIsoMorphicEffect(() => {
      if (element && enabled) {
        var d = disposables();
        d.requestAnimationFrame(function run() {
          d.requestAnimationFrame(run);
          setSize(current => {
            let newSize = computeSize(element);
            return newSize.width === current.width && newSize.height === current.height ? current : newSize;
          });
        });
        return () => {
          d.dispose();
        };
      }
    }, [element, enabled]);
    return unit ? {width:`${size3.width}px`, height:`${size3.height}px`} : size3;
  }
  function useHandleToggle(cb) {
    let pointerTypeRef = (0,import_react32.useRef)(null), handlePointerDown = useEvent(event => {
      pointerTypeRef.current = event.pointerType;
      isDisabledReactIssue7711(event.currentTarget) || "mouse" !== event.pointerType || 0 !== event.button || (event.preventDefault(), cb(event));
    }), handleClick = useEvent(event => {
      "mouse" !== pointerTypeRef.current && (isDisabledReactIssue7711(event.currentTarget) || cb(event));
    });
    return {onPointerDown:handlePointerDown, onClick:handleClick};
  }
  function shallowEqual(a, b) {
    return Object.is(a, b) ? !0 : "object" !== typeof a || null === a || "object" !== typeof b || null === b ? !1 : Array.isArray(a) && Array.isArray(b) ? a.length !== b.length ? !1 : compareEntries(a[Symbol.iterator](), b[Symbol.iterator]()) : a instanceof Map && b instanceof Map || a instanceof Set && b instanceof Set ? a.size !== b.size ? !1 : compareEntries(a.entries(), b.entries()) : isPlainObject2(a) && isPlainObject2(b) ? compareEntries(Object.entries(a)[Symbol.iterator](), Object.entries(b)[Symbol.iterator]()) : 
    !1;
  }
  function compareEntries(a, b) {
    do {
      let aResult = a.next(), bResult = b.next();
      if (aResult.done && bResult.done) {
        return !0;
      }
      if (aResult.done || bResult.done || !Object.is(aResult.value, bResult.value)) {
        return !1;
      }
    } while (1);
  }
  function isPlainObject2(value) {
    if ("[object Object]" !== Object.prototype.toString.call(value)) {
      return !1;
    }
    value = Object.getPrototypeOf(value);
    return null === value || null === Object.getPrototypeOf(value);
  }
  function batch(setup) {
    let [callback, handle] = setup(), d = disposables();
    return (...args) => {
      callback(...args);
      d.dispose();
      d.microTask(handle);
    };
  }
  function useSlice(machine, selector, compare = shallowEqual) {
    return (0,import_with_selector.useSyncExternalStoreWithSelector)(useEvent(onStoreChange => machine.subscribe(identity, onStoreChange)), useEvent(() => machine.state), useEvent(() => machine.state), useEvent(selector), compare);
  }
  function identity(value) {
    return value;
  }
  function useIsTopLayer(enabled, scope) {
    let id = (0,import_react33.useId)(), stackMachine = stackMachines.get(scope), [isTop, onStack] = useSlice(stackMachine, (0,import_react33.useCallback)(state => [stackMachine.selectors.isTop(state, id), stackMachine.selectors.inStack(state, id)], [stackMachine, id]));
    useIsoMorphicEffect(() => {
      if (enabled) {
        return stackMachine.actions.push(id), () => stackMachine.actions.pop(id);
      }
    }, [stackMachine, enabled, id]);
    return enabled ? onStack ? isTop : !0 : !1;
  }
  function markInert(element) {
    var _a3;
    let count2 = null != (_a3 = counts.get(element)) ? _a3 : 0;
    counts.set(element, count2 + 1);
    if (0 !== count2) {
      return () => markNotInert(element);
    }
    originals.set(element, {"aria-hidden":element.getAttribute("aria-hidden"), inert:element.inert});
    element.setAttribute("aria-hidden", "true");
    element.inert = !0;
    return () => markNotInert(element);
  }
  function markNotInert(element) {
    var _a3;
    let count2 = null != (_a3 = counts.get(element)) ? _a3 : 1;
    1 === count2 ? counts.delete(element) : counts.set(element, count2 - 1);
    1 === count2 && (_a3 = originals.get(element)) && (null === _a3["aria-hidden"] ? element.removeAttribute("aria-hidden") : element.setAttribute("aria-hidden", _a3["aria-hidden"]), element.inert = _a3.inert, originals.delete(element));
  }
  function useInertOthers(enabled, {allowed, disallowed} = {}) {
    let isTopLayer = useIsTopLayer(enabled, "inert-others");
    useIsoMorphicEffect(() => {
      var _a3, _b2;
      if (isTopLayer) {
        var d = disposables();
        for (var element$jscomp$0 of null != (_a3 = null == disallowed ? void 0 : disallowed()) ? _a3 : []) {
          element$jscomp$0 && d.add(markInert(element$jscomp$0));
        }
        _a3 = null != (_b2 = null == allowed ? void 0 : allowed()) ? _b2 : [];
        for (let element of _a3) {
          if (element && (_b2 = getOwnerDocument(element))) {
            for (element$jscomp$0 = element.parentElement; element$jscomp$0 && element$jscomp$0 !== _b2.body;) {
              for (let node of element$jscomp$0.children) {
                _a3.some(el => node.contains(el)) || d.add(markInert(node));
              }
              element$jscomp$0 = element$jscomp$0.parentElement;
            }
          }
        }
        return d.dispose;
      }
    }, [isTopLayer, allowed, disallowed]);
  }
  function useOnDisappear(enabled, ref, cb) {
    let listenerRef = useLatestValue(element => {
      element = element.getBoundingClientRect();
      0 === element.x && 0 === element.y && 0 === element.width && 0 === element.height && cb();
    });
    (0,import_react34.useEffect)(() => {
      if (enabled) {
        var element = null === ref ? null : isHTMLElement(ref) ? ref : ref.current;
        if (element) {
          var d = disposables();
          if ("undefined" !== typeof ResizeObserver) {
            let observer = new ResizeObserver(() => listenerRef.current(element));
            observer.observe(element);
            d.add(() => observer.disconnect());
          }
          if ("undefined" !== typeof IntersectionObserver) {
            let observer = new IntersectionObserver(() => listenerRef.current(element));
            observer.observe(element);
            d.add(() => observer.disconnect());
          }
          return () => d.dispose();
        }
      }
    }, [ref, listenerRef, enabled]);
  }
  function getFocusableElements(container = document.body) {
    return null == container ? [] : Array.from(container.querySelectorAll(focusableSelector)).sort((a, z) => Math.sign((a.tabIndex || Number.MAX_SAFE_INTEGER) - (z.tabIndex || Number.MAX_SAFE_INTEGER)));
  }
  function getAutoFocusableElements(container = document.body) {
    return null == container ? [] : Array.from(container.querySelectorAll(autoFocusableSelector)).sort((a, z) => Math.sign((a.tabIndex || Number.MAX_SAFE_INTEGER) - (z.tabIndex || Number.MAX_SAFE_INTEGER)));
  }
  function isFocusableElement(element, mode = 0) {
    var _a3;
    return element === (null == (_a3 = getOwnerDocument(element)) ? void 0 : _a3.body) ? !1 : match(mode, {[0]() {
      return element.matches(focusableSelector);
    }, [1]() {
      let next = element;
      for (; null !== next;) {
        if (next.matches(focusableSelector)) {
          return !0;
        }
        next = next.parentElement;
      }
      return !1;
    }});
  }
  function restoreFocusIfNecessary(element) {
    disposables().nextFrame(() => {
      let activeElement2 = getActiveElement(element);
      activeElement2 && isHTMLorSVGElement(activeElement2) && !isFocusableElement(activeElement2, 0) && focusElement(element);
    });
  }
  function focusElement(element) {
    null == element || element.focus({preventScroll:!0});
  }
  function isSelectableElement(element) {
    var _a3, _b2;
    return null != (_b2 = null == (_a3 = null == element ? void 0 : element.matches) ? void 0 : _a3.call(element, "textarea,input")) ? _b2 : !1;
  }
  function sortByDomNode(nodes, resolveKey = i => i) {
    return nodes.slice().sort((aItem, zItem) => {
      aItem = resolveKey(aItem);
      zItem = resolveKey(zItem);
      if (null === aItem || null === zItem) {
        return 0;
      }
      zItem = aItem.compareDocumentPosition(zItem);
      return zItem & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : zItem & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
    });
  }
  function focusFrom(current, focus, container = null === current ? document.body : getRootNode(current)) {
    return focusIn(getFocusableElements(container), focus, {relativeTo:current});
  }
  function focusIn(container, focus, {sorted = !0, relativeTo = null, skipElements = []} = {}) {
    var root = Array.isArray(container) ? 0 < container.length ? getRootNode(container[0]) : document : getRootNode(container);
    let elements = Array.isArray(container) ? sorted ? sortByDomNode(container) : container : focus & 64 ? getAutoFocusableElements(container) : getFocusableElements(container);
    0 < skipElements.length && 1 < elements.length && (elements = elements.filter(element => !skipElements.some(skipElement => null != skipElement && "current" in skipElement ? (null == skipElement ? void 0 : skipElement.current) === element : skipElement === element)));
    relativeTo = null != relativeTo ? relativeTo : null == root ? void 0 : root.activeElement;
    if (focus & 5) {
      container = 1;
    } else {
      if (focus & 10) {
        container = -1;
      } else {
        throw Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
      }
    }
    sorted = (() => {
      if (focus & 1) {
        return 0;
      }
      if (focus & 2) {
        return Math.max(0, elements.indexOf(relativeTo)) - 1;
      }
      if (focus & 4) {
        return Math.max(0, elements.indexOf(relativeTo)) + 1;
      }
      if (focus & 8) {
        return elements.length - 1;
      }
      throw Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
    })();
    root = focus & 32 ? {preventScroll:!0} : {};
    let offset3 = 0, total = elements.length;
    var next = void 0;
    do {
      if (offset3 >= total || 0 >= offset3 + total) {
        return 0;
      }
      next = sorted + offset3;
      if (focus & 16) {
        next = (next + total) % total;
      } else {
        if (0 > next) {
          return 3;
        }
        if (next >= total) {
          return 1;
        }
      }
      next = elements[next];
      null == next || next.focus(root);
      offset3 += container;
    } while (next !== getActiveElement(next));
    focus & 6 && isSelectableElement(next) && next.select();
    return 2;
  }
  function isIOS() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && 0 < window.navigator.maxTouchPoints;
  }
  function isAndroid() {
    return /Android/gi.test(window.navigator.userAgent);
  }
  function useDocumentEvent(enabled, type, listener, options) {
    let listenerRef = useLatestValue(listener);
    (0,import_react35.useEffect)(() => {
      function handler(event) {
        listenerRef.current(event);
      }
      if (enabled) {
        return document.addEventListener(type, handler, options), () => document.removeEventListener(type, handler, options);
      }
    }, [enabled, type, options]);
  }
  function useWindowEvent(enabled, type, listener, options) {
    let listenerRef = useLatestValue(listener);
    (0,import_react36.useEffect)(() => {
      function handler(event) {
        listenerRef.current(event);
      }
      if (enabled) {
        return window.addEventListener(type, handler, options), () => window.removeEventListener(type, handler, options);
      }
    }, [enabled, type, options]);
  }
  function useOutsideClick(enabled, containers, cb) {
    let cbRef = useLatestValue(cb), handleOutsideClick = (0,import_react37.useCallback)(function(event, resolveTarget) {
      if (!event.defaultPrevented && (resolveTarget = resolveTarget(event), null !== resolveTarget && resolveTarget.getRootNode().contains(resolveTarget) && resolveTarget.isConnected)) {
        var _containers = function resolve(containers2) {
          return "function" === typeof containers2 ? resolve(containers2()) : Array.isArray(containers2) || containers2 instanceof Set ? containers2 : [containers2];
        }(containers);
        for (let container of _containers) {
          if (null !== container && (container.contains(resolveTarget) || event.composed && event.composedPath().includes(container))) {
            return;
          }
        }
        isFocusableElement(resolveTarget, 1) || -1 === resolveTarget.tabIndex || event.preventDefault();
        return cbRef.current(event, resolveTarget);
      }
    }, [cbRef, containers]), initialClickTarget = (0,import_react37.useRef)(null);
    useDocumentEvent(enabled, "pointerdown", event => {
      var _a3, _b2;
      isIOS() || isAndroid() || (initialClickTarget.current = (null == (_b2 = null == (_a3 = event.composedPath) ? void 0 : _a3.call(event)) ? void 0 : _b2[0]) || event.target);
    }, !0);
    useDocumentEvent(enabled, "pointerup", event => {
      if (!isIOS() && !isAndroid() && initialClickTarget.current) {
        var target = initialClickTarget.current;
        initialClickTarget.current = null;
        return handleOutsideClick(event, () => target);
      }
    }, !0);
    let startPosition = (0,import_react37.useRef)({x:0, y:0});
    useDocumentEvent(enabled, "touchstart", event => {
      startPosition.current.x = event.touches[0].clientX;
      startPosition.current.y = event.touches[0].clientY;
    }, !0);
    useDocumentEvent(enabled, "touchend", event => {
      var JSCompiler_object_inline_y_274 = event.changedTouches[0].clientY;
      if (!(30 <= Math.abs(event.changedTouches[0].clientX - startPosition.current.x) || 30 <= Math.abs(JSCompiler_object_inline_y_274 - startPosition.current.y))) {
        return handleOutsideClick(event, () => isHTMLorSVGElement(event.target) ? event.target : null);
      }
    }, !0);
    useWindowEvent(enabled, "blur", event => handleOutsideClick(event, () => {
      var element = window.document.activeElement;
      return isHTMLElement(element) && "IFRAME" === element.nodeName ? window.document.activeElement : null;
    }), !0);
  }
  function useOwnerDocument(...args) {
    return (0,import_react38.useMemo)(() => getOwnerDocument(...args), [...args]);
  }
  function useRootDocument(...args) {
    return (0,import_react38.useMemo)(() => getRootNode(...args), [...args]);
  }
  function useQuickRelease(enabled, {trigger, action, close, select}) {
    let triggeredAtRef = (0,import_react39.useRef)(null), startXRef = (0,import_react39.useRef)(null), startYRef = (0,import_react39.useRef)(null);
    useDocumentEvent(enabled && null !== trigger, "pointerdown", e => {
      isNode(null == e ? void 0 : e.target) && null != trigger && trigger.contains(e.target) && (startXRef.current = e.x, startYRef.current = e.y, triggeredAtRef.current = e.timeStamp);
    });
    useDocumentEvent(enabled && null !== trigger, "pointerup", e => {
      var _a3, _b2;
      let triggeredAt = triggeredAtRef.current;
      if (null !== triggeredAt && (triggeredAtRef.current = null, isHTMLorSVGElement(e.target) && !(5 > Math.abs(e.x - (null != (_a3 = startXRef.current) ? _a3 : e.x)) && 5 > Math.abs(e.y - (null != (_b2 = startYRef.current) ? _b2 : e.y))))) {
        switch(_a3 = action(e), _a3.kind) {
          case 1:
            200 < e.timeStamp - triggeredAt && (select(_a3.target), close());
            break;
          case 2:
            close();
        }
      }
    }, {capture:!0});
  }
  function useEventListener(element, type, listener, options) {
    let listenerRef = useLatestValue(listener);
    (0,import_react40.useEffect)(() => {
      function handler(event) {
        listenerRef.current(event);
      }
      element = null != element ? element : window;
      element.addEventListener(type, handler, options);
      return () => element.removeEventListener(type, handler, options);
    }, [element, type, options]);
  }
  function useRefocusableInput(input) {
    let info = (0,import_react41.useRef)({value:"", selectionStart:null, selectionEnd:null});
    useEventListener(input, "blur", event => {
      event = event.target;
      isHTMLInputElement(event) && (info.current = {value:event.value, selectionStart:event.selectionStart, selectionEnd:event.selectionEnd});
    });
    return useEvent(() => {
      if (!isActiveElement(input) && isHTMLInputElement(input) && input.isConnected) {
        input.focus({preventScroll:!0});
        if (input.value !== info.current.value) {
          input.setSelectionRange(input.value.length, input.value.length);
        } else {
          let {selectionStart, selectionEnd} = info.current;
          null !== selectionStart && null !== selectionEnd && input.setSelectionRange(selectionStart, selectionEnd);
        }
        info.current = {value:"", selectionStart:null, selectionEnd:null};
      }
    });
  }
  function useResolveButtonType(props, element) {
    return (0,import_react42.useMemo)(() => {
      var _a3;
      if (props.type) {
        return props.type;
      }
      let tag = null != (_a3 = props.as) ? _a3 : "button";
      if ("string" === typeof tag && "button" === tag.toLowerCase() || "BUTTON" === (null == element ? void 0 : element.tagName) && !element.hasAttribute("type")) {
        return "button";
      }
    }, [props.type, props.as, element]);
  }
  function adjustScrollbarPadding() {
    let scrollbarWidthBefore;
    return {before({doc}) {
      var _a3;
      let documentElement = doc.documentElement;
      doc = null != (_a3 = doc.defaultView) ? _a3 : window;
      scrollbarWidthBefore = Math.max(0, doc.innerWidth - documentElement.clientWidth);
    }, after({doc, d}) {
      doc = doc.documentElement;
      d.style(doc, "paddingRight", `${Math.max(0, scrollbarWidthBefore - Math.max(0, doc.clientWidth - doc.offsetWidth))}px`);
    }};
  }
  function handleIOSLocking() {
    return isIOS() ? {before({doc, d, meta}) {
      function inAllowedContainer(el) {
        for (let resolve of meta().containers) {
          for (let element of resolve()) {
            if (element.contains(el)) {
              return !0;
            }
          }
        }
        return !1;
      }
      d.microTask(() => {
        var _a3;
        if ("auto" !== window.getComputedStyle(doc.documentElement).scrollBehavior) {
          let _d = disposables();
          _d.style(doc.documentElement, "scrollBehavior", "auto");
          d.add(() => d.microTask(() => _d.dispose()));
        }
        let scrollPosition = null != (_a3 = window.scrollY) ? _a3 : window.pageYOffset, scrollToElement = null;
        d.addEventListener(doc, "click", e => {
          if (isHTMLorSVGElement(e.target)) {
            try {
              let anchor = e.target.closest("a");
              if (anchor) {
                var {hash} = new URL(anchor.href), el = doc.querySelector(hash);
                isHTMLorSVGElement(el) && !inAllowedContainer(el) && (scrollToElement = el);
              }
            } catch (err) {
            }
          }
        }, !0);
        d.group(_d => {
          d.addEventListener(doc, "touchstart", e => {
            _d.dispose();
            var JSCompiler_temp;
            if (JSCompiler_temp = isHTMLorSVGElement(e.target)) {
              JSCompiler_temp = e.target, JSCompiler_temp = isElement(JSCompiler_temp) && "style" in JSCompiler_temp;
            }
            if (JSCompiler_temp) {
              if (inAllowedContainer(e.target)) {
                for (e = e.target; e.parentElement && inAllowedContainer(e.parentElement);) {
                  e = e.parentElement;
                }
                _d.style(e, "overscrollBehavior", "contain");
              } else {
                _d.style(e.target, "touchAction", "none");
              }
            }
          });
        });
        d.addEventListener(doc, "touchmove", e => {
          if (isHTMLorSVGElement(e.target) && !isHTMLInputElement(e.target)) {
            if (inAllowedContainer(e.target)) {
              let scrollableParent = e.target;
              for (; scrollableParent.parentElement && "" !== scrollableParent.dataset.headlessuiPortal && !(scrollableParent.scrollHeight > scrollableParent.clientHeight || scrollableParent.scrollWidth > scrollableParent.clientWidth);) {
                scrollableParent = scrollableParent.parentElement;
              }
              "" === scrollableParent.dataset.headlessuiPortal && e.preventDefault();
            } else {
              e.preventDefault();
            }
          }
        }, {passive:!1});
        d.add(() => {
          var _a4;
          let newScrollPosition = null != (_a4 = window.scrollY) ? _a4 : window.pageYOffset;
          scrollPosition !== newScrollPosition && window.scrollTo(0, scrollPosition);
          scrollToElement && scrollToElement.isConnected && (scrollToElement.scrollIntoView({block:"nearest"}), scrollToElement = null);
        });
      });
    }} : {};
  }
  function preventScroll() {
    return {before({doc, d}) {
      d.style(doc.documentElement, "overflow", "hidden");
    }};
  }
  function buildMeta(fns) {
    let tmp = {};
    for (let fn of fns) {
      Object.assign(tmp, fn(tmp));
    }
    return tmp;
  }
  function useDocumentOverflowLockedEffect(shouldBeLocked, doc, meta = () => ({containers:[]})) {
    var store = (0,import_react43.useSyncExternalStore)(overflows.subscribe, overflows.getSnapshot, overflows.getSnapshot);
    store = (store = doc ? store.get(doc) : void 0) ? 0 < store.count : !1;
    useIsoMorphicEffect(() => {
      if (doc && shouldBeLocked) {
        return overflows.dispatch("PUSH", doc, meta), () => overflows.dispatch("POP", doc, meta);
      }
    }, [shouldBeLocked, doc]);
    return store;
  }
  function useScrollLock(enabled, ownerDocument, resolveAllowedContainers = () => [document.body]) {
    enabled = useIsTopLayer(enabled, "scroll-lock");
    useDocumentOverflowLockedEffect(enabled, ownerDocument, meta => {
      var _a3;
      return {containers:[...(null != (_a3 = meta.containers) ? _a3 : []), resolveAllowedContainers]};
    });
  }
  function useTrackedPointer() {
    let lastPos = (0,import_react44.useRef)([-1, -1]);
    return {wasMoved(evt) {
      evt = [evt.screenX, evt.screenY];
      if (lastPos.current[0] === evt[0] && lastPos.current[1] === evt[1]) {
        return !1;
      }
      lastPos.current = evt;
      return !0;
    }, update(evt) {
      lastPos.current = [evt.screenX, evt.screenY];
    }};
  }
  function useFlags(initialFlags = 0) {
    let [flags, setFlags] = (0,import_react45.useState)(initialFlags);
    initialFlags = (0,import_react45.useCallback)(flag => setFlags(flag), []);
    let addFlag = (0,import_react45.useCallback)(flag => setFlags(flags2 => flags2 | flag), []), hasFlag = (0,import_react45.useCallback)(flag => (flags & flag) === flag, [flags]), removeFlag = (0,import_react45.useCallback)(flag => setFlags(flags2 => flags2 & ~flag), []), toggleFlag = (0,import_react45.useCallback)(flag => setFlags(flags2 => flags2 ^ flag), []);
    return {flags, setFlag:initialFlags, addFlag, hasFlag, removeFlag, toggleFlag};
  }
  function transitionDataAttributes(data) {
    let attributes = {};
    for (let key in data) {
      !0 === data[key] && (attributes[`data-${key}`] = "");
    }
    return attributes;
  }
  function useTransition(enabled, element, show, events) {
    let [visible, setVisible] = (0,import_react46.useState)(show), {hasFlag, addFlag, removeFlag} = useFlags(enabled && visible ? 3 : 0), inFlight = (0,import_react46.useRef)(!1), cancelledRef = (0,import_react46.useRef)(!1), d = useDisposables();
    useIsoMorphicEffect(() => {
      var _a3;
      if (enabled) {
        show && setVisible(!0);
        if (element) {
          return null == (_a3 = null == events ? void 0 : events.start) || _a3.call(events, show), transition(element, {inFlight, prepare() {
            cancelledRef.current = cancelledRef.current ? !1 : inFlight.current;
            inFlight.current = !0;
            cancelledRef.current || (show ? (addFlag(3), removeFlag(4)) : (addFlag(4), removeFlag(2)));
          }, run() {
            cancelledRef.current ? show ? (removeFlag(3), addFlag(4)) : (removeFlag(4), addFlag(3)) : show ? removeFlag(1) : addFlag(1);
          }, done() {
            var _a4;
            cancelledRef.current && hasPendingTransitions(element) || (inFlight.current = !1, removeFlag(7), show || setVisible(!1), null == (_a4 = null == events ? void 0 : events.end) || _a4.call(events, show));
          }});
        }
        show && addFlag(3);
      }
    }, [enabled, show, element, d]);
    return enabled ? [visible, {closed:hasFlag(1), enter:hasFlag(2), leave:hasFlag(4), transition:hasFlag(2) || hasFlag(4)}] : [show, {closed:void 0, enter:void 0, leave:void 0, transition:void 0}];
  }
  function transition(node, {prepare, run, done, inFlight}) {
    let d = disposables();
    prepareTransition(node, {prepare, inFlight});
    d.nextFrame(() => {
      run();
      d.requestAnimationFrame(() => {
        d.add(waitForTransition(node, done));
      });
    });
    return d.dispose;
  }
  function waitForTransition(node, done) {
    var _a3, _b2;
    let d = disposables();
    if (!node) {
      return d.dispose;
    }
    let cancelled = !1;
    d.add(() => {
      cancelled = !0;
    });
    let transitions = null != (_b2 = null == (_a3 = node.getAnimations) ? void 0 : _a3.call(node).filter(animation => animation instanceof CSSTransition)) ? _b2 : [];
    if (0 === transitions.length) {
      return done(), d.dispose;
    }
    Promise.allSettled(transitions.map(transition2 => transition2.finished)).then(() => {
      cancelled || done();
    });
    return d.dispose;
  }
  function prepareTransition(node, {inFlight, prepare}) {
    (null == inFlight ? 0 : inFlight.current) ? prepare() : (inFlight = node.style.transition, node.style.transition = "none", prepare(), node.offsetHeight, node.style.transition = inFlight);
  }
  function hasPendingTransitions(node) {
    var _a3, _b2;
    return (null != (_b2 = null == (_a3 = node.getAnimations) ? void 0 : _a3.call(node)) ? _b2 : []).some(animation => animation instanceof CSSTransition && "finished" !== animation.playState);
  }
  function useTreeWalker(enabled, {container, accept, walk}) {
    let acceptRef = (0,import_react47.useRef)(accept), walkRef = (0,import_react47.useRef)(walk);
    (0,import_react47.useEffect)(() => {
      acceptRef.current = accept;
      walkRef.current = walk;
    }, [accept, walk]);
    useIsoMorphicEffect(() => {
      if (container && enabled) {
        var ownerDocument = getOwnerDocument(container);
        if (ownerDocument) {
          var accept2 = acceptRef.current, walk2 = walkRef.current, acceptNode = Object.assign(node => accept2(node), {acceptNode:accept2});
          for (ownerDocument = ownerDocument.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, acceptNode, !1); ownerDocument.nextNode();) {
            walk2(ownerDocument.currentNode);
          }
        }
      }
    }, [container, enabled, acceptRef, walkRef]);
  }
  function useWatch(cb, dependencies) {
    let track = (0,import_react48.useRef)([]), action = useEvent(cb);
    (0,import_react48.useEffect)(() => {
      var oldValues = [...track.current];
      for (let [idx, value] of dependencies.entries()) {
        if (track.current[idx] !== value) {
          return oldValues = action(dependencies, oldValues), track.current = dependencies, oldValues;
        }
      }
    }, [action, ...dependencies]);
  }
  function isElement2(value) {
    var JSCompiler_temp;
    if (!(JSCompiler_temp = value instanceof Element)) {
      var _node$ownerDocument;
      JSCompiler_temp = (null == value || null == (_node$ownerDocument = value.ownerDocument) ? void 0 : _node$ownerDocument.defaultView) || window;
      JSCompiler_temp = value instanceof JSCompiler_temp.Element;
    }
    return JSCompiler_temp;
  }
  function getUserAgent() {
    const uaData = navigator.userAgentData;
    return uaData && Array.isArray(uaData.brands) ? uaData.brands.map(_ref => {
      let {brand, version} = _ref;
      return brand + "/" + version;
    }).join(" ") : navigator.userAgent;
  }
  function evaluate(value, param) {
    return "function" === typeof value ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getOppositeAxis(axis) {
    return "x" === axis ? "y" : "x";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentSides(placement, rects, rtl) {
    void 0 === rtl && (rtl = !1);
    const alignment = placement.split("-")[1], alignmentAxis = getOppositeAxis(getSideAxis(placement));
    placement = "y" === alignmentAxis ? "height" : "width";
    rtl = "x" === alignmentAxis ? alignment === (rtl ? "end" : "start") ? "right" : "left" : "start" === alignment ? "bottom" : "top";
    rects.reference[placement] > rects.floating[placement] && (rtl = getOppositePlacement(rtl));
    return [rtl, getOppositePlacement(rtl)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"], rl = ["right", "left"], tb = ["top", "bottom"], bt = ["bottom", "top"];
    switch(side) {
      case "top":
      case "bottom":
        return rtl ? isStart ? rl : lr : isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = placement.split("-")[1];
    placement = getSideList(getSide(placement), "start" === direction, rtl);
    alignment && (placement = placement.map(side => side + "-" + alignment), flipAlignment && (placement = placement.concat(placement.map(getOppositeAlignmentPlacement))));
    return placement;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
  }
  function rectToClientRect(rect) {
    return {...rect, top:rect.y, left:rect.x, right:rect.x + rect.width, bottom:rect.y + rect.height};
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {reference, floating} = _ref;
    var sideAxis = getSideAxis(placement);
    _ref = getOppositeAxis(getSideAxis(placement));
    var alignLength = "y" === _ref ? "height" : "width", side = getSide(placement);
    sideAxis = "y" === sideAxis;
    const commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2;
    alignLength = reference[alignLength] / 2 - floating[alignLength] / 2;
    switch(side) {
      case "top":
        side = {x:commonX, y:reference.y - floating.height};
        break;
      case "bottom":
        side = {x:commonX, y:reference.y + reference.height};
        break;
      case "right":
        side = {x:reference.x + reference.width, y:commonY};
        break;
      case "left":
        side = {x:reference.x - floating.width, y:commonY};
        break;
      default:
        side = {x:reference.x, y:reference.y};
    }
    switch(placement.split("-")[1]) {
      case "start":
        side[_ref] -= alignLength * (rtl && sideAxis ? -1 : 1);
        break;
      case "end":
        side[_ref] += alignLength * (rtl && sideAxis ? -1 : 1);
    }
    return side;
  }
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    void 0 === options && (options = {});
    const {x, y, platform:platform2, rects, elements, strategy} = state, {boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = !1, padding = 0} = evaluate(options, state);
    state = "number" !== typeof padding ? {top:0, right:0, bottom:0, left:0, ...padding} : {top:padding, right:padding, bottom:padding, left:padding};
    var element = elements[altBoundary ? "floating" === elementContext ? "reference" : "floating" : elementContext];
    options = rectToClientRect(await platform2.getClippingRect({element:(null != (_await$platform$isEle = await (null == platform2.isElement ? void 0 : platform2.isElement(element))) ? _await$platform$isEle : 1) ? element : element.contextElement || await (null == platform2.getDocumentElement ? void 0 : platform2.getDocumentElement(elements.floating)), boundary, rootBoundary, strategy}));
    element = "floating" === elementContext ? {...rects.floating, x, y} : rects.reference;
    const offsetParent = await (null == platform2.getOffsetParent ? void 0 : platform2.getOffsetParent(elements.floating));
    _await$platform$isEle = await (null == platform2.isElement ? void 0 : platform2.isElement(offsetParent)) ? await (null == platform2.getScale ? void 0 : platform2.getScale(offsetParent)) || {x:1, y:1} : {x:1, y:1};
    element = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({rect:element, offsetParent, strategy}) : element);
    return {top:(options.top - element.top + state.top) / _await$platform$isEle.y, bottom:(element.bottom - options.bottom + state.bottom) / _await$platform$isEle.y, left:(options.left - element.left + state.left) / _await$platform$isEle.x, right:(element.right - options.right + state.right) / _await$platform$isEle.x};
  }
  async function convertValueToCoords(state, options) {
    const {placement, platform:platform2, elements} = state;
    var rtl = await (null == platform2.isRTL ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement);
    const alignment = placement.split("-")[1], isVertical = "y" === getSideAxis(placement);
    side = ["left", "top"].includes(side) ? -1 : 1;
    rtl = rtl && isVertical ? -1 : 1;
    state = evaluate(options, state);
    let {mainAxis, crossAxis, alignmentAxis} = "number" === typeof state ? {mainAxis:state, crossAxis:0, alignmentAxis:null} : {mainAxis:0, crossAxis:0, alignmentAxis:null, ...state};
    alignment && "number" === typeof alignmentAxis && (crossAxis = "end" === alignment ? -1 * alignmentAxis : alignmentAxis);
    return isVertical ? {x:crossAxis * rtl, y:mainAxis * side} : {x:mainAxis * side, y:crossAxis * rtl};
  }
  function getNodeName(node) {
    return isNode2(node) ? (node.nodeName || "").toLowerCase() : "#document";
  }
  function getWindow2(node) {
    var _node$ownerDocument;
    return (null == node ? void 0 : null == (_node$ownerDocument = node.ownerDocument) ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return null == (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) ? void 0 : _ref.documentElement;
  }
  function isNode2(value) {
    return value instanceof Node || value instanceof getWindow2(value).Node;
  }
  function isElement3(value) {
    return value instanceof Element || value instanceof getWindow2(value).Element;
  }
  function isHTMLElement2(value) {
    return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
  }
  function isShadowRoot(value) {
    return "undefined" === typeof ShadowRoot ? !1 : value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {overflow, overflowX, overflowY, display} = getComputedStyle2(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isContainingBlock(element) {
    const webkit = isWebKit(), css = getComputedStyle2(element);
    return "none" !== css.transform || "none" !== css.perspective || (css.containerType ? "normal" !== css.containerType : !1) || !webkit && (css.backdropFilter ? "none" !== css.backdropFilter : !1) || !webkit && (css.filter ? "none" !== css.filter : !1) || ["transform", "perspective", "filter"].some(value => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some(value => (css.contain || "").includes(value));
  }
  function isWebKit() {
    return "undefined" !== typeof CSS && CSS.supports ? CSS.supports("-webkit-backdrop-filter", "none") : !1;
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle2(element) {
    return getWindow2(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    return isElement3(element) ? {scrollLeft:element.scrollLeft, scrollTop:element.scrollTop} : {scrollLeft:element.pageXOffset, scrollTop:element.pageYOffset};
  }
  function getParentNode(node) {
    if ("html" === getNodeName(node)) {
      return node;
    }
    node = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
    return isShadowRoot(node) ? node.host : node;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    return isLastTraversableNode(parentNode) ? node.ownerDocument ? node.ownerDocument.body : node.body : isHTMLElement2(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    void 0 === list && (list = []);
    void 0 === traverseIframes && (traverseIframes = !0);
    const scrollableAncestor = getNearestOverflowAncestor(node);
    node = scrollableAncestor === (null == (_node$ownerDocument2 = node.ownerDocument) ? void 0 : _node$ownerDocument2.body);
    _node$ownerDocument2 = getWindow2(scrollableAncestor);
    return node ? list.concat(_node$ownerDocument2, _node$ownerDocument2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], _node$ownerDocument2.frameElement && traverseIframes ? getOverflowAncestors(_node$ownerDocument2.frameElement) : []) : list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getCssDimensions(element) {
    var css = getComputedStyle2(element);
    let width = parseFloat(css.width) || 0;
    css = parseFloat(css.height) || 0;
    var hasOffset = isHTMLElement2(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    element = hasOffset ? element.offsetHeight : css;
    if (hasOffset = round(width) !== offsetWidth || round(css) !== element) {
      width = offsetWidth, css = element;
    }
    return {width, height:css, $:hasOffset};
  }
  function unwrapElement(element) {
    return isElement3(element) ? element : element.contextElement;
  }
  function getScale(element) {
    var domElement = unwrapElement(element);
    if (!isHTMLElement2(domElement)) {
      return {x:1, y:1};
    }
    element = domElement.getBoundingClientRect();
    const {width, height, $} = getCssDimensions(domElement);
    domElement = ($ ? round(element.width) : element.width) / width;
    element = ($ ? round(element.height) : element.height) / height;
    domElement && Number.isFinite(domElement) || (domElement = 1);
    element && Number.isFinite(element) || (element = 1);
    return {x:domElement, y:element};
  }
  function getVisualOffsets(element) {
    element = getWindow2(element);
    return isWebKit() && element.visualViewport ? {x:element.visualViewport.offsetLeft, y:element.visualViewport.offsetTop} : noOffsets;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    void 0 === includeScale && (includeScale = !1);
    void 0 === isFixedStrategy && (isFixedStrategy = !1);
    var clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element), scale = {x:1, y:1};
    includeScale && (offsetParent ? isElement3(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));
    element = isFixedStrategy;
    void 0 === element && (element = !1);
    element = !offsetParent || element && offsetParent !== getWindow2(domElement) ? !1 : element;
    includeScale = element ? getVisualOffsets(domElement) : {x:0, y:0};
    element = (clientRect.left + includeScale.x) / scale.x;
    includeScale = (clientRect.top + includeScale.y) / scale.y;
    isFixedStrategy = clientRect.width / scale.x;
    clientRect = clientRect.height / scale.y;
    if (domElement) {
      domElement = getWindow2(domElement);
      scale = offsetParent && isElement3(offsetParent) ? getWindow2(offsetParent) : offsetParent;
      let currentIFrame = domElement.frameElement;
      for (; currentIFrame && offsetParent && scale !== domElement;) {
        const iframeScale = getScale(currentIFrame);
        var iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle2(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        iframeRect = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        element *= iframeScale.x;
        includeScale *= iframeScale.y;
        isFixedStrategy *= iframeScale.x;
        clientRect *= iframeScale.y;
        element += left;
        includeScale += iframeRect;
        currentIFrame = getWindow2(currentIFrame).frameElement;
      }
    }
    return rectToClientRect({width:isFixedStrategy, height:clientRect, x:element, y:includeScale});
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    if ("viewport" === clippingAncestor) {
      clippingAncestor = getWindow2(element);
      var html = getDocumentElement(element);
      clippingAncestor = clippingAncestor.visualViewport;
      element = html.clientWidth;
      html = html.clientHeight;
      var x = 0, y = 0;
      if (clippingAncestor) {
        element = clippingAncestor.width;
        html = clippingAncestor.height;
        var visualViewportBased = isWebKit();
        if (!visualViewportBased || visualViewportBased && "fixed" === strategy) {
          x = clippingAncestor.offsetLeft, y = clippingAncestor.offsetTop;
        }
      }
      strategy = {width:element, height:html, x, y};
    } else {
      "document" === clippingAncestor ? (visualViewportBased = getDocumentElement(element), strategy = getDocumentElement(visualViewportBased), x = getNodeScroll(visualViewportBased), clippingAncestor = visualViewportBased.ownerDocument.body, element = max(strategy.scrollWidth, strategy.clientWidth, clippingAncestor.scrollWidth, clippingAncestor.clientWidth), html = max(strategy.scrollHeight, strategy.clientHeight, clippingAncestor.scrollHeight, clippingAncestor.clientHeight), y = -x.scrollLeft, 
      visualViewportBased = getBoundingClientRect(getDocumentElement(visualViewportBased)).left + getNodeScroll(visualViewportBased).scrollLeft, y += visualViewportBased, x = -x.scrollTop, "rtl" === getComputedStyle2(clippingAncestor).direction && (y += max(strategy.clientWidth, clippingAncestor.clientWidth) - element), strategy = {width:element, height:html, x:y, y:x}) : isElement3(clippingAncestor) ? (element = getBoundingClientRect(clippingAncestor, !0, "fixed" === strategy), strategy = element.top + 
      clippingAncestor.clientTop, element = element.left + clippingAncestor.clientLeft, html = isHTMLElement2(clippingAncestor) ? getScale(clippingAncestor) : {x:1, y:1}, strategy = {width:clippingAncestor.clientWidth * html.x, height:clippingAncestor.clientHeight * html.y, x:element * html.x, y:strategy * html.y}) : (strategy = getVisualOffsets(element), strategy = {...clippingAncestor, x:clippingAncestor.x - strategy.x, y:clippingAncestor.y - strategy.y});
    }
    return rectToClientRect(strategy);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    element = getParentNode(element);
    return element === stopNode || !isElement3(element) || isLastTraversableNode(element) ? !1 : "fixed" === getComputedStyle2(element).position || hasFixedPositionAncestor(element, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    var cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    cachedResult = getOverflowAncestors(element, [], !1).filter(el => isElement3(el) && "body" !== getNodeName(el));
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = "fixed" === getComputedStyle2(element).position;
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    for (; isElement3(currentNode) && !isLastTraversableNode(currentNode);) {
      const computedStyle = getComputedStyle2(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
      currentNodeIsContaining || "fixed" !== computedStyle.position || (currentContainingBlockComputedStyle = null);
      (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && "static" === computedStyle.position && currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? cachedResult = cachedResult.filter(ancestor => ancestor !== currentNode) : currentContainingBlockComputedStyle = 
      computedStyle;
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, cachedResult);
    return cachedResult;
  }
  function getTrueOffsetParent(element, polyfill) {
    return isHTMLElement2(element) && "fixed" !== getComputedStyle2(element).position ? polyfill ? polyfill(element) : element.offsetParent : null;
  }
  function getOffsetParent(element, polyfill) {
    const window2 = getWindow2(element);
    if (!isHTMLElement2(element)) {
      return window2;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    for (; offsetParent && ["table", "td", "th"].includes(getNodeName(offsetParent)) && "static" === getComputedStyle2(offsetParent).position;) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && ("html" === getNodeName(offsetParent) || "body" === getNodeName(offsetParent) && "static" === getComputedStyle2(offsetParent).position && !isContainingBlock(offsetParent))) {
      return window2;
    }
    if (!(polyfill = offsetParent)) {
      a: {
        for (element = getParentNode(element); isHTMLElement2(element) && !isLastTraversableNode(element);) {
          if (isContainingBlock(element)) {
            polyfill = element;
            break a;
          } else {
            element = getParentNode(element);
          }
        }
        polyfill = null;
      }
    }
    return polyfill || window2;
  }
  function observeMove(element, onMove) {
    function cleanup() {
      clearTimeout(timeoutId);
      io && io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      function handleObserve(entries) {
        entries = entries[0].intersectionRatio;
        if (entries !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          entries ? refresh(!1, entries) : timeoutId = setTimeout(() => {
            refresh(!1, 1e-7);
          }, 100);
        }
        isFirstUpdate = !1;
      }
      void 0 === skip && (skip = !1);
      void 0 === threshold && (threshold = 1);
      cleanup();
      const {left, top, width, height} = element.getBoundingClientRect();
      skip || onMove();
      if (width && height) {
        skip = floor(top);
        var insetRight = floor(root.clientWidth - (left + width)), insetBottom = floor(root.clientHeight - (top + height)), insetLeft = floor(left);
        skip = {rootMargin:-skip + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px", threshold:max(0, min(1, threshold)) || 1};
        var isFirstUpdate = !0;
        try {
          io = new IntersectionObserver(handleObserve, {...skip, root:root.ownerDocument});
        } catch (e) {
          io = new IntersectionObserver(handleObserve, skip);
        }
        io.observe(element);
      }
    }
    let io = null, timeoutId;
    const root = getDocumentElement(element);
    refresh(!0);
    return cleanup;
  }
  function autoUpdate(reference, floating, update, options) {
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      !prevRefRect || nextRefRect.x === prevRefRect.x && nextRefRect.y === prevRefRect.y && nextRefRect.width === prevRefRect.width && nextRefRect.height === prevRefRect.height || update();
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    void 0 === options && (options = {});
    const {ancestorScroll = !0, ancestorResize = !0, elementResize = "function" === typeof ResizeObserver, layoutShift = "function" === typeof IntersectionObserver, animationFrame = !1} = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {passive:!0});
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1, resizeObserver = null;
    elementResize && (resizeObserver = new ResizeObserver(_ref => {
      [_ref] = _ref;
      _ref && _ref.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
        resizeObserver && resizeObserver.observe(floating);
      }));
      update();
    }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
    let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    animationFrame && frameLoop();
    update();
    return () => {
      ancestors.forEach(ancestor => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo && cleanupIo();
      resizeObserver && resizeObserver.disconnect();
      resizeObserver = null;
      animationFrame && cancelAnimationFrame(frameId);
    };
  }
  function deepEqual(a, b) {
    if (a === b) {
      return !0;
    }
    if (typeof a !== typeof b) {
      return !1;
    }
    if ("function" === typeof a && a.toString() === b.toString()) {
      return !0;
    }
    let i, keys;
    if (a && b && "object" === typeof a) {
      if (Array.isArray(a)) {
        var length = a.length;
        if (length !== b.length) {
          return !1;
        }
        for (i = length; 0 !== i--;) {
          if (!deepEqual(a[i], b[i])) {
            return !1;
          }
        }
        return !0;
      }
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) {
        return !1;
      }
      for (i = length; 0 !== i--;) {
        if (!{}.hasOwnProperty.call(b, keys[i])) {
          return !1;
        }
      }
      for (i = length; 0 !== i--;) {
        if (length = keys[i], !("_owner" === length && a.$$typeof || deepEqual(a[length], b[length]))) {
          return !1;
        }
      }
      return !0;
    }
    return a !== a && b !== b;
  }
  function getDPR(element) {
    return "undefined" === typeof window ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
  }
  function roundByDPR(element, value) {
    element = getDPR(element);
    return Math.round(value * element) / element;
  }
  function useLatestRef(value) {
    const ref = React12.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }
  function useFloating(options) {
    void 0 === options && (options = {});
    const {placement = "bottom", strategy = "absolute", middleware = [], platform:platform2, elements:{reference:externalReference, floating:externalFloating} = {}, transform = !0, whileElementsMounted, open} = options, [data, setData] = React12.useState({x:0, y:0, strategy, placement, middlewareData:{}, isPositioned:!1}), [latestMiddleware, setLatestMiddleware] = React12.useState(middleware);
    deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware);
    const [_reference, _setReference] = React12.useState(null), [_floating, _setFloating] = React12.useState(null), setReference = React12.useCallback(node => {
      node !== referenceRef.current && (referenceRef.current = node, _setReference(node));
    }, []), setFloating = React12.useCallback(node => {
      node !== floatingRef.current && (floatingRef.current = node, _setFloating(node));
    }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React12.useRef(null), floatingRef = React12.useRef(null), dataRef = React12.useRef(data);
    options = null != whileElementsMounted;
    const whileElementsMountedRef = useLatestRef(whileElementsMounted), platformRef = useLatestRef(platform2), update = React12.useCallback(() => {
      if (referenceRef.current && floatingRef.current) {
        var config = {placement, strategy, middleware:latestMiddleware};
        platformRef.current && (config.platform = platformRef.current);
        computePosition2(referenceRef.current, floatingRef.current, config).then(data2 => {
          const fullData = {...data2, isPositioned:!0};
          isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
            setData(fullData);
          }));
        });
      }
    }, [latestMiddleware, placement, strategy, platformRef]);
    index(() => {
      !1 === open && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData(data2 => ({...data2, isPositioned:!1})));
    }, [open]);
    const isMountedRef = React12.useRef(!1);
    index(() => {
      isMountedRef.current = !0;
      return () => {
        isMountedRef.current = !1;
      };
    }, []);
    index(() => {
      referenceEl && (referenceRef.current = referenceEl);
      floatingEl && (floatingRef.current = floatingEl);
      if (referenceEl && floatingEl) {
        if (whileElementsMountedRef.current) {
          return whileElementsMountedRef.current(referenceEl, floatingEl, update);
        }
        update();
      }
    }, [referenceEl, floatingEl, update, whileElementsMountedRef, options]);
    const refs = React12.useMemo(() => ({reference:referenceRef, floating:floatingRef, setReference, setFloating}), [setReference, setFloating]), elements = React12.useMemo(() => ({reference:referenceEl, floating:floatingEl}), [referenceEl, floatingEl]), floatingStyles = React12.useMemo(() => {
      const initialStyles = {position:strategy, left:0, top:0};
      if (!elements.floating) {
        return initialStyles;
      }
      const x = roundByDPR(elements.floating, data.x), y = roundByDPR(elements.floating, data.y);
      return transform ? {...initialStyles, transform:"translate(" + x + "px, " + y + "px)", ...(1.5 <= getDPR(elements.floating) && {willChange:"transform"})} : {position:strategy, left:x, top:y};
    }, [strategy, transform, elements.floating, data.x, data.y]);
    return React12.useMemo(() => ({...data, update, refs, elements, floatingStyles}), [data, update, refs, elements, floatingStyles]);
  }
  function useEffectEvent(callback) {
    const ref = React13.useRef(() => {
      throw Error("Cannot call an event handler while rendering.");
    });
    useSafeInsertionEffect(() => {
      ref.current = callback;
    });
    return React13.useCallback(function() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return null == ref.current ? void 0 : ref.current(...args);
    }, []);
  }
  function useFloatingId() {
    const [id, setId] = React13.useState(() => serverHandoffComplete ? genId() : void 0);
    index2(() => {
      null == id && setId(genId());
    }, []);
    React13.useEffect(() => {
      serverHandoffComplete = !0;
    }, []);
    return id;
  }
  function warn() {
    for (var _devMessageSet, _len = arguments.length, messages = Array(_len), _key = 0; _key < _len; _key++) {
      messages[_key] = arguments[_key];
    }
    _len = "Floating UI: " + messages.join(" ");
    if (null == (_devMessageSet = devMessageSet) || !_devMessageSet.has(_len)) {
      var _devMessageSet2;
      null == (_devMessageSet2 = devMessageSet) || _devMessageSet2.add(_len);
      console.warn(_len);
    }
  }
  function error() {
    for (var _devMessageSet3, _len2 = arguments.length, messages = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      messages[_key2] = arguments[_key2];
    }
    _len2 = "Floating UI: " + messages.join(" ");
    if (null == (_devMessageSet3 = devMessageSet) || !_devMessageSet3.has(_len2)) {
      var _devMessageSet4;
      null == (_devMessageSet4 = devMessageSet) || _devMessageSet4.add(_len2);
      console.error(_len2);
    }
  }
  function createPubSub() {
    const map = new Map();
    return {emit(event, data) {
      var _map$get;
      null == (_map$get = map.get(event)) || _map$get.forEach(handler => handler(data));
    }, on(event, listener) {
      map.set(event, [...(map.get(event) || []), listener]);
    }, off(event, listener) {
      var _map$get2;
      map.set(event, (null == (_map$get2 = map.get(event)) ? void 0 : _map$get2.filter(l => l !== listener)) || []);
    }};
  }
  function useFloatingRootContext(options) {
    const {open = !1, onOpenChange:onOpenChangeProp, elements:elementsProp} = options, floatingId = useId3(), dataRef = React13.useRef({}), [events] = React13.useState(() => createPubSub()), nested = null != useFloatingParentNodeId();
    (options = elementsProp.reference) && !isElement2(options) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    const [positionReference, setPositionReference] = React13.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {
      dataRef.current.openEvent = open2 ? event : void 0;
      events.emit("openchange", {open:open2, event, reason, nested});
      null == onOpenChangeProp || onOpenChangeProp(open2, event, reason);
    }), refs = React13.useMemo(() => ({setPositionReference}), []), elements = React13.useMemo(() => ({reference:positionReference || elementsProp.reference || null, floating:elementsProp.floating || null, domReference:elementsProp.reference}), [positionReference, elementsProp.reference, elementsProp.floating]);
    return React13.useMemo(() => ({dataRef, open, onOpenChange, elements, events, floatingId, refs}), [open, onOpenChange, elements, events, floatingId, refs]);
  }
  function useFloating2(options) {
    void 0 === options && (options = {});
    const {nodeId} = options;
    var internalRootContext = useFloatingRootContext({...options, elements:{reference:null, floating:null, ...options.elements}});
    const rootContext = options.rootContext || internalRootContext;
    internalRootContext = rootContext.elements;
    const [_domReference, setDomReference] = React13.useState(null), [positionReference, _setPositionReference] = React13.useState(null), domReference = (null == internalRootContext ? void 0 : internalRootContext.reference) || _domReference, domReferenceRef = React13.useRef(null), tree = React13.useContext(FloatingTreeContext);
    index2(() => {
      domReference && (domReferenceRef.current = domReference);
    }, [domReference]);
    const position = useFloating({...options, elements:{...internalRootContext, ...(positionReference && {reference:positionReference})}}), setPositionReference = React13.useCallback(node => {
      const computedPositionReference = isElement2(node) ? {getBoundingClientRect:() => node.getBoundingClientRect(), contextElement:node} : node;
      _setPositionReference(computedPositionReference);
      position.refs.setReference(computedPositionReference);
    }, [position.refs]), setReference = React13.useCallback(node => {
      if (isElement2(node) || null === node) {
        domReferenceRef.current = node, setDomReference(node);
      }
      (isElement2(position.refs.reference.current) || null === position.refs.reference.current || null !== node && !isElement2(node)) && position.refs.setReference(node);
    }, [position.refs]), refs = React13.useMemo(() => ({...position.refs, setReference, setPositionReference, domReference:domReferenceRef}), [position.refs, setReference, setPositionReference]), elements = React13.useMemo(() => ({...position.elements, domReference}), [position.elements, domReference]), context = React13.useMemo(() => ({...position, ...rootContext, refs, elements, nodeId}), [position, refs, elements, nodeId, rootContext]);
    index2(() => {
      rootContext.dataRef.current.floatingContext = context;
      const node = null == tree ? void 0 : tree.nodesRef.current.find(node2 => node2.id === nodeId);
      node && (node.context = context);
    });
    return React13.useMemo(() => ({...position, context, refs, elements}), [position, refs, elements, context]);
  }
  function mergeProps2(userProps, propsList, elementKey) {
    const map = new Map(), isItem = "item" === elementKey;
    let domUserProps = userProps;
    if (isItem && userProps) {
      const {active:_, selected:__, ...validProps} = userProps;
      domUserProps = validProps;
    }
    return {...("floating" === elementKey && {tabIndex:-1}), ...domUserProps, ...propsList.map(value => {
      value = value ? value[elementKey] : null;
      return "function" === typeof value ? userProps ? value(userProps) : null : value;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach(_ref => {
        let [key, value] = _ref;
        if (!isItem || !["active", "selected"].includes(key)) {
          if (0 === key.indexOf("on")) {
            if (map.has(key) || map.set(key, []), "function" === typeof value) {
              var _map$get;
              null == (_map$get = map.get(key)) || _map$get.push(value);
              acc[key] = function() {
                for (var _map$get2, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return null == (_map$get2 = map.get(key)) ? void 0 : _map$get2.map(fn => fn(...args)).find(val => void 0 !== val);
              };
            }
          } else {
            acc[key] = value;
          }
        }
      });
      return acc;
    }, {})};
  }
  function useInteractions(propsList) {
    void 0 === propsList && (propsList = []);
    const deps = propsList, getReferenceProps = React13.useCallback(userProps => mergeProps2(userProps, propsList, "reference"), deps), getFloatingProps = React13.useCallback(userProps => mergeProps2(userProps, propsList, "floating"), deps), getItemProps = React13.useCallback(userProps => mergeProps2(userProps, propsList, "item"), propsList.map(key => null == key ? void 0 : key.item));
    return React13.useMemo(() => ({getReferenceProps, getFloatingProps, getItemProps}), [getReferenceProps, getFloatingProps, getItemProps]);
  }
  function getArgsWithCustomFloatingHeight(state, height) {
    return {...state, rects:{...state.rects, floating:{...state.rects.floating, height}}};
  }
  function useInnerOffset(context, props) {
    const {open, elements} = context, {enabled = !0, overflowRef, scrollRef, onChange:unstable_onChange} = props, onChange = useEffectEvent(unstable_onChange), controlledScrollingRef = React13.useRef(!1), prevScrollTopRef = React13.useRef(null), initialOverflowRef = React13.useRef(null);
    React13.useEffect(() => {
      function onWheel(e) {
        if (!e.ctrlKey && el && null != overflowRef.current) {
          var dY = e.deltaY, isAtBottom = -0.5 <= overflowRef.current.bottom, remainingScroll = el.scrollHeight - el.clientHeight, sign = 0 > dY ? -1 : 1, method = 0 > dY ? "max" : "min";
          el.scrollHeight <= el.clientHeight || (!(-0.5 <= overflowRef.current.top) && 0 < dY || !isAtBottom && 0 > dY ? (e.preventDefault(), (0,import_react_dom6.flushSync)(() => {
            onChange(d => d + Math[method](dY, remainingScroll * sign));
          })) : /firefox/i.test(getUserAgent()) && (el.scrollTop += dY));
        }
      }
      if (enabled) {
        var el = (null == scrollRef ? void 0 : scrollRef.current) || elements.floating;
        if (open && el) {
          return el.addEventListener("wheel", onWheel), requestAnimationFrame(() => {
            prevScrollTopRef.current = el.scrollTop;
            null != overflowRef.current && (initialOverflowRef.current = {...overflowRef.current});
          }), () => {
            prevScrollTopRef.current = null;
            initialOverflowRef.current = null;
            el.removeEventListener("wheel", onWheel);
          };
        }
      }
    }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
    return React13.useMemo(() => enabled ? {floating:{onKeyDown() {
      controlledScrollingRef.current = !0;
    }, onWheel() {
      controlledScrollingRef.current = !1;
    }, onPointerMove() {
      controlledScrollingRef.current = !1;
    }, onScroll() {
      const el = (null == scrollRef ? void 0 : scrollRef.current) || elements.floating;
      if (overflowRef.current && el && controlledScrollingRef.current) {
        if (null !== prevScrollTopRef.current) {
          const scrollDiff = el.scrollTop - prevScrollTopRef.current;
          (-0.5 > overflowRef.current.bottom && -1 > scrollDiff || -0.5 > overflowRef.current.top && 1 < scrollDiff) && (0,import_react_dom6.flushSync)(() => onChange(d => d + scrollDiff));
        }
        requestAnimationFrame(() => {
          prevScrollTopRef.current = el.scrollTop;
        });
      }
    }}} : {}, [enabled, overflowRef, elements.floating, scrollRef, onChange]);
  }
  function useResolvedAnchor(anchor) {
    return (0,import_react52.useMemo)(() => anchor ? "string" === typeof anchor ? {to:anchor} : anchor : null, [anchor]);
  }
  function useFloatingReference() {
    return (0,import_react52.useContext)(FloatingContext).setReference;
  }
  function useFloatingPanelProps() {
    let {getFloatingProps, slot} = (0,import_react52.useContext)(FloatingContext);
    return (0,import_react52.useCallback)((...args) => Object.assign({}, getFloatingProps(...args), {"data-anchor":slot.anchor}), [getFloatingProps, slot]);
  }
  function useFloatingPanel(placement = null) {
    !1 === placement && (placement = null);
    "string" === typeof placement && (placement = {to:placement});
    let updatePlacementConfig = (0,import_react52.useContext)(PlacementContext), stablePlacement = (0,import_react52.useMemo)(() => placement, [JSON.stringify(placement, (_, v) => {
      var _a3;
      return null != (_a3 = null == v ? void 0 : v.outerHTML) ? _a3 : v;
    })]);
    useIsoMorphicEffect(() => {
      null == updatePlacementConfig || updatePlacementConfig(null != stablePlacement ? stablePlacement : null);
    }, [updatePlacementConfig, stablePlacement]);
    let context = (0,import_react52.useContext)(FloatingContext);
    return (0,import_react52.useMemo)(() => [context.setFloating, placement ? context.styles : {}], [context.setFloating, placement, context.styles]);
  }
  function FloatingProvider({children, enabled = !0}) {
    let [config, setConfig] = (0,import_react52.useState)(null), [innerOffset, setInnerOffset] = (0,import_react52.useState)(0);
    var overflowRef = (0,import_react52.useRef)(null);
    let [floatingEl, setFloatingElement] = (0,import_react52.useState)(null);
    useFixScrollingPixel(floatingEl);
    let isEnabled = enabled && null !== config && null !== floatingEl, {to:placement = "bottom", gap = 0, offset:offset3 = 0, padding = 0, inner:inner2} = useResolvedConfig(config, floatingEl), [to, align = "center"] = placement.split(" ");
    useIsoMorphicEffect(() => {
      isEnabled && setInnerOffset(0);
    }, [isEnabled]);
    let {refs, floatingStyles, context} = useFloating2({open:isEnabled, placement:"selection" === to ? "center" === align ? "bottom" : `bottom-${align}` : "center" === align ? `${to}` : `${to}-${align}`, strategy:"absolute", transform:!1, middleware:[offset2({mainAxis:"selection" === to ? 0 : gap, crossAxis:offset3}), shift2({padding}), "selection" !== to && flip2({padding}), "selection" === to && inner2 ? inner({...inner2, padding, overflowRef, offset:innerOffset, minItemsVisible:4, referenceOverflowThreshold:padding, 
    onFallbackChange(fallback) {
      var _a3, _b2;
      if (fallback && (fallback = context.elements.floating)) {
        var scrollPaddingBottom = parseFloat(getComputedStyle(fallback).scrollPaddingBottom) || 0, missing = Math.min(4, fallback.childElementCount), elementHeight = 0, elementAmountVisible = 0;
        for (let child of null != (_b2 = null == (_a3 = context.elements.floating) ? void 0 : _a3.childNodes) ? _b2 : []) {
          if (isHTMLElement(child)) {
            _a3 = child.offsetTop;
            _b2 = _a3 + child.clientHeight + scrollPaddingBottom;
            let parentTop = fallback.scrollTop, parentBottom = parentTop + fallback.clientHeight;
            if (_a3 >= parentTop && _b2 <= parentBottom) {
              missing--;
            } else {
              elementAmountVisible = Math.max(0, Math.min(_b2, parentBottom) - Math.max(_a3, parentTop));
              elementHeight = child.clientHeight;
              break;
            }
          }
        }
        1 <= missing && setInnerOffset(existingOffset => {
          let newInnerOffset = elementHeight * missing - elementAmountVisible + scrollPaddingBottom;
          return existingOffset >= newInnerOffset ? existingOffset : newInnerOffset;
        });
      }
    }}) : null, size2({padding, apply({availableWidth, availableHeight, elements}) {
      Object.assign(elements.floating.style, {overflow:"auto", maxWidth:`${availableWidth}px`, maxHeight:`min(var(--anchor-max-height, 100vh), ${availableHeight}px)`});
    }})].filter(Boolean), whileElementsMounted:autoUpdate}), [exposedTo = to, exposedAlign = align] = context.placement.split("-");
    "selection" === to && (exposedTo = "selection");
    enabled = (0,import_react52.useMemo)(() => ({anchor:[exposedTo, exposedAlign].filter(Boolean).join(" ")}), [exposedTo, exposedAlign]);
    overflowRef = useInnerOffset(context, {overflowRef, onChange:setInnerOffset});
    let {getReferenceProps, getFloatingProps} = useInteractions([overflowRef]);
    overflowRef = useEvent(el => {
      setFloatingElement(el);
      refs.setFloating(el);
    });
    return React14.createElement(PlacementContext.Provider, {value:setConfig}, React14.createElement(FloatingContext.Provider, {value:{setFloating:overflowRef, setReference:refs.setReference, styles:floatingStyles, getReferenceProps, getFloatingProps, slot:enabled}}, children));
  }
  function useFixScrollingPixel(element) {
    useIsoMorphicEffect(() => {
      if (element) {
        var observer = new MutationObserver(() => {
          var maxHeight = window.getComputedStyle(element).maxHeight;
          let maxHeightFloat = parseFloat(maxHeight);
          isNaN(maxHeightFloat) || (maxHeight = parseInt(maxHeight), isNaN(maxHeight) || maxHeightFloat === maxHeight || (element.style.maxHeight = `${Math.ceil(maxHeightFloat)}px`));
        });
        observer.observe(element, {attributes:!0, attributeFilter:["style"]});
        return () => {
          observer.disconnect();
        };
      }
    }, [element]);
  }
  function useResolvedConfig(config, element) {
    var _a3, _b2, _c;
    let gap = useResolvePxValue(null != (_a3 = null == config ? void 0 : config.gap) ? _a3 : "var(--anchor-gap, 0)", element);
    _a3 = useResolvePxValue(null != (_b2 = null == config ? void 0 : config.offset) ? _b2 : "var(--anchor-offset, 0)", element);
    _b2 = useResolvePxValue(null != (_c = null == config ? void 0 : config.padding) ? _c : "var(--anchor-padding, 0)", element);
    return {...config, gap, offset:_a3, padding:_b2};
  }
  function useResolvePxValue(input, element, defaultValue) {
    let d = useDisposables(), computeValue = useEvent((value2, element2) => {
      if (null == value2) {
        return [defaultValue, null];
      }
      if ("number" === typeof value2) {
        return [value2, null];
      }
      if ("string" === typeof value2) {
        if (!element2) {
          return [defaultValue, null];
        }
        let result = resolveCSSVariablePxValue(value2, element2);
        return [result, setValue2 => {
          let variables = resolveVariables(value2), history2 = variables.map(variable => window.getComputedStyle(element2).getPropertyValue(variable));
          d.requestAnimationFrame(function check() {
            d.nextFrame(check);
            var changed = !1;
            for (let [idx, variable] of variables.entries()) {
              let value3 = window.getComputedStyle(element2).getPropertyValue(variable);
              if (history2[idx] !== value3) {
                history2[idx] = value3;
                changed = !0;
                break;
              }
            }
            changed && (changed = resolveCSSVariablePxValue(value2, element2), result !== changed && (setValue2(changed), result = changed));
          });
          return d.dispose;
        }];
      }
      return [defaultValue, null];
    }), immediateValue = (0,import_react52.useMemo)(() => computeValue(input, element)[0], [input, element]), [value = immediateValue, setValue] = (0,import_react52.useState)();
    useIsoMorphicEffect(() => {
      let [value2, watcher] = computeValue(input, element);
      setValue(value2);
      if (watcher) {
        return watcher(setValue);
      }
    }, [input, element]);
    return value;
  }
  function resolveVariables(value) {
    var matches = /var\((.*)\)/.exec(value);
    if (matches) {
      let idx = matches[1].indexOf(",");
      if (-1 === idx) {
        return [matches[1]];
      }
      value = matches[1].slice(0, idx).trim();
      return (matches = matches[1].slice(idx + 1).trim()) ? [value, ...resolveVariables(matches)] : [value];
    }
    return [];
  }
  function resolveCSSVariablePxValue(input, element) {
    let tmpEl = document.createElement("div");
    element.appendChild(tmpEl);
    tmpEl.style.setProperty("margin-top", "0px", "important");
    tmpEl.style.setProperty("margin-top", input, "important");
    input = parseFloat(window.getComputedStyle(tmpEl).marginTop) || 0;
    element.removeChild(tmpEl);
    return input;
  }
  function useFrozenData(freeze, data) {
    let [frozenValue, setFrozenValue] = (0,import_react53.useState)(data);
    freeze || frozenValue === data || setFrozenValue(data);
    return freeze ? frozenValue : data;
  }
  function useOpenClosed() {
    return (0,import_react54.useContext)(Context);
  }
  function OpenClosedProvider({value, children}) {
    return import_react54.default.createElement(Context.Provider, {value}, children);
  }
  function ResetOpenClosedProvider({children}) {
    return import_react54.default.createElement(Context.Provider, {value:null}, children);
  }
  function calculateActiveIndex(action, resolvers) {
    let items = resolvers.resolveItems();
    if (0 >= items.length) {
      return null;
    }
    let currentActiveIndex = resolvers.resolveActiveIndex();
    var activeIndex = null != currentActiveIndex ? currentActiveIndex : -1;
    switch(action.focus) {
      case 0:
        for (action = 0; action < items.length; ++action) {
          if (!resolvers.resolveDisabled(items[action], action, items)) {
            return action;
          }
        }
        return currentActiveIndex;
      case 1:
        -1 === activeIndex && (activeIndex = items.length);
        for (action = activeIndex - 1; 0 <= action; --action) {
          if (!resolvers.resolveDisabled(items[action], action, items)) {
            return action;
          }
        }
        return currentActiveIndex;
      case 2:
        for (action = activeIndex + 1; action < items.length; ++action) {
          if (!resolvers.resolveDisabled(items[action], action, items)) {
            return action;
          }
        }
        return currentActiveIndex;
      case 3:
        for (action = items.length - 1; 0 <= action; --action) {
          if (!resolvers.resolveDisabled(items[action], action, items)) {
            return action;
          }
        }
        return currentActiveIndex;
      case 4:
        for (activeIndex = 0; activeIndex < items.length; ++activeIndex) {
          if (resolvers.resolveId(items[activeIndex], activeIndex, items) === action.id) {
            return activeIndex;
          }
        }
        return currentActiveIndex;
      case 5:
        return null;
      default:
        throw Error("Unexpected object: " + action);
    }
  }
  function useOnUnmount(cb) {
    let stableCb = useEvent(cb), trulyUnmounted = (0,import_react55.useRef)(!1);
    (0,import_react55.useEffect)(() => {
      trulyUnmounted.current = !1;
      return () => {
        trulyUnmounted.current = !0;
        microTask(() => {
          trulyUnmounted.current && stableCb();
        });
      };
    }, [stableCb]);
  }
  function ForcePortalRoot(props) {
    return import_react56.default.createElement(ForcePortalRootContext.Provider, {value:props.force}, props.children);
  }
  function usePortalTarget(ownerDocument) {
    let forceInRoot = (0,import_react56.useContext)(ForcePortalRootContext), groupTarget = (0,import_react57.useContext)(PortalGroupContext), [target, setTarget] = (0,import_react57.useState)(() => {
      var _a3;
      if (!forceInRoot && null !== groupTarget) {
        return null != (_a3 = groupTarget.current) ? _a3 : null;
      }
      if (env.isServer) {
        return null;
      }
      if (_a3 = null == ownerDocument ? void 0 : ownerDocument.getElementById("headlessui-portal-root")) {
        return _a3;
      }
      if (null === ownerDocument) {
        return null;
      }
      _a3 = ownerDocument.createElement("div");
      _a3.setAttribute("id", "headlessui-portal-root");
      return ownerDocument.body.appendChild(_a3);
    });
    (0,import_react57.useEffect)(() => {
      null !== target && ((null == ownerDocument ? 0 : ownerDocument.body.contains(target)) || null == ownerDocument || ownerDocument.body.appendChild(target));
    }, [target, ownerDocument]);
    (0,import_react57.useEffect)(() => {
      forceInRoot || null !== groupTarget && setTarget(groupTarget.current);
    }, [groupTarget, setTarget, forceInRoot]);
    return target;
  }
  function useNestedPortals() {
    let parent = (0,import_react57.useContext)(PortalParentContext), portals = (0,import_react57.useRef)([]), register = useEvent(portal => {
      portals.current.push(portal);
      parent && parent.register(portal);
      return () => unregister(portal);
    }), unregister = useEvent(portal => {
      let idx = portals.current.indexOf(portal);
      -1 !== idx && portals.current.splice(idx, 1);
      parent && parent.unregister(portal);
    }), api = (0,import_react57.useMemo)(() => ({register, unregister, portals}), [register, unregister, portals]);
    return [portals, (0,import_react57.useMemo)(() => function({children}) {
      return import_react57.default.createElement(PortalParentContext.Provider, {value:api}, children);
    }, [api])];
  }
  function computeVisualPosition(element) {
    element = element.getBoundingClientRect();
    return `${element.x},${element.y}`;
  }
  function detectMovement(target, state, onMove) {
    let d = disposables();
    if ("Tracked" === state.kind) {
      let check2 = function() {
        position !== computeVisualPosition(target) && (d.dispose(), onMove());
      }, {position} = state, observer = new ResizeObserver(check2);
      observer.observe(target);
      d.add(() => observer.disconnect());
      d.addEventListener(window, "scroll", check2, {passive:!0});
      d.addEventListener(window, "resize", check2);
    }
    return () => d.dispose();
  }
  function adjustOrderedState(state, adjustment = i => i) {
    var currentActiveOption = null !== state.activeOptionIndex ? state.options[state.activeOptionIndex] : null;
    state = adjustment(state.options.slice());
    state = 0 < state.length && null !== state[0].dataRef.current.order ? state.sort((a, z) => a.dataRef.current.order - z.dataRef.current.order) : sortByDomNode(state, option => option.dataRef.current.domRef.current);
    currentActiveOption = currentActiveOption ? state.indexOf(currentActiveOption) : null;
    -1 === currentActiveOption && (currentActiveOption = null);
    return {options:state, activeOptionIndex:currentActiveOption};
  }
  function useComboboxMachineContext(component) {
    let context = (0,import_react58.useContext)(ComboboxContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Combobox /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useComboboxMachine), component;
    }
    return context;
  }
  function useComboboxMachine({id, virtual = null, __demoMode = !1}) {
    let machine = (0,import_react58.useMemo)(() => ComboboxMachine.new({id, virtual, __demoMode}), []);
    useOnUnmount(() => machine.dispose());
    return machine;
  }
  function useData(component) {
    let context = (0,import_react59.useContext)(ComboboxDataContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Combobox /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useData), component;
    }
    return context;
  }
  function VirtualProvider(props) {
    let machine = useComboboxMachineContext("VirtualProvider");
    var data = useData("VirtualProvider");
    let {options} = data.virtual, optionsElement = useSlice(machine, state => state.optionsElement), [paddingStart, paddingEnd] = (0,import_react59.useMemo)(() => {
      if (!optionsElement) {
        return [0, 0];
      }
      let styles = window.getComputedStyle(optionsElement);
      return [parseFloat(styles.paddingBlockStart || styles.paddingTop), parseFloat(styles.paddingBlockEnd || styles.paddingBottom)];
    }, [optionsElement]), virtualizer = useVirtualizerBase({observeElementRect, observeElementOffset, scrollToFn:elementScroll, enabled:0 !== options.length, scrollPaddingStart:paddingStart, scrollPaddingEnd:paddingEnd, count:options.length, estimateSize() {
      return 40;
    }, getScrollElement() {
      return machine.state.optionsElement;
    }, overscan:12}), [baseKey, setBaseKey] = (0,import_react59.useState)(0);
    useIsoMorphicEffect(() => {
      setBaseKey(v => v + 1);
    }, [options]);
    data = virtualizer.getVirtualItems();
    let isPointerActivationTrigger = useSlice(machine, state => 0 === state.activationTrigger), activeOptionIndex = useSlice(machine, machine.selectors.activeOptionIndex);
    return 0 === data.length ? null : import_react59.default.createElement(VirtualContext.Provider, {value:virtualizer}, import_react59.default.createElement("div", {style:{position:"relative", width:"100%", height:`${virtualizer.getTotalSize()}px`}, ref:el => {
      el && (isPointerActivationTrigger || null !== activeOptionIndex && options.length > activeOptionIndex && virtualizer.scrollToIndex(activeOptionIndex));
    }}, data.map(item => {
      var _a3;
      return import_react59.default.createElement(import_react59.Fragment, {key:item.key}, import_react59.default.cloneElement(null == (_a3 = props.children) ? void 0 : _a3.call(props, {...props.slot, option:options[item.index]}), {key:`${baseKey}-${item.key}`, "data-index":item.index, "aria-setsize":options.length, "aria-posinset":item.index + 1, style:{position:"absolute", top:0, left:0, transform:`translateY(${item.start}px)`, overflowAnchor:"none"}}));
    })));
  }
  function useEscape(enabled, view = "undefined" !== typeof document ? document.defaultView : null, cb) {
    let isTopLayer = useIsTopLayer(enabled, "escape");
    useEventListener(view, "keydown", event => {
      isTopLayer && (event.defaultPrevented || "Escape" === event.key && cb(event));
    });
  }
  function useIsTouchDevice() {
    var _a3;
    let [mq] = (0,import_react61.useState)(() => "undefined" !== typeof window && "function" === typeof window.matchMedia ? window.matchMedia("(pointer: coarse)") : null), [isTouchDevice, setIsTouchDevice] = (0,import_react61.useState)(null != (_a3 = null == mq ? void 0 : mq.matches) ? _a3 : !1);
    useIsoMorphicEffect(() => {
      function handle(event) {
        setIsTouchDevice(event.matches);
      }
      if (mq) {
        return mq.addEventListener("change", handle), () => mq.removeEventListener("change", handle);
      }
    }, [mq]);
    return isTouchDevice;
  }
  function useRootContainers({defaultContainers = [], portals, mainTreeNode} = {}) {
    let resolveContainers2 = useEvent(() => {
      var _a3, _b2;
      let ownerDocument = getOwnerDocument(mainTreeNode), containers = [];
      for (let container of defaultContainers) {
        null !== container && (isElement(container) ? containers.push(container) : "current" in container && isElement(container.current) && containers.push(container.current));
      }
      if (null == portals ? 0 : portals.current) {
        for (let portal of portals.current) {
          containers.push(portal);
        }
      }
      for (let container of null != (_a3 = null == ownerDocument ? void 0 : ownerDocument.querySelectorAll("html \x3e *, body \x3e *")) ? _a3 : []) {
        if (container !== document.body && container !== document.head && isElement(container) && "headlessui-portal-root" !== container.id) {
          if (mainTreeNode) {
            if (container.contains(mainTreeNode)) {
              continue;
            }
            if (container.contains(null == (_b2 = null == mainTreeNode ? void 0 : mainTreeNode.getRootNode()) ? void 0 : _b2.host)) {
              continue;
            }
          }
          containers.some(defaultContainer => container.contains(defaultContainer)) || containers.push(container);
        }
      }
      return containers;
    });
    return {resolveContainers:resolveContainers2, contains:useEvent(element => resolveContainers2().some(container => container.contains(element)))};
  }
  function MainTreeProvider({children, node}) {
    let [mainTreeNode, setMainTreeNode] = (0,import_react62.useState)(null);
    node = useMainTreeNode(null != node ? node : mainTreeNode);
    return import_react62.default.createElement(MainTreeContext.Provider, {value:node}, children, null === node && import_react62.default.createElement(Hidden, {features:4, ref:el => {
      var _a3, _b2;
      if (el) {
        for (let container of null != (_b2 = null == (_a3 = getOwnerDocument(el)) ? void 0 : _a3.querySelectorAll("html \x3e *, body \x3e *")) ? _b2 : []) {
          if (container !== document.body && container !== document.head && isElement(container) && (null == container ? 0 : container.contains(el))) {
            setMainTreeNode(container);
            break;
          }
        }
      }
    }}));
  }
  function useMainTreeNode(fallbackMainTreeNode = null) {
    var _a3;
    return null != (_a3 = (0,import_react62.useContext)(MainTreeContext)) ? _a3 : fallbackMainTreeNode;
  }
  function useIsHydratingInReact18() {
    let isServer = "undefined" === typeof document;
    if (!("useSyncExternalStore" in React21)) {
      return !1;
    }
    const useSyncExternalStore2 = React21.useSyncExternalStore;
    return useSyncExternalStore2(() => () => {
    }, () => !1, () => isServer ? !1 : !0);
  }
  function useServerHandoffComplete() {
    let isHydrating = useIsHydratingInReact18(), [complete, setComplete] = React21.useState(env.isHandoffComplete);
    complete && !1 === env.isHandoffComplete && setComplete(!1);
    React21.useEffect(() => {
      !0 !== complete && setComplete(!0);
    }, [complete]);
    React21.useEffect(() => env.handoff(), []);
    return isHydrating ? !1 : complete;
  }
  function useIsMounted() {
    let mounted = (0,import_react63.useRef)(!1);
    useIsoMorphicEffect(() => {
      mounted.current = !0;
      return () => {
        mounted.current = !1;
      };
    }, []);
    return mounted;
  }
  function useTabDirection() {
    let direction = (0,import_react64.useRef)(0);
    useWindowEvent(!0, "keydown", event => {
      "Tab" === event.key && (direction.current = event.shiftKey ? 1 : 0);
    }, !0);
    return direction;
  }
  function resolveContainers(containers) {
    if (!containers) {
      return new Set();
    }
    if ("function" === typeof containers) {
      return new Set(containers());
    }
    let all = new Set();
    for (let container of containers.current) {
      isElement(container.current) && all.add(container.current);
    }
    return all;
  }
  function useRestoreElement(enabled = !0) {
    let localHistory = (0,import_react65.useRef)(history.slice());
    useWatch(([newEnabled], [oldEnabled]) => {
      !0 === oldEnabled && !1 === newEnabled && microTask(() => {
        localHistory.current.splice(0);
      });
      !1 === oldEnabled && !0 === newEnabled && (localHistory.current = history.slice());
    }, [enabled, history, localHistory]);
    return useEvent(() => {
      var _a3;
      return null != (_a3 = localHistory.current.find(x => null != x && x.isConnected)) ? _a3 : null;
    });
  }
  function useRestoreFocus(features, {ownerDocument}) {
    let enabled = !!(features & 8), getRestoreElement = useRestoreElement(enabled);
    useWatch(() => {
      enabled || isActiveElement(null == ownerDocument ? void 0 : ownerDocument.body) && focusElement(getRestoreElement());
    }, [enabled]);
    useOnUnmount(() => {
      enabled && focusElement(getRestoreElement());
    });
  }
  function useInitialFocus(features, {ownerDocument, container, initialFocus, initialFocusFallback}) {
    let previousActiveElement = (0,import_react65.useRef)(null), enabled = useIsTopLayer(!!(features & 1), "focus-trap#initial-focus"), mounted = useIsMounted();
    useWatch(() => {
      if (0 !== features) {
        if (enabled) {
          var containerElement = container.current;
          containerElement && microTask(() => {
            if (mounted.current) {
              var activeElement2 = null == ownerDocument ? void 0 : ownerDocument.activeElement;
              if (null == initialFocus ? 0 : initialFocus.current) {
                if ((null == initialFocus ? void 0 : initialFocus.current) === activeElement2) {
                  previousActiveElement.current = activeElement2;
                  return;
                }
              } else if (containerElement.contains(activeElement2)) {
                previousActiveElement.current = activeElement2;
                return;
              }
              if (null == initialFocus ? 0 : initialFocus.current) {
                focusElement(initialFocus.current);
              } else {
                if (features & 16) {
                  if (0 !== focusIn(containerElement, 65)) {
                    return;
                  }
                } else if (0 !== focusIn(containerElement, 1)) {
                  return;
                }
                if (null == initialFocusFallback ? 0 : initialFocusFallback.current) {
                  if (focusElement(initialFocusFallback.current), (null == ownerDocument ? void 0 : ownerDocument.activeElement) === initialFocusFallback.current) {
                    return;
                  }
                }
                console.warn("There are no focusable elements inside the \x3cFocusTrap /\x3e");
              }
              previousActiveElement.current = null == ownerDocument ? void 0 : ownerDocument.activeElement;
            }
          });
        } else {
          (null == initialFocusFallback ? 0 : initialFocusFallback.current) && focusElement(initialFocusFallback.current);
        }
      }
    }, [initialFocusFallback, enabled, features]);
    return previousActiveElement;
  }
  function useFocusLock(features, {ownerDocument, container, containers, previousActiveElement}) {
    let mounted = useIsMounted(), enabled = !!(features & 4);
    useEventListener(null == ownerDocument ? void 0 : ownerDocument.defaultView, "focus", event => {
      if (enabled && mounted.current) {
        var allContainers = resolveContainers(containers);
        isHTMLElement(container.current) && allContainers.add(container.current);
        var previous = previousActiveElement.current;
        if (previous) {
          var toElement = event.target;
          isHTMLElement(toElement) ? contains2(allContainers, toElement) ? (previousActiveElement.current = toElement, focusElement(toElement)) : (event.preventDefault(), event.stopPropagation(), focusElement(previous)) : focusElement(previousActiveElement.current);
        }
      }
    }, !0);
  }
  function contains2(containers, element) {
    for (let container of containers) {
      if (container.contains(element)) {
        return !0;
      }
    }
    return !1;
  }
  function shouldForwardRef(props) {
    var _a3;
    return !!(props.enter || props.enterFrom || props.enterTo || props.leave || props.leaveFrom || props.leaveTo) || !isFragment(null != (_a3 = props.as) ? _a3 : DEFAULT_TRANSITION_CHILD_TAG) || 1 === import_react66.default.Children.count(props.children);
  }
  function useTransitionContext() {
    let context = (0,import_react66.useContext)(TransitionContext);
    if (null === context) {
      throw Error("A \x3cTransition.Child /\x3e is used but it is missing a parent \x3cTransition /\x3e or \x3cTransition.Root /\x3e.");
    }
    return context;
  }
  function useParentNesting() {
    let context = (0,import_react66.useContext)(NestingContext);
    if (null === context) {
      throw Error("A \x3cTransition.Child /\x3e is used but it is missing a parent \x3cTransition /\x3e or \x3cTransition.Root /\x3e.");
    }
    return context;
  }
  function hasChildren(bag) {
    return "children" in bag ? hasChildren(bag.children) : 0 < bag.current.filter(({el}) => null !== el.current).filter(({state}) => "visible" === state).length;
  }
  function useNesting(done, parent) {
    let doneRef = useLatestValue(done), transitionableChildren = (0,import_react66.useRef)([]), mounted = useIsMounted(), d = useDisposables(), unregister = useEvent((container, strategy = 1) => {
      let idx = transitionableChildren.current.findIndex(({el}) => el === container);
      -1 !== idx && (match(strategy, {[0]() {
        transitionableChildren.current.splice(idx, 1);
      }, [1]() {
        transitionableChildren.current[idx].state = "hidden";
      }}), d.microTask(() => {
        var _a3;
        hasChildren(transitionableChildren) || !mounted.current || null != (_a3 = doneRef.current) && _a3.call(doneRef);
      }));
    }), register = useEvent(container => {
      let child = transitionableChildren.current.find(({el}) => el === container);
      child ? "visible" !== child.state && (child.state = "visible") : transitionableChildren.current.push({el:container, state:"visible"});
      return () => unregister(container, 0);
    }), todos = (0,import_react66.useRef)([]), wait = (0,import_react66.useRef)(Promise.resolve()), chains = (0,import_react66.useRef)({enter:[], leave:[]}), onStart = useEvent((container, direction, cb) => {
      todos.current.splice(0);
      parent && (parent.chains.current[direction] = parent.chains.current[direction].filter(([containerInParent]) => containerInParent !== container));
      null == parent || parent.chains.current[direction].push([container, new Promise(resolve => {
        todos.current.push(resolve);
      })]);
      null == parent || parent.chains.current[direction].push([container, new Promise(resolve => {
        Promise.all(chains.current[direction].map(([, promise]) => promise)).then(() => resolve());
      })]);
      "enter" === direction ? wait.current = wait.current.then(() => null == parent ? void 0 : parent.wait.current).then(() => cb(direction)) : cb(direction);
    }), onStop = useEvent((_container, direction, cb) => {
      Promise.all(chains.current[direction].splice(0).map(([, promise]) => promise)).then(() => {
        var _a3;
        null == (_a3 = todos.current.shift()) || _a3();
      }).then(() => cb(direction));
    });
    return (0,import_react66.useMemo)(() => ({children:transitionableChildren, register, unregister, onStart, onStop, wait, chains}), [register, unregister, transitionableChildren, onStart, onStop, chains, wait]);
  }
  function useDialogContext(component) {
    let context = (0,import_react67.useContext)(DialogContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Dialog /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useDialogContext), component;
    }
    return context;
  }
  function stateReducer(state, action) {
    return match(action.type, reducers3, state, action);
  }
  function useDisclosureContext(component) {
    let context = (0,import_react69.useContext)(DisclosureContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Disclosure /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useDisclosureContext), component;
    }
    return context;
  }
  function useDisclosureAPIContext(component) {
    let context = (0,import_react69.useContext)(DisclosureAPIContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Disclosure /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useDisclosureAPIContext), component;
    }
    return context;
  }
  function stateReducer2(state, action) {
    return match(action.type, reducers4, state, action);
  }
  function useResolvedTag(tag) {
    let tagName = "string" === typeof tag ? tag : void 0, [resolvedTag, setResolvedTag] = (0,import_react71.useState)(tagName);
    return [null != tagName ? tagName : resolvedTag, (0,import_react71.useCallback)(ref => {
      tagName || isHTMLElement(ref) && setResolvedTag(ref.tagName.toLowerCase());
    }, [tagName])];
  }
  function getTextContents(element) {
    var _a3, _b2;
    let currentInnerText = null != (_a3 = element.innerText) ? _a3 : "";
    element = element.cloneNode(!0);
    if (!isHTMLElement(element)) {
      return currentInnerText;
    }
    _a3 = !1;
    for (var child of element.querySelectorAll('[hidden],[aria-hidden],[role\x3d"img"]')) {
      child.remove(), _a3 = !0;
    }
    child = _a3 ? null != (_b2 = element.innerText) ? _b2 : "" : currentInnerText;
    emojiRegex.test(child) && (child = child.replace(emojiRegex, ""));
    return child;
  }
  function getTextValue(element) {
    var label = element.getAttribute("aria-label");
    if ("string" === typeof label) {
      return label.trim();
    }
    if (label = element.getAttribute("aria-labelledby")) {
      if (label = label.split(" ").map(labelledby2 => {
        if (labelledby2 = document.getElementById(labelledby2)) {
          let label2 = labelledby2.getAttribute("aria-label");
          return "string" === typeof label2 ? label2.trim() : getTextContents(labelledby2).trim();
        }
        return null;
      }).filter(Boolean), 0 < label.length) {
        return label.join(", ");
      }
    }
    return getTextContents(element).trim();
  }
  function useTextValue(element) {
    let cacheKey = (0,import_react74.useRef)(""), cacheValue = (0,import_react74.useRef)("");
    return useEvent(() => {
      var el = element.current;
      if (!el) {
        return "";
      }
      let currentKey = el.innerText;
      if (cacheKey.current === currentKey) {
        return cacheValue.current;
      }
      el = getTextValue(el).trim().toLowerCase();
      cacheKey.current = currentKey;
      return cacheValue.current = el;
    });
  }
  function adjustOrderedState2(state, adjustment = i => i) {
    var currentActiveOption = null !== state.activeOptionIndex ? state.options[state.activeOptionIndex] : null;
    state = sortByDomNode(adjustment(state.options.slice()), option => option.dataRef.current.domRef.current);
    currentActiveOption = currentActiveOption ? state.indexOf(currentActiveOption) : null;
    -1 === currentActiveOption && (currentActiveOption = null);
    return {options:state, activeOptionIndex:currentActiveOption};
  }
  function useListboxMachineContext(component) {
    let context = (0,import_react75.useContext)(ListboxContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Listbox /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useListboxMachine), component;
    }
    return context;
  }
  function useListboxMachine({id, __demoMode = !1}) {
    let machine = (0,import_react75.useMemo)(() => ListboxMachine.new({id, __demoMode}), []);
    useOnUnmount(() => machine.dispose());
    return machine;
  }
  function useData2(component) {
    let context = (0,import_react76.useContext)(ListboxDataContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Listbox /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useData2), component;
    }
    return context;
  }
  function adjustOrderedState3(state, adjustment = i => i) {
    var currentActiveItem = null !== state.activeItemIndex ? state.items[state.activeItemIndex] : null;
    state = sortByDomNode(adjustment(state.items.slice()), item => item.dataRef.current.domRef.current);
    currentActiveItem = currentActiveItem ? state.indexOf(currentActiveItem) : null;
    -1 === currentActiveItem && (currentActiveItem = null);
    return {items:state, activeItemIndex:currentActiveItem};
  }
  function useMenuMachineContext(component) {
    let context = (0,import_react77.useContext)(MenuContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Menu /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useMenuMachine), component;
    }
    return context;
  }
  function useMenuMachine({id, __demoMode = !1}) {
    let machine = (0,import_react77.useMemo)(() => MenuMachine.new({id, __demoMode}), []);
    useOnUnmount(() => machine.dispose());
    return machine;
  }
  function usePopoverMachineContext(component) {
    let context = (0,import_react79.useContext)(PopoverContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Popover /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, usePopoverMachineContext), component;
    }
    return context;
  }
  function usePopoverMachine({id, __demoMode = !1}) {
    let machine = (0,import_react79.useMemo)(() => PopoverMachine.new({id, __demoMode}), []);
    useOnUnmount(() => machine.dispose());
    return machine;
  }
  function BackdropFn2(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-popover-backdrop-${internalId}`, transition:transition2 = !1, ...theirProps} = props, machine = usePopoverMachineContext("Popover.Backdrop");
    props = useSlice(machine, (0,import_react80.useCallback)(state => state.popoverState, []));
    let [localBackdropElement, setLocalBackdropElement] = (0,import_react80.useState)(null);
    ref = useSyncRefs(ref, setLocalBackdropElement);
    internalId = useOpenClosed();
    let [visible, transitionData] = useTransition(transition2, localBackdropElement, null !== internalId ? 1 === (internalId & 1) : 0 === props);
    internalId = useEvent(event => {
      if (isDisabledReactIssue7711(event.currentTarget)) {
        return event.preventDefault();
      }
      machine.actions.close();
    });
    props = useSlot({open:0 === props});
    ref = {ref, id, "aria-hidden":!0, onClick:internalId, ...transitionDataAttributes(transitionData)};
    return useRender()({ourProps:ref, theirProps, slot:props, defaultTag:"div", features:3, visible, name:"Popover.Backdrop"});
  }
  function useData3(component) {
    let context = (0,import_react81.useContext)(RadioGroupDataContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <RadioGroup /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useData3), component;
    }
    return context;
  }
  function useActions(component) {
    let context = (0,import_react81.useContext)(RadioGroupActionsContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <RadioGroup /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useActions), component;
    }
    return context;
  }
  function stateReducer3(state, action) {
    return match(action.type, reducers8, state, action);
  }
  function FocusSentinel({onFocus}) {
    let [enabled, setEnabled] = (0,import_react83.useState)(!0), mounted = useIsMounted();
    return enabled ? import_react83.default.createElement(Hidden, {as:"button", type:"button", features:2, onFocus:event => {
      function forwardFocus() {
        0 >= tries-- ? frame && cancelAnimationFrame(frame) : onFocus() ? (cancelAnimationFrame(frame), mounted.current && setEnabled(!1)) : frame = requestAnimationFrame(forwardFocus);
      }
      event.preventDefault();
      let frame, tries = 50;
      frame = requestAnimationFrame(forwardFocus);
    }}) : null;
  }
  function createCollection() {
    return {groups:new Map(), get(group, key) {
      var _a3;
      let list = this.groups.get(group);
      list || (list = new Map(), this.groups.set(group, list));
      group = null != (_a3 = list.get(key)) ? _a3 : 0;
      list.set(key, group + 1);
      return [Array.from(list.keys()).indexOf(key), function() {
        let renders2 = list.get(key);
        1 < renders2 ? list.set(key, renders2 - 1) : list.delete(key);
      }];
    }};
  }
  function StableCollection({children}) {
    let collection = React36.useRef(createCollection());
    return React36.createElement(StableCollectionContext.Provider, {value:collection}, children);
  }
  function useStableCollectionIndex(group) {
    let collection = React36.useContext(StableCollectionContext);
    if (!collection) {
      throw Error("You must wrap your component in a \x3cStableCollection\x3e");
    }
    let key = React36.useId(), [idx, cleanupIdx] = collection.current.get(group, key);
    React36.useEffect(() => cleanupIdx, []);
    return idx;
  }
  function useData4(component) {
    let context = (0,import_react84.useContext)(TabsDataContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Tab.Group /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useData4), component;
    }
    return context;
  }
  function useActions2(component) {
    let context = (0,import_react84.useContext)(TabsActionsContext);
    if (null === context) {
      throw component = Error(`<${component} /> is missing a parent <Tab.Group /> component.`), Error.captureStackTrace && Error.captureStackTrace(component, useActions2), component;
    }
    return context;
  }
  function stateReducer4(state, action) {
    return match(action.type, reducers9, state, action);
  }
  var process = require("module$node_modules$process$browser");
  "use strict";
  var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __copyProps = (to, from, except, desc) => {
    if (from && "object" === typeof from || "function" === typeof from) {
      for (let key of __getOwnPropNames(from)) {
        __hasOwnProp.call(to, key) || key === except || __defProp(to, key, {get:() => from[key], enumerable:!(desc = __getOwnPropDesc(from, key)) || desc.enumerable});
      }
    }
    return to;
  }, __toESM = (mod, isNodeMode, target) => (target = null != mod ? __create(__getProtoOf(mod)) : {}, __copyProps(!isNodeMode && mod && mod.__esModule ? target : __defProp(target, "default", {value:mod, enumerable:!0}), mod)), __publicField = (obj, key, value) => {
    key = "symbol" !== typeof key ? key + "" : key;
    key in obj ? __defProp(obj, key, {enumerable:!0, configurable:!0, writable:!0, value}) : obj[key] = value;
    return value;
  }, __privateGet = (obj, member, getter) => {
    if (!member.has(obj)) {
      throw TypeError("Cannot read from private field");
    }
    return getter ? getter.call(obj) : member.get(obj);
  }, __privateAdd = (obj, member, value) => {
    if (member.has(obj)) {
      throw TypeError("Cannot add the same private member more than once");
    }
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  }, __privateSet = (obj, member, value, setter) => {
    if (!member.has(obj)) {
      throw TypeError("Cannot write to private field");
    }
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  }, src_exports = {};
  ((target, all) => {
    for (var name in all) {
      __defProp(target, name, {get:all[name], enumerable:!0});
    }
  })(src_exports, {Button:() => Button, Checkbox:() => Checkbox, CloseButton:() => CloseButton, Combobox:() => Combobox, ComboboxButton:() => ComboboxButton, ComboboxInput:() => ComboboxInput, ComboboxLabel:() => ComboboxLabel, ComboboxOption:() => ComboboxOption, ComboboxOptions:() => ComboboxOptions, DataInteractive:() => DataInteractive, Description:() => Description, Dialog:() => Dialog, DialogBackdrop:() => DialogBackdrop, DialogDescription:() => DialogDescription, DialogPanel:() => DialogPanel, 
  DialogTitle:() => DialogTitle, Disclosure:() => Disclosure, DisclosureButton:() => DisclosureButton, DisclosurePanel:() => DisclosurePanel, Field:() => Field, Fieldset:() => Fieldset, FocusTrap:() => FocusTrap, FocusTrapFeatures:() => FocusTrapFeatures, Input:() => Input, Label:() => Label, Legend:() => Legend, Listbox:() => Listbox, ListboxButton:() => ListboxButton, ListboxLabel:() => ListboxLabel, ListboxOption:() => ListboxOption, ListboxOptions:() => ListboxOptions, ListboxSelectedOption:() => 
  ListboxSelectedOption, Menu:() => Menu, MenuButton:() => MenuButton, MenuHeading:() => MenuHeading, MenuItem:() => MenuItem, MenuItems:() => MenuItems, MenuSection:() => MenuSection, MenuSeparator:() => MenuSeparator, Popover:() => Popover, PopoverBackdrop:() => PopoverBackdrop, PopoverButton:() => PopoverButton, PopoverGroup:() => PopoverGroup, PopoverOverlay:() => PopoverOverlay, PopoverPanel:() => PopoverPanel, Portal:() => Portal, Radio:() => Radio, RadioGroup:() => RadioGroup, RadioGroupDescription:() => 
  RadioGroupDescription, RadioGroupLabel:() => RadioGroupLabel, RadioGroupOption:() => RadioGroupOption, Select:() => Select, Switch:() => Switch, SwitchDescription:() => SwitchDescription, SwitchGroup:() => SwitchGroup, SwitchLabel:() => SwitchLabel, Tab:() => Tab, TabGroup:() => TabGroup, TabList:() => TabList, TabPanel:() => TabPanel, TabPanels:() => TabPanels, Textarea:() => Textarea, Transition:() => Transition, TransitionChild:() => TransitionChild, useClose:() => useClose});
  module.exports = (mod => __copyProps(__defProp({}, "__esModule", {value:!0}), mod))(src_exports);
  var import_react = __toESM(require("module$node_modules$react$index"), 1), $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = "undefined" !== typeof document ? (0, import_react.default).useLayoutEffect : () => {
  }, import_react2 = require("module$node_modules$react$index"), $431fbd86ca7dc216$export$b204af158042fbac = el => {
    var _el_ownerDocument;
    return null !== (_el_ownerDocument = null === el || void 0 === el ? void 0 : el.ownerDocument) && void 0 !== _el_ownerDocument ? _el_ownerDocument : document;
  }, $431fbd86ca7dc216$export$f21a1ffae260145a = el => el && "window" in el && el.window === el ? el : $431fbd86ca7dc216$export$b204af158042fbac(el).defaultView || window, $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => doc.activeElement, $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testPlatform(/^Mac/i);
  }), $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
  }), $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || $c87311424ea30a05$export$9ac100e40613ea10() && 1 < navigator.maxTouchPoints;
  }), $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
  });
  $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
  });
  $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
  });
  var $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
  }), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/Android/i);
  });
  $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
  });
  var import_react3 = require("module$node_modules$react$index"), import_react4 = require("module$node_modules$react$index"), import_react5 = require("module$node_modules$react$index"), $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1, $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {Tab:!0, Escape:!0}, 
  $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
    const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
    element = $431fbd86ca7dc216$export$b204af158042fbac(element);
    loadListener && element.removeEventListener("DOMContentLoaded", loadListener);
    $507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject) && (windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus, element.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), element.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), element.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, 
    !0), windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), "undefined" !== typeof PointerEvent && (element.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), element.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), element.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject));
  };
  "undefined" !== typeof document && $507fabe10e71c6fb$export$2f1888112f558a7d();
  var $507fabe10e71c6fb$var$nonTextInputTypes = new Set("checkbox radio range color file image button submit reset".split(" ")), import_react6 = require("module$node_modules$react$index"), import_react7 = require("module$node_modules$react$index"), import_react8 = require("module$node_modules$react$index"), $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0, import_react9 = require("module$node_modules$react$index"), import_react14 = require("module$node_modules$react$index"), 
  env = new class {
    constructor() {
      __publicField(this, "current", this.detect());
      __publicField(this, "handoffState", "pending");
      __publicField(this, "currentId", 0);
    }
    set(env2) {
      this.current !== env2 && (this.handoffState = "pending", this.currentId = 0, this.current = env2);
    }
    reset() {
      this.set(this.detect());
    }
    nextId() {
      return ++this.currentId;
    }
    get isServer() {
      return "server" === this.current;
    }
    get isClient() {
      return "client" === this.current;
    }
    detect() {
      return "undefined" === typeof window || "undefined" === typeof document ? "server" : "client";
    }
    handoff() {
      "pending" === this.handoffState && (this.handoffState = "complete");
    }
    get isHandoffComplete() {
      return "complete" === this.handoffState;
    }
  }(), import_react10 = require("module$node_modules$react$index"), import_react13 = __toESM(require("module$node_modules$react$index"), 1), import_react12 = require("module$node_modules$react$index"), import_react11 = require("module$node_modules$react$index"), useIsoMorphicEffect = (effect, deps) => {
    env.isServer ? (0,import_react11.useEffect)(effect, deps) : (0,import_react11.useLayoutEffect)(effect, deps);
  }, useEvent = function(cb) {
    let cache = useLatestValue(cb);
    return import_react13.default.useCallback((...args) => cache.current(...args), [cache]);
  }, import_react15 = require("module$node_modules$react$index"), import_react16 = __toESM(require("module$node_modules$react$index"), 1), DisabledContext = (0,import_react16.createContext)(void 0), import_react17 = __toESM(require("module$node_modules$react$index"), 1), Button = forwardRefWithAs(function(props, ref) {
    var _a3;
    let providedDisabled = useDisabled(), {disabled = providedDisabled || !1, autoFocus = !1, ...theirProps} = props, {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    props = mergeProps({ref, type:null != (_a3 = theirProps.type) ? _a3 : "button", disabled:disabled || void 0, autoFocus}, focusProps, hoverProps, pressProps);
    _a3 = useSlot({disabled, hover, focus, active, autofocus:autoFocus});
    return useRender()({ourProps:props, theirProps, slot:_a3, defaultTag:"button", name:"Button"});
  }), import_react27 = __toESM(require("module$node_modules$react$index"), 1), import_react18 = require("module$node_modules$react$index"), import_react_dom = require("module$node_modules$react_dom$index"), import_react19 = require("module$node_modules$react$index"), import_react20 = require("module$node_modules$react$index"), import_react22 = __toESM(require("module$node_modules$react$index"), 1), import_react_dom2 = require("module$node_modules$react_dom$index"), import_react21 = require("module$node_modules$react$index"), 
  Hidden = forwardRefWithAs(function(props, ref) {
    var _a3;
    let {features = 1, ...theirProps} = props;
    props = {ref, "aria-hidden":2 === (features & 2) ? !0 : null != (_a3 = theirProps["aria-hidden"]) ? _a3 : void 0, hidden:4 === (features & 4) ? !0 : void 0, style:{position:"fixed", top:1, left:1, width:1, height:0, padding:0, margin:-1, overflow:"hidden", clip:"rect(0, 0, 0, 0)", whiteSpace:"nowrap", borderWidth:"0", ...(4 === (features & 4) && 2 !== (features & 2) && {display:"none"})}};
    return useRender()({ourProps:props, theirProps, slot:{}, defaultTag:"span", name:"Hidden"});
  }), FormFieldsContext = (0,import_react22.createContext)(null), import_react23 = __toESM(require("module$node_modules$react$index"), 1), IdContext = (0,import_react23.createContext)(void 0), import_react25 = __toESM(require("module$node_modules$react$index"), 1), import_react24 = require("module$node_modules$react$index"), Optional = Symbol(), DescriptionContext = (0,import_react25.createContext)(null);
  DescriptionContext.displayName = "DescriptionContext";
  var DescriptionRoot = forwardRefWithAs(function(props, ref) {
    let internalId = (0,import_react20.useId)();
    var providedDisabled = useDisabled();
    let {id = `headlessui-description-${internalId}`, ...theirProps} = props, context = useDescriptionContext();
    props = useSyncRefs(ref);
    useIsoMorphicEffect(() => context.register(id), [id, context.register]);
    providedDisabled = useSlot({...context.slot, disabled:providedDisabled || !1});
    props = {ref:props, ...context.props, id};
    return useRender()({ourProps:props, theirProps, slot:providedDisabled, defaultTag:"p", name:context.name || "Description"});
  }), Description = Object.assign(DescriptionRoot, {}), import_react26 = __toESM(require("module$node_modules$react$index"), 1), LabelContext = (0,import_react26.createContext)(null);
  LabelContext.displayName = "LabelContext";
  var LabelRoot = forwardRefWithAs(function(props, ref) {
    var _a3;
    let internalId = (0,import_react20.useId)(), context = useLabelContext(), providedHtmlFor = useProvidedId();
    var providedDisabled = useDisabled();
    let {id = `headlessui-label-${internalId}`, htmlFor = null != providedHtmlFor ? providedHtmlFor : null == (_a3 = context.props) ? void 0 : _a3.htmlFor, passive = !1, ...theirProps} = props;
    props = useSyncRefs(ref);
    useIsoMorphicEffect(() => context.register(id), [id, context.register]);
    ref = useEvent(e => {
      var current = e.currentTarget, JSCompiler_temp;
      if (JSCompiler_temp = e.target !== e.currentTarget) {
        JSCompiler_temp = e.target, JSCompiler_temp = isElement(JSCompiler_temp) ? JSCompiler_temp.matches('a[href],audio[controls],button,details,embed,iframe,img[usemap],input:not([type\x3d"hidden"]),label,select,textarea,video[controls]') : !1;
      }
      if (!JSCompiler_temp) {
        isHTMLLabelElement(current) && e.preventDefault();
        if (context.props && "onClick" in context.props && "function" === typeof context.props.onClick) {
          context.props.onClick(e);
        }
        isHTMLLabelElement(current) && (e = document.getElementById(current.htmlFor)) && (current = e.getAttribute("disabled"), "true" !== current && "" !== current && (current = e.getAttribute("aria-disabled"), "true" !== current && "" !== current && ((isHTMLInputElement(e) && ("file" === e.type || "radio" === e.type || "checkbox" === e.type) || "radio" === e.role || "checkbox" === e.role || "switch" === e.role) && e.click(), e.focus({preventScroll:!0}))));
      }
    });
    providedDisabled = useSlot({...context.slot, disabled:providedDisabled || !1});
    props = {ref:props, ...context.props, id, htmlFor, onClick:ref};
    passive && ("onClick" in props && (delete props.htmlFor, delete props.onClick), "onClick" in theirProps && delete theirProps.onClick);
    return useRender()({ourProps:props, theirProps, slot:providedDisabled, defaultTag:htmlFor ? "label" : "div", name:context.name || "Label"});
  }), Label = Object.assign(LabelRoot, {}), Checkbox = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)(), providedId = useProvidedId(), providedDisabled = useDisabled();
    let {id = providedId || `headlessui-checkbox-${internalId}`, disabled = providedDisabled || !1, autoFocus = !1, checked:controlledChecked, defaultChecked:_defaultChecked, onChange:controlledOnChange, name, value, form, indeterminate = !1, tabIndex = 0, ...theirProps} = props, defaultChecked = useDefaultValue(_defaultChecked), [checked, onChange] = useControllable(controlledChecked, controlledOnChange, null != defaultChecked ? defaultChecked : !1);
    props = useLabelledBy();
    internalId = useDescribedBy();
    let d = useDisposables(), [changing, setChanging] = (0,import_react27.useState)(!1), toggle = useEvent(() => {
      setChanging(!0);
      null == onChange || onChange(!checked);
      d.nextFrame(() => {
        setChanging(!1);
      });
    });
    providedId = useEvent(event => {
      if (isDisabledReactIssue7711(event.currentTarget)) {
        return event.preventDefault();
      }
      event.preventDefault();
      toggle();
    });
    providedDisabled = useEvent(event => {
      " " === event.key ? (event.preventDefault(), toggle()) : "Enter" === event.key && attemptSubmit(event.currentTarget);
    });
    let handleKeyPress = useEvent(event => event.preventDefault()), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    ref = mergeProps({ref, id, role:"checkbox", "aria-checked":indeterminate ? "mixed" : checked ? "true" : "false", "aria-labelledby":props, "aria-describedby":internalId, "aria-disabled":disabled ? !0 : void 0, indeterminate:indeterminate ? "true" : void 0, tabIndex:disabled ? void 0 : tabIndex, onKeyUp:disabled ? void 0 : providedDisabled, onKeyPress:disabled ? void 0 : handleKeyPress, onClick:disabled ? void 0 : providedId}, focusProps, hoverProps, pressProps);
    props = useSlot({checked, disabled, hover, focus, active, indeterminate, changing, autofocus:autoFocus});
    internalId = (0,import_react27.useCallback)(() => {
      if (void 0 !== defaultChecked) {
        return null == onChange ? void 0 : onChange(defaultChecked);
      }
    }, [onChange, defaultChecked]);
    providedId = useRender();
    return import_react27.default.createElement(import_react27.default.Fragment, null, null != name && import_react27.default.createElement(FormFields, {disabled, data:{[name]:value || "on"}, overrides:{type:"checkbox", checked}, form, onReset:internalId}), providedId({ourProps:ref, theirProps, slot:props, defaultTag:"span", name:"Checkbox"}));
  }), import_react29 = __toESM(require("module$node_modules$react$index"), 1), import_react28 = __toESM(require("module$node_modules$react$index"), 1), CloseContext = (0,import_react28.createContext)(() => {
  }), CloseButton = forwardRefWithAs(function(props, ref) {
    let close = useClose();
    return import_react29.default.createElement(Button, {ref, ...mergeProps({onClick:close}, props)});
  }), React11 = __toESM(require("module$node_modules$react$index"), 1), import_react_dom3 = require("module$node_modules$react_dom$index"), debounce = (targetWindow, fn, ms) => {
    let timeoutId;
    return function(...args) {
      targetWindow.clearTimeout(timeoutId);
      timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);
    };
  }, getRect = element => {
    const {offsetWidth, offsetHeight} = element;
    return {width:offsetWidth, height:offsetHeight};
  }, defaultKeyExtractor = index3 => index3, defaultRangeExtractor = range => {
    var start = Math.max(range.startIndex - range.overscan, 0);
    range = Math.min(range.endIndex + range.overscan, range.count - 1);
    const arr = [];
    for (; start <= range; start++) {
      arr.push(start);
    }
    return arr;
  }, observeElementRect = (instance, cb) => {
    const element = instance.scrollElement;
    if (element) {
      var targetWindow = instance.targetWindow;
      if (targetWindow) {
        var handler = rect => {
          const {width, height} = rect;
          cb({width:Math.round(width), height:Math.round(height)});
        };
        handler(getRect(element));
        if (!targetWindow.ResizeObserver) {
          return () => {
          };
        }
        var observer = new targetWindow.ResizeObserver(entries => {
          const run = () => {
            var entry = entries[0];
            if (null == entry ? 0 : entry.borderBoxSize) {
              if (entry = entry.borderBoxSize[0]) {
                handler({width:entry.inlineSize, height:entry.blockSize});
                return;
              }
            }
            handler(getRect(element));
          };
          instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
        });
        observer.observe(element, {box:"border-box"});
        return () => {
          observer.unobserve(element);
        };
      }
    }
  }, addEventListenerOptions = {passive:!0}, supportsScrollend = "undefined" == typeof window ? !0 : "onscrollend" in window, observeElementOffset = (instance, cb) => {
    const element = instance.scrollElement;
    if (element) {
      var targetWindow = instance.targetWindow;
      if (targetWindow) {
        var offset3 = 0, fallback = instance.options.useScrollendEvent && supportsScrollend ? () => {
        } : debounce(targetWindow, () => {
          cb(offset3, !1);
        }, instance.options.isScrollingResetDelay);
        targetWindow = isScrolling => () => {
          const {horizontal, isRtl} = instance.options;
          offset3 = horizontal ? element.scrollLeft * (isRtl && -1 || 1) : element.scrollTop;
          fallback();
          cb(offset3, isScrolling);
        };
        var handler = targetWindow(!0), endHandler = targetWindow(!1);
        endHandler();
        element.addEventListener("scroll", handler, addEventListenerOptions);
        var registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
        registerScrollendEvent && element.addEventListener("scrollend", endHandler, addEventListenerOptions);
        return () => {
          element.removeEventListener("scroll", handler);
          registerScrollendEvent && element.removeEventListener("scrollend", endHandler);
        };
      }
    }
  }, measureElement = (element, entry, instance) => {
    if (null == entry ? 0 : entry.borderBoxSize) {
      if (entry = entry.borderBoxSize[0]) {
        return Math.round(entry[instance.options.horizontal ? "inlineSize" : "blockSize"]);
      }
    }
    return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
  }, elementScroll = (offset3, {adjustments = 0, behavior}, instance) => {
    var _a3, _b2;
    null == (_b2 = null == (_a3 = instance.scrollElement) ? void 0 : _a3.scrollTo) || _b2.call(_a3, {[instance.options.horizontal ? "left" : "top"]:offset3 + adjustments, behavior});
  }, Virtualizer = class {
    constructor(opts) {
      this.unsubs = [];
      this.targetWindow = this.scrollElement = null;
      this.isScrolling = !1;
      this.scrollToIndexTimeoutId = null;
      this.measurementsCache = [];
      this.itemSizeCache = new Map();
      this.pendingMeasuredCacheIndexes = [];
      this.scrollDirection = this.scrollOffset = this.scrollRect = null;
      this.scrollAdjustments = 0;
      this.elementsCache = new Map();
      this.observer = (() => {
        let _ro = null;
        const get = () => _ro ? _ro : this.targetWindow && this.targetWindow.ResizeObserver ? _ro = new this.targetWindow.ResizeObserver(entries => {
          entries.forEach(entry => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        }) : null;
        return {disconnect:() => {
          var _a3;
          null == (_a3 = get()) || _a3.disconnect();
          _ro = null;
        }, observe:target => {
          var _a3;
          return null == (_a3 = get()) ? void 0 : _a3.observe(target, {box:"border-box"});
        }, unobserve:target => {
          var _a3;
          return null == (_a3 = get()) ? void 0 : _a3.unobserve(target);
        }};
      })();
      this.range = null;
      this.setOptions = opts2 => {
        Object.entries(opts2).forEach(([key, value]) => {
          "undefined" === typeof value && delete opts2[key];
        });
        this.options = {debug:!1, initialOffset:0, overscan:1, paddingStart:0, paddingEnd:0, scrollPaddingStart:0, scrollPaddingEnd:0, horizontal:!1, getItemKey:defaultKeyExtractor, rangeExtractor:defaultRangeExtractor, onChange:() => {
        }, measureElement, initialRect:{width:0, height:0}, scrollMargin:0, gap:0, indexAttribute:"data-index", initialMeasurementsCache:[], lanes:1, isScrollingResetDelay:150, enabled:!0, isRtl:!1, useScrollendEvent:!1, useAnimationFrameWithResizeObserver:!1, ...opts2};
      };
      this.notify = sync => {
        var _a3, _b2;
        null == (_b2 = (_a3 = this.options).onChange) || _b2.call(_a3, this, sync);
      };
      this.maybeNotify = memo(() => {
        this.calculateRange();
        return [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null];
      }, isScrolling => {
        this.notify(isScrolling);
      }, {key:"maybeNotify", debug:() => this.options.debug, initialDeps:[this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]});
      this.cleanup = () => {
        this.unsubs.filter(Boolean).forEach(d => d());
        this.unsubs = [];
        this.observer.disconnect();
        this.targetWindow = this.scrollElement = null;
      };
      this._didMount = () => () => {
        this.cleanup();
      };
      this._willUpdate = () => {
        var _a4, _a3;
        const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
        this.scrollElement !== scrollElement && (this.cleanup(), scrollElement ? (this.targetWindow = (this.scrollElement = scrollElement) && "ownerDocument" in this.scrollElement ? this.scrollElement.ownerDocument.defaultView : null != (_a4 = null == (_a3 = this.scrollElement) ? void 0 : _a3.window) ? _a4 : null, this.elementsCache.forEach(cached => {
          this.observer.observe(cached);
        }), this._scrollToOffset(this.getScrollOffset(), {adjustments:void 0, behavior:void 0}), this.unsubs.push(this.options.observeElementRect(this, rect => {
          this.scrollRect = rect;
          this.maybeNotify();
        })), this.unsubs.push(this.options.observeElementOffset(this, (offset3, isScrolling) => {
          this.scrollAdjustments = 0;
          this.scrollDirection = isScrolling ? this.getScrollOffset() < offset3 ? "forward" : "backward" : null;
          this.scrollOffset = offset3;
          this.isScrolling = isScrolling;
          this.maybeNotify();
        }))) : this.maybeNotify());
      };
      this.getSize = () => {
        var _a3;
        if (!this.options.enabled) {
          return this.scrollRect = null, 0;
        }
        this.scrollRect = null != (_a3 = this.scrollRect) ? _a3 : this.options.initialRect;
        return this.scrollRect[this.options.horizontal ? "width" : "height"];
      };
      this.getScrollOffset = () => {
        var _a3;
        return this.options.enabled ? this.scrollOffset = null != (_a3 = this.scrollOffset) ? _a3 : "function" === typeof this.options.initialOffset ? this.options.initialOffset() : this.options.initialOffset : (this.scrollOffset = null, 0);
      };
      this.getFurthestMeasurement = (measurements, index3) => {
        const furthestMeasurementsFound = new Map(), furthestMeasurements = new Map();
        for (--index3; 0 <= index3; index3--) {
          const measurement = measurements[index3];
          if (furthestMeasurementsFound.has(measurement.lane)) {
            continue;
          }
          const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);
          null == previousFurthestMeasurement || measurement.end > previousFurthestMeasurement.end ? furthestMeasurements.set(measurement.lane, measurement) : measurement.end < previousFurthestMeasurement.end && furthestMeasurementsFound.set(measurement.lane, !0);
          if (furthestMeasurementsFound.size === this.options.lanes) {
            break;
          }
        }
        return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => a.end === b.end ? a.index - b.index : a.end - b.end)[0] : void 0;
      };
      this.getMeasurementOptions = memo(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey, this.options.enabled], (count2, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {count:count2, paddingStart, scrollMargin, getItemKey, enabled};
      }, {key:!1});
      this.getMeasurements = memo(() => [this.getMeasurementOptions(), this.itemSizeCache], ({count:count2, paddingStart, scrollMargin, getItemKey, enabled}, itemSizeCache) => {
        if (!enabled) {
          return this.measurementsCache = [], this.itemSizeCache.clear(), [];
        }
        0 === this.measurementsCache.length && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach(item => {
          this.itemSizeCache.set(item.key, item.size);
        }));
        var min2 = 0 < this.pendingMeasuredCacheIndexes.length ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        for (enabled = this.measurementsCache.slice(0, min2); min2 < count2; min2++) {
          const key = getItemKey(min2), furthestMeasurement = 1 === this.options.lanes ? enabled[min2 - 1] : this.getFurthestMeasurement(enabled, min2), start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          var measuredSize = itemSizeCache.get(key);
          measuredSize = "number" === typeof measuredSize ? measuredSize : this.options.estimateSize(min2);
          enabled[min2] = {index:min2, start, size:measuredSize, end:start + measuredSize, key, lane:furthestMeasurement ? furthestMeasurement.lane : min2 % this.options.lanes};
        }
        return this.measurementsCache = enabled;
      }, {key:"getMeasurements", debug:() => this.options.debug});
      this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.getScrollOffset(), this.options.lanes], (measurements, outerSize, scrollOffset, lanes) => this.range = 0 < measurements.length && 0 < outerSize ? calculateRange({measurements, outerSize, scrollOffset, lanes}) : null, {key:"calculateRange", debug:() => this.options.debug});
      this.getVirtualIndexes = memo(() => {
        let startIndex = null, endIndex = null;
        const range = this.calculateRange();
        range && (startIndex = range.startIndex, endIndex = range.endIndex);
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [this.options.rangeExtractor, this.options.overscan, this.options.count, startIndex, endIndex];
      }, (rangeExtractor, overscan, count2, startIndex, endIndex) => null === startIndex || null === endIndex ? [] : rangeExtractor({startIndex, endIndex, overscan, count:count2}), {key:"getVirtualIndexes", debug:() => this.options.debug});
      this.indexFromElement = node => {
        const attributeName = this.options.indexAttribute;
        node = node.getAttribute(attributeName);
        return node ? parseInt(node, 10) : (console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`), -1);
      };
      this._measureElement = (node, entry) => {
        const index3 = this.indexFromElement(node);
        var item = this.measurementsCache[index3];
        if (item) {
          item = item.key;
          var prevNode = this.elementsCache.get(item);
          prevNode !== node && (prevNode && this.observer.unobserve(prevNode), this.observer.observe(node), this.elementsCache.set(item, node));
          node.isConnected && this.resizeItem(index3, this.options.measureElement(node, entry, this));
        }
      };
      this.resizeItem = (index3, size3) => {
        var _a3;
        if (index3 = this.measurementsCache[index3]) {
          var itemSize = null != (_a3 = this.itemSizeCache.get(index3.key)) ? _a3 : index3.size;
          _a3 = size3 - itemSize;
          if (0 !== _a3) {
            if (void 0 !== this.shouldAdjustScrollPositionOnItemSizeChange ? this.shouldAdjustScrollPositionOnItemSizeChange(index3, _a3, this) : index3.start < this.getScrollOffset() + this.scrollAdjustments) {
              this.options.debug && console.info("correction", _a3), this._scrollToOffset(this.getScrollOffset(), {adjustments:this.scrollAdjustments += _a3, behavior:void 0});
            }
            this.pendingMeasuredCacheIndexes.push(index3.index);
            this.itemSizeCache = new Map(this.itemSizeCache.set(index3.key, size3));
            this.notify(!1);
          }
        }
      };
      this.measureElement = node => {
        node ? this._measureElement(node, void 0) : this.elementsCache.forEach((cached, key) => {
          cached.isConnected || (this.observer.unobserve(cached), this.elementsCache.delete(key));
        });
      };
      this.getVirtualItems = memo(() => [this.getVirtualIndexes(), this.getMeasurements()], (indexes, measurements) => {
        const virtualItems = [];
        for (let k = 0, len = indexes.length; k < len; k++) {
          virtualItems.push(measurements[indexes[k]]);
        }
        return virtualItems;
      }, {key:"getVirtualItems", debug:() => this.options.debug});
      this.getVirtualItemForOffset = offset3 => {
        const measurements = this.getMeasurements();
        if (0 !== measurements.length) {
          return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, index3 => notUndefined(measurements[index3]).start, offset3)]);
        }
      };
      this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
        const size3 = this.getSize(), scrollOffset = this.getScrollOffset();
        "auto" === align && (align = toOffset >= scrollOffset + size3 ? "end" : "start");
        "center" === align ? toOffset += (itemSize - size3) / 2 : "end" === align && (toOffset -= size3);
        align = this.getTotalSize() - size3;
        return Math.max(Math.min(align, toOffset), 0);
      };
      this.getOffsetForIndex = (index3, align = "auto") => {
        index3 = Math.max(0, Math.min(index3, this.options.count - 1));
        if (index3 = this.measurementsCache[index3]) {
          var size3 = this.getSize(), scrollOffset = this.getScrollOffset();
          if ("auto" === align) {
            if (index3.end >= scrollOffset + size3 - this.options.scrollPaddingEnd) {
              align = "end";
            } else if (index3.start <= scrollOffset + this.options.scrollPaddingStart) {
              align = "start";
            } else {
              return [scrollOffset, align];
            }
          }
          return [this.getOffsetForAlignment("end" === align ? index3.end + this.options.scrollPaddingEnd : index3.start - this.options.scrollPaddingStart, align, index3.size), align];
        }
      };
      this.isDynamicMode = () => 0 < this.elementsCache.size;
      this.cancelScrollToIndex = () => {
        null !== this.scrollToIndexTimeoutId && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null);
      };
      this.scrollToOffset = (toOffset, {align = "start", behavior} = {}) => {
        this.cancelScrollToIndex();
        "smooth" === behavior && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
        this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {adjustments:void 0, behavior});
      };
      this.scrollToIndex = (index3, {align:initialAlign = "auto", behavior} = {}) => {
        index3 = Math.max(0, Math.min(index3, this.options.count - 1));
        this.cancelScrollToIndex();
        "smooth" === behavior && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
        if (initialAlign = this.getOffsetForIndex(index3, initialAlign)) {
          var [offset3, align] = initialAlign;
          this._scrollToOffset(offset3, {adjustments:void 0, behavior});
          "smooth" !== behavior && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
            this.scrollToIndexTimeoutId = null;
            if (this.elementsCache.has(this.options.getItemKey(index3))) {
              var result = this.getOffsetForIndex(index3, align);
              if (result) {
                [result] = result;
                var currentScrollOffset = this.getScrollOffset();
                1 >= Math.abs(result - currentScrollOffset) || this.scrollToIndex(index3, {align, behavior});
              }
            } else {
              this.scrollToIndex(index3, {align, behavior});
            }
          }));
        }
      };
      this.scrollBy = (delta, {behavior} = {}) => {
        this.cancelScrollToIndex();
        "smooth" === behavior && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
        this._scrollToOffset(this.getScrollOffset() + delta, {adjustments:void 0, behavior});
      };
      this.getTotalSize = () => {
        var _a4, _a3, measurements = this.getMeasurements();
        if (0 === measurements.length) {
          measurements = this.options.paddingStart;
        } else if (1 === this.options.lanes) {
          measurements = null != (_a4 = null == (_a3 = measurements[measurements.length - 1]) ? void 0 : _a3.end) ? _a4 : 0;
        } else {
          _a4 = Array(this.options.lanes).fill(null);
          for (_a3 = measurements.length - 1; 0 <= _a3 && _a4.some(val => null === val);) {
            const item = measurements[_a3];
            null === _a4[item.lane] && (_a4[item.lane] = item.end);
            _a3--;
          }
          measurements = Math.max(..._a4.filter(val => null !== val));
        }
        return Math.max(measurements - this.options.scrollMargin + this.options.paddingEnd, 0);
      };
      this._scrollToOffset = (offset3, {adjustments, behavior}) => {
        this.options.scrollToFn(offset3, {behavior, adjustments}, this);
      };
      this.measure = () => {
        this.itemSizeCache = new Map();
        this.notify(!1);
      };
      this.setOptions(opts);
    }
  }, findNearestBinarySearch = (low, high, getCurrentValue, value) => {
    for (; low <= high;) {
      const middle = (low + high) / 2 | 0, currentValue = getCurrentValue(middle);
      if (currentValue < value) {
        low = middle + 1;
      } else if (currentValue > value) {
        high = middle - 1;
      } else {
        return middle;
      }
    }
    return 0 < low ? low - 1 : 0;
  }, useIsomorphicLayoutEffect = "undefined" !== typeof document ? React11.useLayoutEffect : React11.useEffect, import_react59 = __toESM(require("module$node_modules$react$index"), 1), import_react_dom8 = require("module$node_modules$react_dom$index"), import_react30 = require("module$node_modules$react$index"), import_react31 = require("module$node_modules$react$index"), import_react32 = require("module$node_modules$react$index"), import_react33 = require("module$node_modules$react$index"), DefaultMap = 
  class extends Map {
    constructor(factory) {
      super();
      this.factory = factory;
    }
    get(key) {
      let value = super.get(key);
      void 0 === value && (value = this.factory(key), this.set(key, value));
      return value;
    }
  }, Machine = class {
    constructor(initialState) {
      __privateAdd(this, _state, {});
      __privateAdd(this, _eventSubscribers, new DefaultMap(() => new Set()));
      __privateAdd(this, _subscribers, new Set());
      __publicField(this, "disposables", disposables());
      __privateSet(this, _state, initialState);
      env.isServer && this.disposables.microTask(() => {
        this.dispose();
      });
    }
    dispose() {
      this.disposables.dispose();
    }
    get state() {
      return __privateGet(this, _state);
    }
    subscribe(selector, callback) {
      if (env.isServer) {
        return () => {
        };
      }
      let subscriber = {selector, callback, current:selector(__privateGet(this, _state))};
      __privateGet(this, _subscribers).add(subscriber);
      return this.disposables.add(() => {
        __privateGet(this, _subscribers).delete(subscriber);
      });
    }
    on(type, callback) {
      if (env.isServer) {
        return () => {
        };
      }
      __privateGet(this, _eventSubscribers).get(type).add(callback);
      return this.disposables.add(() => {
        __privateGet(this, _eventSubscribers).get(type).delete(callback);
      });
    }
    send(event) {
      var newState = this.reduce(__privateGet(this, _state), event);
      if (newState !== __privateGet(this, _state)) {
        __privateSet(this, _state, newState);
        for (let subscriber of __privateGet(this, _subscribers)) {
          newState = subscriber.selector(__privateGet(this, _state)), shallowEqual(subscriber.current, newState) || (subscriber.current = newState, subscriber.callback(newState));
        }
        for (let callback of __privateGet(this, _eventSubscribers).get(event.type)) {
          callback(__privateGet(this, _state), event);
        }
      }
    }
  };
  var _state = new WeakMap();
  var _eventSubscribers = new WeakMap();
  var _subscribers = new WeakMap();
  var reducers = {[0](state, action) {
    action = action.id;
    let idx = state.stack.indexOf(action);
    if (-1 !== idx) {
      let copy = state.stack.slice();
      copy.splice(idx, 1);
      copy.push(action);
      action = copy;
      return {...state, stack:action};
    }
    return {...state, stack:[...state.stack, action]};
  }, [1](state, action) {
    action = state.stack.indexOf(action.id);
    if (-1 === action) {
      return state;
    }
    let copy = state.stack.slice();
    copy.splice(action, 1);
    return {...state, stack:copy};
  }}, StackMachine = class extends Machine {
    constructor() {
      super(...arguments);
      __publicField(this, "actions", {push:id => this.send({type:0, id}), pop:id => this.send({type:1, id})});
      __publicField(this, "selectors", {isTop:(state, id) => state.stack[state.stack.length - 1] === id, inStack:(state, id) => state.stack.includes(id)});
    }
    static new() {
      return new StackMachine({stack:[]});
    }
    reduce(state, action) {
      return match(action.type, reducers, state, action);
    }
  }, stackMachines = new DefaultMap(() => StackMachine.new()), import_with_selector = require("module$node_modules$use_sync_external_store$with_selector"), originals = new Map(), counts = new Map(), import_react34 = require("module$node_modules$react$index"), import_react37 = require("module$node_modules$react$index"), focusableSelector = "[contentEditable\x3dtrue] [tabindex] a[href] area[href] button:not([disabled]) iframe input:not([disabled]) select:not([disabled]) details\x3esummary textarea:not([disabled])".split(" ").map(selector => 
  `${selector}:not([tabindex='-1'])`).join(","), autoFocusableSelector = ["[data-autofocus]"].map(selector => `${selector}:not([tabindex='-1'])`).join(",");
  "undefined" !== typeof window && "undefined" !== typeof document && (document.addEventListener("keydown", event => {
    event.metaKey || event.altKey || event.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
  }, !0), document.addEventListener("click", event => {
    1 === event.detail ? delete document.documentElement.dataset.headlessuiFocusVisible : 0 === event.detail && (document.documentElement.dataset.headlessuiFocusVisible = "");
  }, !0));
  var import_react35 = require("module$node_modules$react$index"), import_react36 = require("module$node_modules$react$index"), import_react38 = require("module$node_modules$react$index"), import_react39 = require("module$node_modules$react$index"), Action = {Ignore:{kind:0}, Select:target => ({kind:1, target}), Close:{kind:2}}, import_react41 = require("module$node_modules$react$index"), import_react40 = require("module$node_modules$react$index"), import_react42 = require("module$node_modules$react$index"), 
  import_react43 = require("module$node_modules$react$index"), overflows = function(initial, actions) {
    let state = initial(), listeners = new Set();
    return {getSnapshot() {
      return state;
    }, subscribe(onChange) {
      listeners.add(onChange);
      return () => listeners.delete(onChange);
    }, dispatch(key, ...args) {
      if (key = actions[key].call(state, ...args)) {
        state = key, listeners.forEach(listener => listener());
      }
    }};
  }(() => new Map(), {PUSH(doc, meta) {
    var _a3;
    let entry = null != (_a3 = this.get(doc)) ? _a3 : {doc, count:0, d:disposables(), meta:new Set(), computedMeta:{}};
    entry.count++;
    entry.meta.add(meta);
    entry.computedMeta = buildMeta(entry.meta);
    this.set(doc, entry);
    return this;
  }, POP(doc, meta) {
    if (doc = this.get(doc)) {
      doc.count--, doc.meta.delete(meta), doc.computedMeta = buildMeta(doc.meta);
    }
    return this;
  }, SCROLL_PREVENT(entry) {
    let ctx = {doc:entry.doc, d:entry.d, meta() {
      return entry.computedMeta;
    }}, steps = [handleIOSLocking(), adjustScrollbarPadding(), preventScroll()];
    steps.forEach(({before}) => null == before ? void 0 : before(ctx));
    steps.forEach(({after}) => null == after ? void 0 : after(ctx));
  }, SCROLL_ALLOW({d}) {
    d.dispose();
  }, TEARDOWN({doc}) {
    this.delete(doc);
  }});
  overflows.subscribe(() => {
    var docs = overflows.getSnapshot();
    let styles = new Map();
    for (var [doc] of docs) {
      styles.set(doc, doc.documentElement.style.overflow);
    }
    for (let entry of docs.values()) {
      docs = "hidden" === styles.get(entry.doc), ((doc = 0 !== entry.count) && !docs || !doc && docs) && overflows.dispatch(0 < entry.count ? "SCROLL_PREVENT" : "SCROLL_ALLOW", entry), 0 === entry.count && overflows.dispatch("TEARDOWN", entry);
    }
  });
  var import_react44 = require("module$node_modules$react$index"), import_react46 = require("module$node_modules$react$index"), import_react45 = require("module$node_modules$react$index"), _a, _b;
  "undefined" !== typeof process && "undefined" !== typeof globalThis && "undefined" !== typeof Element && "test" === (null == (_a = null == process ? void 0 : process.env) ? void 0 : _a.NODE_ENV) && "undefined" === typeof(null == (_b = null == Element ? void 0 : Element.prototype) ? void 0 : _b.getAnimations) && (Element.prototype.getAnimations = function() {
    console.warn("Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.\nPlease install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.\n\nExample usage:\n```js\nimport { mockAnimationsApi } from 'jsdom-testing-mocks'\nmockAnimationsApi()\n```");
    return [];
  });
  var import_react47 = require("module$node_modules$react$index"), import_react48 = require("module$node_modules$react$index"), React13 = __toESM(require("module$node_modules$react$index"), 1), import_react50 = require("module$node_modules$react$index"), min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, oppositeSideMap = {left:"right", right:"left", bottom:"top", top:"bottom"}, oppositeAlignmentMap = {start:"end", end:"start"}, computePosition = async(reference, floating, config) => 
  {
    const {placement = "bottom", strategy = "absolute", middleware = [], platform:platform2} = config;
    config = middleware.filter(Boolean);
    const rtl = await (null == platform2.isRTL ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({reference, floating, strategy}), {x, y} = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
    for (let i = 0; i < config.length; i++) {
      const {name, fn} = config[i], {x:nextX, y:nextY, data, reset} = await fn({x, y, initialPlacement:placement, placement:statefulPlacement, strategy, middlewareData, rects, platform:platform2, elements:{reference, floating}});
      x = null != nextX ? nextX : x;
      y = null != nextY ? nextY : y;
      middlewareData = {...middlewareData, [name]:{...middlewareData[name], ...data}};
      reset && 50 >= resetCount && (resetCount++, "object" === typeof reset && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = !0 === reset.rects ? await platform2.getElementRects({reference, floating, strategy}) : reset.rects), {x, y} = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i = -1);
    }
    return {x, y, placement:statefulPlacement, strategy, middlewareData};
  }, flip = function(options) {
    void 0 === options && (options = {});
    return {name:"flip", options, async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {placement, middlewareData, rects, initialPlacement, platform:platform2, elements} = state, {mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !0, fallbackPlacements:specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = !0, ...detectOverflowOptions} = evaluate(options, state);
      if (null != (_middlewareData$arrow = middlewareData.arrow) && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      _middlewareData$arrow = getSide(placement);
      var isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (null == platform2.isRTL ? void 0 : platform2.isRTL(elements.floating));
      isBasePlacement = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      specifiedFallbackPlacements || "none" === fallbackAxisSideDirection || isBasePlacement.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      isBasePlacement = [initialPlacement, ...isBasePlacement];
      const overflow = await detectOverflow(state, detectOverflowOptions), overflows2 = [];
      state = (null == (_middlewareData$flip = middlewareData.flip) ? void 0 : _middlewareData$flip.overflows) || [];
      checkMainAxis && overflows2.push(overflow[_middlewareData$arrow]);
      checkCrossAxis && (_middlewareData$flip = getAlignmentSides(placement, rects, rtl), overflows2.push(overflow[_middlewareData$flip[0]], overflow[_middlewareData$flip[1]]));
      state = [...state, {placement, overflows:overflows2}];
      if (!overflows2.every(side2 => 0 >= side2)) {
        var _middlewareData$flip2, _overflowsData$filter;
        _middlewareData$flip = ((null == (_middlewareData$flip2 = middlewareData.flip) ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        if (_middlewareData$flip2 = isBasePlacement[_middlewareData$flip]) {
          return {data:{index:_middlewareData$flip, overflows:state}, reset:{placement:_middlewareData$flip2}};
        }
        _middlewareData$flip2 = null == (_overflowsData$filter = state.filter(d => 0 >= d.overflows[0]).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) ? void 0 : _overflowsData$filter.placement;
        if (!_middlewareData$flip2) {
          switch(fallbackStrategy) {
            case "bestFit":
              var _overflowsData$map$so;
              (_overflowsData$filter = null == (_overflowsData$map$so = state.map(d => [d.placement, d.overflows.filter(overflow2 => 0 < overflow2).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) ? void 0 : _overflowsData$map$so[0]) && (_middlewareData$flip2 = _overflowsData$filter);
              break;
            case "initialPlacement":
              _middlewareData$flip2 = initialPlacement;
          }
        }
        if (placement !== _middlewareData$flip2) {
          return {reset:{placement:_middlewareData$flip2}};
        }
      }
      return {};
    }};
  }, offset = function(options) {
    void 0 === options && (options = 0);
    return {name:"offset", options, async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {x, y, placement, middlewareData} = state;
      state = await convertValueToCoords(state, options);
      return placement === (null == (_middlewareData$offse = middlewareData.offset) ? void 0 : _middlewareData$offse.placement) && null != (_middlewareData$arrow = middlewareData.arrow) && _middlewareData$arrow.alignmentOffset ? {} : {x:x + state.x, y:y + state.y, data:{...state, placement}};
    }};
  }, shift = function(options) {
    void 0 === options && (options = {});
    return {name:"shift", options, async fn(state) {
      const {x, y, placement} = state, {mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !1, limiter = {fn:_ref => {
        let {x:x2, y:y2} = _ref;
        return {x:x2, y:y2};
      }}, ...detectOverflowOptions} = evaluate(options, state);
      var coords = {x, y};
      const overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      coords = coords[crossAxis];
      checkMainAxis && (mainAxisCoord = max(mainAxisCoord + overflow["y" === mainAxis ? "top" : "left"], min(mainAxisCoord, mainAxisCoord - overflow["y" === mainAxis ? "bottom" : "right"])));
      checkCrossAxis && (coords = max(coords + overflow["y" === crossAxis ? "top" : "left"], min(coords, coords - overflow["y" === crossAxis ? "bottom" : "right"])));
      state = limiter.fn({...state, [mainAxis]:mainAxisCoord, [crossAxis]:coords});
      return {...state, data:{x:state.x - x, y:state.y - y}};
    }};
  }, size = function(options) {
    void 0 === options && (options = {});
    return {name:"size", options, async fn(state) {
      const {placement, rects, platform:platform2, elements} = state, {apply = () => {
      }, ...detectOverflowOptions} = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions);
      var side = getSide(placement), alignment = placement.split("-")[1];
      const isYAxis = "y" === getSideAxis(placement), {width, height} = rects.floating;
      if ("top" === side || "bottom" === side) {
        var heightSide = side;
        side = alignment === (await (null == platform2.isRTL ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        heightSide = "end" === alignment ? "top" : "bottom";
      }
      var overflowAvailableHeight = height - overflow[heightSide], overflowAvailableWidth = width - overflow[side], noShift = !state.middlewareData.shift;
      side = overflowAvailableHeight;
      heightSide = overflowAvailableWidth;
      isYAxis ? (heightSide = width - overflow.left - overflow.right, heightSide = alignment || noShift ? min(overflowAvailableWidth, heightSide) : heightSide) : (side = height - overflow.top - overflow.bottom, side = alignment || noShift ? min(overflowAvailableHeight, side) : side);
      noShift && !alignment && (alignment = max(overflow.left, 0), overflowAvailableHeight = max(overflow.right, 0), noShift = max(overflow.top, 0), overflowAvailableWidth = max(overflow.bottom, 0), isYAxis ? heightSide = width - 2 * (0 !== alignment || 0 !== overflowAvailableHeight ? alignment + overflowAvailableHeight : max(overflow.left, overflow.right)) : side = height - 2 * (0 !== noShift || 0 !== overflowAvailableWidth ? noShift + overflowAvailableWidth : max(overflow.top, overflow.bottom)));
      await apply({...state, availableWidth:heightSide, availableHeight:side});
      state = await platform2.getDimensions(elements.floating);
      return width !== state.width || height !== state.height ? {reset:{rects:!0}} : {};
    }};
  }, noOffsets = {x:0, y:0}, platform = {convertOffsetParentRelativeRectToViewportRelativeRect:function(_ref) {
    let {rect, offsetParent, strategy} = _ref;
    var isOffsetParentAnElement = isHTMLElement2(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    if (offsetParent === documentElement) {
      return rect;
    }
    _ref = {scrollLeft:0, scrollTop:0};
    let scale = {x:1, y:1};
    var JSCompiler_object_inline_x_275 = 0, JSCompiler_object_inline_y_276 = 0;
    if (isOffsetParentAnElement || !isOffsetParentAnElement && "fixed" !== strategy) {
      if ("body" !== getNodeName(offsetParent) || isOverflowElement(documentElement)) {
        _ref = getNodeScroll(offsetParent);
      }
      isHTMLElement2(offsetParent) && (isOffsetParentAnElement = getBoundingClientRect(offsetParent), scale = getScale(offsetParent), JSCompiler_object_inline_x_275 = isOffsetParentAnElement.x + offsetParent.clientLeft, JSCompiler_object_inline_y_276 = isOffsetParentAnElement.y + offsetParent.clientTop);
    }
    return {width:rect.width * scale.x, height:rect.height * scale.y, x:rect.x * scale.x - _ref.scrollLeft * scale.x + JSCompiler_object_inline_x_275, y:rect.y * scale.y - _ref.scrollTop * scale.y + JSCompiler_object_inline_y_276};
  }, getDocumentElement, getClippingRect:function(_ref) {
    let {element, boundary, rootBoundary, strategy} = _ref;
    _ref = [...("clippingAncestors" === boundary ? getClippingElementAncestors(element, this._c) : [].concat(boundary)), rootBoundary];
    _ref = _ref.reduce((accRect, clippingAncestor) => {
      clippingAncestor = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(clippingAncestor.top, accRect.top);
      accRect.right = min(clippingAncestor.right, accRect.right);
      accRect.bottom = min(clippingAncestor.bottom, accRect.bottom);
      accRect.left = max(clippingAncestor.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, _ref[0], strategy));
    return {width:_ref.right - _ref.left, height:_ref.bottom - _ref.top, x:_ref.left, y:_ref.top};
  }, getOffsetParent, getElementRects:async function(_ref) {
    let {reference, floating, strategy} = _ref;
    _ref = this.getDimensions;
    var offsetParent = await (this.getOffsetParent || getOffsetParent)(floating), isOffsetParentAnElement = isHTMLElement2(offsetParent);
    const documentElement = getDocumentElement(offsetParent), isFixed = "fixed" === strategy, rect = getBoundingClientRect(reference, !0, isFixed, offsetParent);
    let scroll = {scrollLeft:0, scrollTop:0};
    var JSCompiler_object_inline_x_289 = 0, JSCompiler_object_inline_y_290 = 0;
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if ("body" !== getNodeName(offsetParent) || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      isOffsetParentAnElement ? (isOffsetParentAnElement = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent), JSCompiler_object_inline_x_289 = isOffsetParentAnElement.x + offsetParent.clientLeft, JSCompiler_object_inline_y_290 = isOffsetParentAnElement.y + offsetParent.clientTop) : documentElement && (JSCompiler_object_inline_x_289 = getBoundingClientRect(getDocumentElement(documentElement)).left + getNodeScroll(documentElement).scrollLeft);
    }
    return {reference:{x:rect.left + scroll.scrollLeft - JSCompiler_object_inline_x_289, y:rect.top + scroll.scrollTop - JSCompiler_object_inline_y_290, width:rect.width, height:rect.height}, floating:{x:0, y:0, ...(await _ref(floating))}};
  }, getClientRects:function(element) {
    return Array.from(element.getClientRects());
  }, getDimensions:function(element) {
    return getCssDimensions(element);
  }, getScale, isElement:isElement3, isRTL:function(element) {
    return "rtl" === getComputedStyle2(element).direction;
  }}, computePosition2 = (reference, floating, options) => {
    const cache = new Map();
    options = {platform, ...options};
    return computePosition(reference, floating, {...options, platform:{...options.platform, _c:cache}});
  }, React12 = __toESM(require("module$node_modules$react$index"), 1), import_react49 = require("module$node_modules$react$index"), ReactDOM = __toESM(require("module$node_modules$react_dom$index"), 1), index = "undefined" !== typeof document ? import_react49.useLayoutEffect : import_react49.useEffect, offset2 = (options, deps) => ({...offset(options), options:[options, deps]}), shift2 = (options, deps) => ({...shift(options), options:[options, deps]}), flip2 = (options, deps) => ({...flip(options), 
  options:[options, deps]}), size2 = (options, deps) => ({...size(options), options:[options, deps]}), import_react_dom6 = require("module$node_modules$react_dom$index"), SafeReact = {...React13}, useSafeInsertionEffect = SafeReact.useInsertionEffect || (fn => fn()), index2 = "undefined" !== typeof document ? import_react50.useLayoutEffect : import_react50.useEffect, serverHandoffComplete = !1, count = 0, genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++, useId3 = SafeReact.useId || 
  useFloatingId;
  var devMessageSet = new Set();
  var FloatingNodeContext = React13.createContext(null), FloatingTreeContext = React13.createContext(null), useFloatingParentNodeId = () => {
    var _React$useContext;
    return (null == (_React$useContext = React13.useContext(FloatingNodeContext)) ? void 0 : _React$useContext.id) || null;
  }, inner = props => ({name:"inner", options:props, async fn(state) {
    const {listRef, overflowRef, onFallbackChange, offset:innerOffset = 0, index:index3 = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions} = props, {rects, elements:{floating}} = state, item = listRef.current[index3];
    state.placement.startsWith("bottom") || warn('`placement` side must be "bottom" when using the `inner`', "middleware.");
    if (!item) {
      return {};
    }
    state = {...state, ...(await offset2(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))};
    const el = (null == scrollRef ? void 0 : scrollRef.current) || floating, overflow = await detectOverflow(getArgsWithCustomFloatingHeight(state, el.scrollHeight), detectOverflowOptions), refOverflow = await detectOverflow(state, {...detectOverflowOptions, elementContext:"reference"}), diffY = Math.max(0, overflow.top), nextY = state.y + diffY;
    el.style.maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom)) + "px";
    el.scrollTop = diffY;
    onFallbackChange && (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold ? (0,import_react_dom6.flushSync)(() => onFallbackChange(!0)) : (0,import_react_dom6.flushSync)(() => onFallbackChange(!1)));
    overflowRef && (overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({...state, y:nextY}, el.offsetHeight), detectOverflowOptions));
    return {y:nextY};
  }}), React14 = __toESM(require("module$node_modules$react$index"), 1), import_react52 = require("module$node_modules$react$index"), FloatingContext = (0,import_react52.createContext)({styles:void 0, setReference:() => {
  }, setFloating:() => {
  }, getReferenceProps:() => ({}), getFloatingProps:() => ({}), slot:{}});
  FloatingContext.displayName = "FloatingContext";
  var PlacementContext = (0,import_react52.createContext)(null);
  PlacementContext.displayName = "PlacementContext";
  var import_react53 = __toESM(require("module$node_modules$react$index"), 1), Frozen = import_react53.default.forwardRef(function({children, freeze}, ref) {
    children = useFrozenData(freeze, children);
    return (0,import_react53.isValidElement)(children) ? (0,import_react53.cloneElement)(children, {ref}) : import_react53.default.createElement(import_react53.default.Fragment, null, children);
  }), import_react54 = __toESM(require("module$node_modules$react$index"), 1), Context = (0,import_react54.createContext)(null);
  Context.displayName = "OpenClosedContext";
  var history = [];
  (function(cb) {
    function check() {
      "loading" !== document.readyState && (cb(), document.removeEventListener("DOMContentLoaded", check));
    }
    "undefined" !== typeof window && "undefined" !== typeof document && (document.addEventListener("DOMContentLoaded", check), check());
  })(() => {
    function handle(e) {
      if (isHTMLorSVGElement(e.target) && e.target !== document.body && history[0] !== e.target) {
        var focusableElement = e.target;
        focusableElement = focusableElement.closest(focusableSelector);
        history.unshift(null != focusableElement ? focusableElement : e.target);
        history = history.filter(x => null != x && x.isConnected);
        history.splice(10);
      }
    }
    window.addEventListener("click", handle, {capture:!0});
    window.addEventListener("mousedown", handle, {capture:!0});
    window.addEventListener("focus", handle, {capture:!0});
    document.body.addEventListener("click", handle, {capture:!0});
    document.body.addEventListener("mousedown", handle, {capture:!0});
    document.body.addEventListener("focus", handle, {capture:!0});
  });
  var import_react57 = __toESM(require("module$node_modules$react$index"), 1), import_react_dom7 = require("module$node_modules$react_dom$index"), import_react55 = require("module$node_modules$react$index"), import_react56 = __toESM(require("module$node_modules$react$index"), 1), ForcePortalRootContext = (0,import_react56.createContext)(!1), DEFAULT_PORTAL_TAG = import_react57.Fragment, InternalPortalFn = forwardRefWithAs(function(props, ref) {
    let {ownerDocument:incomingOwnerDocument = null, ...theirProps} = props, internalPortalRootRef = (0,import_react57.useRef)(null);
    props = useSyncRefs(optionalRef(ref2 => {
      internalPortalRootRef.current = ref2;
    }), ref);
    ref = useOwnerDocument(internalPortalRootRef.current);
    let target = usePortalTarget(null != incomingOwnerDocument ? incomingOwnerDocument : ref), parent = (0,import_react57.useContext)(PortalParentContext), d = useDisposables();
    ref = useRender();
    useOnUnmount(() => {
      var _a3;
      target && 0 >= target.childNodes.length && (null == (_a3 = target.parentElement) || _a3.removeChild(target));
    });
    props = {ref:props};
    return target ? (0,import_react_dom7.createPortal)(import_react57.default.createElement("div", {"data-headlessui-portal":"", ref:el => {
      d.dispose();
      parent && el && d.add(parent.register(el));
    }}, ref({ourProps:props, theirProps, slot:{}, defaultTag:DEFAULT_PORTAL_TAG, name:"Portal"})), target) : null;
  }), DEFAULT_GROUP_TAG = import_react57.Fragment, PortalGroupContext = (0,import_react57.createContext)(null), PortalParentContext = (0,import_react57.createContext)(null), PortalRoot = forwardRefWithAs(function(props, ref) {
    ref = useSyncRefs(ref);
    let {enabled = !0, ownerDocument, ...theirProps} = props;
    props = useRender();
    return enabled ? import_react57.default.createElement(InternalPortalFn, {...theirProps, ownerDocument, ref}) : props({ourProps:{ref}, theirProps, slot:{}, defaultTag:DEFAULT_PORTAL_TAG, name:"Portal"});
  }), PortalGroup = forwardRefWithAs(function(props, ref) {
    let {target, ...theirProps} = props;
    props = {ref:useSyncRefs(ref)};
    ref = useRender();
    return import_react57.default.createElement(PortalGroupContext.Provider, {value:target}, ref({ourProps:props, theirProps, defaultTag:DEFAULT_GROUP_TAG, name:"Popover.Group"}));
  }), Portal = Object.assign(PortalRoot, {Group:PortalGroup}), ElementPositionState = {Idle:{kind:"Idle"}, Tracked:position => ({kind:"Tracked", position}), Moved:{kind:"Moved"}}, reducers2 = {[1](state) {
    var _a3;
    if ((null == (_a3 = state.dataRef.current) ? 0 : _a3.disabled) || 1 === state.comboboxState) {
      return state;
    }
    _a3 = state.inputElement ? ElementPositionState.Tracked(computeVisualPosition(state.inputElement)) : state.inputPositionState;
    return {...state, activeOptionIndex:null, comboboxState:1, isTyping:!1, activationTrigger:2, inputPositionState:_a3, __demoMode:!1};
  }, [0](state) {
    var _a3, _b2;
    if ((null == (_a3 = state.dataRef.current) ? 0 : _a3.disabled) || 0 === state.comboboxState) {
      return state;
    }
    if (null == (_b2 = state.dataRef.current) ? 0 : _b2.value) {
      if (_a3 = state.dataRef.current.calculateIndex(state.dataRef.current.value), -1 !== _a3) {
        return {...state, activeOptionIndex:_a3, comboboxState:0, __demoMode:!1, inputPositionState:ElementPositionState.Idle};
      }
    }
    return {...state, comboboxState:0, inputPositionState:ElementPositionState.Idle, __demoMode:!1};
  }, [3](state, action) {
    return state.isTyping === action.isTyping ? state : {...state, isTyping:action.isTyping};
  }, [2](state, action) {
    var _a3, _b2, _c;
    if ((null == (_a3 = state.dataRef.current) ? 0 : _a3.disabled) || state.optionsElement && (null == (_b2 = state.dataRef.current) || !_b2.optionsPropsRef.current.static) && 1 === state.comboboxState) {
      return state;
    }
    if (state.virtual) {
      let {options, disabled} = state.virtual;
      var _d = 4 === action.focus ? action.idx : calculateActiveIndex(action, {resolveItems:() => options, resolveActiveIndex:() => {
        var _a4, _b3;
        return null != (_b3 = null != (_a4 = state.activeOptionIndex) ? _a4 : options.findIndex(option => !disabled(option))) ? _b3 : null;
      }, resolveDisabled:disabled, resolveId() {
        throw Error("Function not implemented.");
      }});
      action = null != (_c = action.trigger) ? _c : 2;
      return state.activeOptionIndex === _d && state.activationTrigger === action ? state : {...state, activeOptionIndex:_d, activationTrigger:action, isTyping:!1, __demoMode:!1};
    }
    let adjustedState = adjustOrderedState(state);
    null === adjustedState.activeOptionIndex && (_c = adjustedState.options.findIndex(option => !option.dataRef.current.disabled), -1 !== _c && (adjustedState.activeOptionIndex = _c));
    _c = 4 === action.focus ? action.idx : calculateActiveIndex(action, {resolveItems:() => adjustedState.options, resolveActiveIndex:() => adjustedState.activeOptionIndex, resolveId:item => item.id, resolveDisabled:item => item.dataRef.current.disabled});
    action = null != (_d = action.trigger) ? _d : 2;
    return state.activeOptionIndex === _c && state.activationTrigger === action ? state : {...state, ...adjustedState, isTyping:!1, activeOptionIndex:_c, activationTrigger:action, __demoMode:!1};
  }, [4]:(state, action) => {
    var _a3, _b2, _c, _d;
    if (null == (_a3 = state.dataRef.current) ? 0 : _a3.virtual) {
      return {...state, options:[...state.options, action.payload]};
    }
    let option = action.payload;
    _a3 = adjustOrderedState(state, options => {
      options.push(option);
      return options;
    });
    null === state.activeOptionIndex && (null == (_c = (_b2 = state.dataRef.current).isSelected) ? 0 : _c.call(_b2, action.payload.dataRef.current.value)) && (_a3.activeOptionIndex = _a3.options.indexOf(option));
    action = {...state, ..._a3, activationTrigger:2};
    (null == (_d = state.dataRef.current) ? 0 : _d.__demoMode) && void 0 === state.dataRef.current.value && (action.activeOptionIndex = 0);
    return action;
  }, [5]:(state, action) => {
    var _a3;
    if (null == (_a3 = state.dataRef.current) ? 0 : _a3.virtual) {
      return {...state, options:state.options.filter(option => option.id !== action.id)};
    }
    _a3 = adjustOrderedState(state, options => {
      let idx = options.findIndex(option => option.id === action.id);
      -1 !== idx && options.splice(idx, 1);
      return options;
    });
    return {...state, ..._a3, activationTrigger:2};
  }, [6]:(state, action) => state.defaultToFirstOption === action.value ? state : {...state, defaultToFirstOption:action.value}, [7]:(state, action) => state.activationTrigger === action.trigger ? state : {...state, activationTrigger:action.trigger}, [8]:(state, action) => {
    var _a3, _b2;
    if (null === state.virtual) {
      return {...state, virtual:{options:action.options, disabled:null != (_a3 = action.disabled) ? _a3 : () => !1}};
    }
    if (state.virtual.options === action.options && state.virtual.disabled === action.disabled) {
      return state;
    }
    _a3 = state.activeOptionIndex;
    null !== state.activeOptionIndex && (_a3 = action.options.indexOf(state.virtual.options[state.activeOptionIndex]), _a3 = -1 !== _a3 ? _a3 : null);
    return {...state, activeOptionIndex:_a3, virtual:{options:action.options, disabled:null != (_b2 = action.disabled) ? _b2 : () => !1}};
  }, [9]:(state, action) => state.inputElement === action.element ? state : {...state, inputElement:action.element}, [10]:(state, action) => state.buttonElement === action.element ? state : {...state, buttonElement:action.element}, [11]:(state, action) => state.optionsElement === action.element ? state : {...state, optionsElement:action.element}, [12](state) {
    return "Tracked" !== state.inputPositionState.kind ? state : {...state, inputPositionState:ElementPositionState.Moved};
  }}, ComboboxMachine = class extends Machine {
    constructor(initialState) {
      super(initialState);
      __publicField(this, "actions", {onChange:newValue => {
        let {onChange, compare, mode, value} = this.state.dataRef.current;
        return match(mode, {[0]:() => null == onChange ? void 0 : onChange(newValue), [1]:() => {
          let copy = value.slice(), idx = copy.findIndex(item => compare(item, newValue));
          -1 === idx ? copy.push(newValue) : copy.splice(idx, 1);
          return null == onChange ? void 0 : onChange(copy);
        }});
      }, registerOption:(id, dataRef) => {
        this.send({type:4, payload:{id, dataRef}});
        return () => {
          this.state.activeOptionIndex === this.state.dataRef.current.calculateIndex(dataRef.current.value) && this.send({type:6, value:!0});
          this.send({type:5, id});
        };
      }, goToOption:(focus, trigger) => {
        this.send({type:6, value:!1});
        return this.send({type:2, ...focus, trigger});
      }, setIsTyping:isTyping => {
        this.send({type:3, isTyping});
      }, closeCombobox:() => {
        var _a3, _b2;
        this.send({type:1});
        this.send({type:6, value:!1});
        null == (_b2 = (_a3 = this.state.dataRef.current).onClose) || _b2.call(_a3);
      }, openCombobox:() => {
        this.send({type:0});
        this.send({type:6, value:!0});
      }, setActivationTrigger:trigger => {
        this.send({type:7, trigger});
      }, selectActiveOption:() => {
        let activeOptionIndex = this.selectors.activeOptionIndex(this.state);
        if (null !== activeOptionIndex) {
          this.actions.setIsTyping(!1);
          if (this.state.virtual) {
            this.actions.onChange(this.state.virtual.options[activeOptionIndex]);
          } else {
            let {dataRef} = this.state.options[activeOptionIndex];
            this.actions.onChange(dataRef.current.value);
          }
          this.actions.goToOption({focus:4, idx:activeOptionIndex});
        }
      }, setInputElement:element => {
        this.send({type:9, element});
      }, setButtonElement:element => {
        this.send({type:10, element});
      }, setOptionsElement:element => {
        this.send({type:11, element});
      }});
      __publicField(this, "selectors", {activeDescendantId:state => {
        var _a3, _b2;
        let activeOptionIndex = this.selectors.activeOptionIndex(state);
        if (null !== activeOptionIndex) {
          return state.virtual ? null == (_b2 = state.options.find(option => !option.dataRef.current.disabled && state.dataRef.current.compare(option.dataRef.current.value, state.virtual.options[activeOptionIndex]))) ? void 0 : _b2.id : null == (_a3 = state.options[activeOptionIndex]) ? void 0 : _a3.id;
        }
      }, activeOptionIndex:state => {
        if (state.defaultToFirstOption && null === state.activeOptionIndex && (state.virtual ? 0 < state.virtual.options.length : 0 < state.options.length)) {
          if (state.virtual) {
            let {options, disabled} = state.virtual;
            var activeOptionIndex2 = options.findIndex(option => {
              var _a3;
              return !(null != (_a3 = null == disabled ? void 0 : disabled(option)) && _a3);
            });
            if (-1 !== activeOptionIndex2) {
              return activeOptionIndex2;
            }
          }
          activeOptionIndex2 = state.options.findIndex(option => !option.dataRef.current.disabled);
          if (-1 !== activeOptionIndex2) {
            return activeOptionIndex2;
          }
        }
        return state.activeOptionIndex;
      }, activeOption:state => {
        var _a3, _b2;
        let activeOptionIndex = this.selectors.activeOptionIndex(state);
        return null === activeOptionIndex ? null : state.virtual ? state.virtual.options[null != activeOptionIndex ? activeOptionIndex : 0] : null != (_b2 = null == (_a3 = state.options[activeOptionIndex]) ? void 0 : _a3.dataRef.current.value) ? _b2 : null;
      }, isActive:(state, value, id) => {
        var _a3;
        let activeOptionIndex = this.selectors.activeOptionIndex(state);
        return null === activeOptionIndex ? !1 : state.virtual ? activeOptionIndex === state.dataRef.current.calculateIndex(value) : (null == (_a3 = state.options[activeOptionIndex]) ? void 0 : _a3.id) === id;
      }, shouldScrollIntoView:(state, value, id) => state.virtual || state.__demoMode || 0 !== state.comboboxState || 0 === state.activationTrigger || !this.selectors.isActive(state, value, id) ? !1 : !0, didInputMove(state) {
        return "Moved" === state.inputPositionState.kind;
      }});
      let id = this.state.id, stackMachine = stackMachines.get(null);
      this.disposables.add(stackMachine.on(0, state => {
        stackMachine.selectors.isTop(state, id) || 0 !== this.state.comboboxState || this.actions.closeCombobox();
      }));
      this.on(0, () => stackMachine.actions.push(id));
      this.on(1, () => stackMachine.actions.pop(id));
      this.disposables.group(d => {
        this.on(1, state => {
          state.inputElement && (d.dispose(), d.add(detectMovement(state.inputElement, state.inputPositionState, () => {
            this.send({type:12});
          })));
        });
      });
    }
    static new({id, virtual = null, __demoMode = !1}) {
      var _a3;
      return new ComboboxMachine({id, dataRef:{current:{}}, comboboxState:__demoMode ? 0 : 1, isTyping:!1, options:[], virtual:virtual ? {options:virtual.options, disabled:null != (_a3 = virtual.disabled) ? _a3 : () => !1} : null, activeOptionIndex:null, activationTrigger:2, inputElement:null, buttonElement:null, optionsElement:null, __demoMode, inputPositionState:ElementPositionState.Idle});
    }
    reduce(state, action) {
      return match(action.type, reducers2, state, action);
    }
  }, import_react58 = require("module$node_modules$react$index"), ComboboxContext = (0,import_react58.createContext)(null), ComboboxDataContext = (0,import_react59.createContext)(null);
  ComboboxDataContext.displayName = "ComboboxDataContext";
  var VirtualContext = (0,import_react59.createContext)(null), DEFAULT_COMBOBOX_TAG = import_react59.Fragment, ComboboxRoot = forwardRefWithAs(function(props, ref) {
    let id = (0,import_react20.useId)();
    var providedDisabled = useDisabled();
    let {value:controlledValue, defaultValue:_defaultValue, onChange:controlledOnChange, form, name, by, invalid = !1, disabled = providedDisabled || !1, onClose:theirOnClose, __demoMode = !1, multiple = !1, immediate = !1, virtual = null, nullable:_nullable, ...theirProps} = props, defaultValue = useDefaultValue(_defaultValue), [value = multiple ? [] : void 0, theirOnChange] = useControllable(controlledValue, controlledOnChange, defaultValue), machine = useComboboxMachine({id, virtual, __demoMode}), 
    optionsPropsRef = (0,import_react59.useRef)({static:!1, hold:!1}), compare = useByComparator(by), calculateIndex = useEvent(value2 => virtual ? null === by ? virtual.options.indexOf(value2) : virtual.options.findIndex(other => compare(other, value2)) : machine.state.options.findIndex(other => compare(other.dataRef.current.value, value2))), isSelected = (0,import_react59.useCallback)(other => match(data.mode, {[1]:() => value.some(option => compare(option, other)), [0]:() => compare(value, other)}), 
    [value]), virtualSlice = useSlice(machine, state => state.virtual), onClose = useEvent(() => null == theirOnClose ? void 0 : theirOnClose()), data = (0,import_react59.useMemo)(() => ({__demoMode, immediate, optionsPropsRef, value, defaultValue, disabled, invalid, mode:multiple ? 1 : 0, virtual:virtual ? virtualSlice : null, onChange:theirOnChange, isSelected, calculateIndex, compare, onClose}), [__demoMode, immediate, optionsPropsRef, value, defaultValue, disabled, invalid, multiple, virtual, 
    virtualSlice, theirOnChange, isSelected, calculateIndex, compare, onClose]);
    useIsoMorphicEffect(() => {
      var _a3;
      virtual && machine.send({type:8, options:virtual.options, disabled:null != (_a3 = virtual.disabled) ? _a3 : null});
    }, [virtual, null == virtual ? void 0 : virtual.options, null == virtual ? void 0 : virtual.disabled]);
    useIsoMorphicEffect(() => {
      machine.state.dataRef.current = data;
    }, [data]);
    let [comboboxState, buttonElement, inputElement, optionsElement] = useSlice(machine, state => [state.comboboxState, state.buttonElement, state.inputElement, state.optionsElement]), stackMachine = stackMachines.get(null);
    props = useSlice(stackMachine, (0,import_react59.useCallback)(state => stackMachine.selectors.isTop(state, id), [stackMachine, id]));
    useOutsideClick(props, [buttonElement, inputElement, optionsElement], () => machine.actions.closeCombobox());
    props = useSlice(machine, machine.selectors.activeOptionIndex);
    providedDisabled = useSlice(machine, machine.selectors.activeOption);
    props = useSlot({open:0 === comboboxState, disabled, invalid, activeIndex:props, activeOption:providedDisabled, value});
    let [labelledby, LabelProvider] = useLabels();
    ref = null === ref ? {} : {ref};
    providedDisabled = (0,import_react59.useCallback)(() => {
      if (void 0 !== defaultValue) {
        return null == theirOnChange ? void 0 : theirOnChange(defaultValue);
      }
    }, [theirOnChange, defaultValue]);
    let render2 = useRender();
    return import_react59.default.createElement(LabelProvider, {value:labelledby, props:{htmlFor:null == inputElement ? void 0 : inputElement.id}, slot:{open:0 === comboboxState, disabled}}, import_react59.default.createElement(FloatingProvider, null, import_react59.default.createElement(ComboboxDataContext.Provider, {value:data}, import_react59.default.createElement(ComboboxContext.Provider, {value:machine}, import_react59.default.createElement(OpenClosedProvider, {value:match(comboboxState, {[0]:1, 
    [1]:2})}, null != name && import_react59.default.createElement(FormFields, {disabled, data:null != value ? {[name]:value} : {}, form, onReset:providedDisabled}), render2({ourProps:ref, theirProps, slot:props, defaultTag:DEFAULT_COMBOBOX_TAG, name:"Combobox"}))))));
  }), ComboboxButton = forwardRefWithAs(function(props, ref) {
    let machine = useComboboxMachineContext("Combobox.Button"), data = useData("Combobox.Button"), [localButtonElement, setLocalButtonElement] = (0,import_react59.useState)(null);
    ref = useSyncRefs(ref, setLocalButtonElement, machine.actions.setButtonElement);
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-combobox-button-${internalId}`, disabled = data.disabled || !1, autoFocus = !1, ...theirProps} = props, [comboboxState, inputElement, optionsElement] = useSlice(machine, state => [state.comboboxState, state.inputElement, state.optionsElement]), refocusInput = useRefocusableInput(inputElement);
    useQuickRelease(0 === comboboxState, {trigger:localButtonElement, action:(0,import_react59.useCallback)(e => {
      if ((null == localButtonElement ? 0 : localButtonElement.contains(e.target)) || (null == inputElement ? 0 : inputElement.contains(e.target))) {
        return Action.Ignore;
      }
      let option = e.target.closest('[role\x3d"option"]:not([data-disabled])');
      return isHTMLElement(option) ? Action.Select(option) : (null == optionsElement ? 0 : optionsElement.contains(e.target)) ? Action.Ignore : Action.Close;
    }, [localButtonElement, inputElement, optionsElement]), close:machine.actions.closeCombobox, select:machine.actions.selectActiveOption});
    let handleKeyDown = useEvent(event => {
      switch(event.key) {
        case " ":
        case "Enter":
          event.preventDefault();
          event.stopPropagation();
          1 === machine.state.comboboxState && (0,import_react_dom8.flushSync)(() => machine.actions.openCombobox());
          refocusInput();
          break;
        case "ArrowDown":
          event.preventDefault();
          event.stopPropagation();
          1 === machine.state.comboboxState && ((0,import_react_dom8.flushSync)(() => machine.actions.openCombobox()), machine.state.dataRef.current.value || machine.actions.goToOption({focus:0}));
          refocusInput();
          break;
        case "ArrowUp":
          event.preventDefault();
          event.stopPropagation();
          1 === machine.state.comboboxState && ((0,import_react_dom8.flushSync)(() => machine.actions.openCombobox()), machine.state.dataRef.current.value || machine.actions.goToOption({focus:3}));
          refocusInput();
          break;
        case "Escape":
          0 === machine.state.comboboxState && (event.preventDefault(), machine.state.optionsElement && !data.optionsPropsRef.current.static && event.stopPropagation(), (0,import_react_dom8.flushSync)(() => machine.actions.closeCombobox()), refocusInput());
      }
    }), toggleProps = useHandleToggle(() => {
      0 === machine.state.comboboxState ? machine.actions.closeCombobox() : machine.actions.openCombobox();
      refocusInput();
    }), labelledBy = useLabelledBy([id]), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    internalId = useSlot({open:0 === comboboxState, active:active || 0 === comboboxState, disabled, invalid:data.invalid, value:data.value, hover, focus});
    props = mergeProps({ref, id, type:useResolveButtonType(props, localButtonElement), tabIndex:-1, "aria-haspopup":"listbox", "aria-controls":null == optionsElement ? void 0 : optionsElement.id, "aria-expanded":0 === comboboxState, "aria-labelledby":labelledBy, disabled:disabled || void 0, autoFocus, onKeyDown:handleKeyDown}, toggleProps, focusProps, hoverProps, pressProps);
    return useRender()({ourProps:props, theirProps, slot:internalId, defaultTag:"button", name:"Combobox.Button"});
  }), ComboboxInput = forwardRefWithAs(function(props, ref) {
    var _a3, _b2;
    let machine = useComboboxMachineContext("Combobox.Input"), data = useData("Combobox.Input");
    var internalId = (0,import_react20.useId)(), providedId = useProvidedId();
    let {id = providedId || `headlessui-combobox-input-${internalId}`, onChange, displayValue, disabled = data.disabled || !1, autoFocus = !1, type = "text", ...theirProps} = props, internalInputRef = (0,import_react59.useRef)(null);
    ref = useSyncRefs(internalInputRef, ref, useFloatingReference(), machine.actions.setInputElement);
    let [comboboxState, isTyping] = useSlice(machine, state => [state.comboboxState, state.isTyping]), d = useDisposables(), clear = useEvent(() => {
      machine.actions.onChange(null);
      machine.state.optionsElement && (machine.state.optionsElement.scrollTop = 0);
      machine.actions.goToOption({focus:5});
    });
    internalId = (0,import_react59.useMemo)(() => {
      var _a4;
      return "function" === typeof displayValue && void 0 !== data.value ? null != (_a4 = displayValue(data.value)) ? _a4 : "" : "string" === typeof data.value ? data.value : "";
    }, [data.value, displayValue]);
    useWatch(([currentDisplayValue2, state], [oldCurrentDisplayValue, oldState]) => {
      if (!machine.state.isTyping) {
        var input = internalInputRef.current;
        input && (0 === oldState && 1 === state ? input.value = currentDisplayValue2 : currentDisplayValue2 !== oldCurrentDisplayValue && (input.value = currentDisplayValue2), requestAnimationFrame(() => {
          if (!machine.state.isTyping && input && !isActiveElement(input)) {
            var {selectionStart, selectionEnd} = input;
            0 === Math.abs((null != selectionEnd ? selectionEnd : 0) - (null != selectionStart ? selectionStart : 0)) && 0 === selectionStart && input.setSelectionRange(input.value.length, input.value.length);
          }
        }));
      }
    }, [internalId, comboboxState, isTyping]);
    useWatch(([newState], [oldState]) => {
      if (0 === newState && 1 === oldState && !machine.state.isTyping && (newState = internalInputRef.current)) {
        oldState = newState.value;
        var {selectionStart, selectionEnd, selectionDirection} = newState;
        newState.value = "";
        newState.value = oldState;
        null !== selectionDirection ? newState.setSelectionRange(selectionStart, selectionEnd, selectionDirection) : newState.setSelectionRange(selectionStart, selectionEnd);
      }
    }, [comboboxState]);
    let isComposing = (0,import_react59.useRef)(!1);
    internalId = useEvent(() => {
      isComposing.current = !0;
    });
    providedId = useEvent(() => {
      d.nextFrame(() => {
        isComposing.current = !1;
      });
    });
    let handleKeyDown = useEvent(event => {
      machine.actions.setIsTyping(!0);
      switch(event.key) {
        case "Enter":
          if (0 !== machine.state.comboboxState) {
            break;
          }
          if (isComposing.current) {
            break;
          }
          event.preventDefault();
          event.stopPropagation();
          if (null === machine.selectors.activeOptionIndex(machine.state)) {
            machine.actions.closeCombobox();
            break;
          }
          machine.actions.selectActiveOption();
          0 === data.mode && machine.actions.closeCombobox();
          break;
        case "ArrowDown":
          return event.preventDefault(), event.stopPropagation(), match(machine.state.comboboxState, {[0]:() => machine.actions.goToOption({focus:2}), [1]:() => machine.actions.openCombobox()});
        case "ArrowUp":
          return event.preventDefault(), event.stopPropagation(), match(machine.state.comboboxState, {[0]:() => machine.actions.goToOption({focus:1}), [1]:() => {
            (0,import_react_dom8.flushSync)(() => machine.actions.openCombobox());
            data.value || machine.actions.goToOption({focus:3});
          }});
        case "Home":
          if (1 === machine.state.comboboxState) {
            break;
          }
          if (event.shiftKey) {
            break;
          }
          event.preventDefault();
          event.stopPropagation();
          return machine.actions.goToOption({focus:0});
        case "PageUp":
          return event.preventDefault(), event.stopPropagation(), machine.actions.goToOption({focus:0});
        case "End":
          if (1 === machine.state.comboboxState) {
            break;
          }
          if (event.shiftKey) {
            break;
          }
          event.preventDefault();
          event.stopPropagation();
          return machine.actions.goToOption({focus:3});
        case "PageDown":
          return event.preventDefault(), event.stopPropagation(), machine.actions.goToOption({focus:3});
        case "Escape":
          if (0 !== machine.state.comboboxState) {
            break;
          }
          event.preventDefault();
          machine.state.optionsElement && !data.optionsPropsRef.current.static && event.stopPropagation();
          0 === data.mode && null === data.value && clear();
          return machine.actions.closeCombobox();
        case "Tab":
          machine.actions.setIsTyping(!1), 0 === machine.state.comboboxState && (0 === data.mode && 1 !== machine.state.activationTrigger && machine.actions.selectActiveOption(), machine.actions.closeCombobox());
      }
    }), handleChange = useEvent(event => {
      null == onChange || onChange(event);
      0 === data.mode && "" === event.target.value && clear();
      machine.actions.openCombobox();
    }), handleBlur = useEvent(event => {
      var _a4, _b3, _c;
      let relatedTarget = null != (_a4 = event.relatedTarget) ? _a4 : history.find(x => x !== event.currentTarget);
      if (!(null != (_b3 = machine.state.optionsElement) && _b3.contains(relatedTarget) || null != (_c = machine.state.buttonElement) && _c.contains(relatedTarget) || 0 !== machine.state.comboboxState)) {
        return event.preventDefault(), 0 === data.mode && null === data.value && clear(), machine.actions.closeCombobox();
      }
    }), handleFocus = useEvent(event => {
      var _a4, _b3, _c;
      let relatedTarget = null != (_a4 = event.relatedTarget) ? _a4 : history.find(x => x !== event.currentTarget);
      null != (_b3 = machine.state.buttonElement) && _b3.contains(relatedTarget) || (null == (_c = machine.state.optionsElement) ? 0 : _c.contains(relatedTarget)) || data.disabled || data.immediate && 0 !== machine.state.comboboxState && d.microTask(() => {
        (0,import_react_dom8.flushSync)(() => machine.actions.openCombobox());
        machine.actions.setActivationTrigger(1);
      });
    }), labelledBy = useLabelledBy(), describedBy = useDescribedBy(), {isFocused:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), optionsElement = useSlice(machine, state => state.optionsElement), slot = useSlot({open:0 === comboboxState, disabled, invalid:data.invalid, hover, focus, autofocus:autoFocus});
    props = mergeProps({ref, id, role:"combobox", type, "aria-controls":null == optionsElement ? void 0 : optionsElement.id, "aria-expanded":0 === comboboxState, "aria-activedescendant":useSlice(machine, machine.selectors.activeDescendantId), "aria-labelledby":labelledBy, "aria-describedby":describedBy, "aria-autocomplete":"list", defaultValue:null != (_b2 = null != (_a3 = props.defaultValue) ? _a3 : void 0 !== data.defaultValue ? null == displayValue ? void 0 : displayValue(data.defaultValue) : 
    null) ? _b2 : data.defaultValue, disabled:disabled || void 0, autoFocus, onCompositionStart:internalId, onCompositionEnd:providedId, onKeyDown:handleKeyDown, onChange:handleChange, onFocus:handleFocus, onBlur:handleBlur}, focusProps, hoverProps);
    return useRender()({ourProps:props, theirProps, slot, defaultTag:"input", name:"Combobox.Input"});
  }), ComboboxLabel = Label, ComboboxOptions = forwardRefWithAs(function(props, ref) {
    var _a3, _b2, _c, internalId = (0,import_react20.useId)();
    let {id = `headlessui-combobox-options-${internalId}`, hold = !1, anchor:rawAnchor, portal = !1, modal = !0, transition:transition2 = !1, ...theirProps} = props, machine = useComboboxMachineContext("Combobox.Options"), data = useData("Combobox.Options");
    var anchor = useResolvedAnchor(rawAnchor);
    anchor && (portal = !0);
    let [floatingRef, style] = useFloatingPanel(anchor), [localOptionsElement, setLocalOptionsElement] = (0,import_react59.useState)(null);
    var getFloatingPanelProps = useFloatingPanelProps();
    let optionsRef = useSyncRefs(ref, anchor ? floatingRef : null, machine.actions.setOptionsElement, setLocalOptionsElement), [comboboxState, inputElement, buttonElement, optionsElement, activationTrigger] = useSlice(machine, state => [state.comboboxState, state.inputElement, state.buttonElement, state.optionsElement, state.activationTrigger]);
    ref = useOwnerDocument(inputElement || buttonElement);
    internalId = useOwnerDocument(optionsElement);
    var usesOpenClosedState = useOpenClosed();
    let [visible, transitionData] = useTransition(transition2, localOptionsElement, null !== usesOpenClosedState ? 1 === (usesOpenClosedState & 1) : 0 === comboboxState);
    useOnDisappear(visible, inputElement, machine.actions.closeCombobox);
    useScrollLock(data.__demoMode ? !1 : modal && 0 === comboboxState, internalId);
    useInertOthers(data.__demoMode ? !1 : modal && 0 === comboboxState, {allowed:(0,import_react59.useCallback)(() => [inputElement, buttonElement, optionsElement], [inputElement, buttonElement, optionsElement])});
    internalId = useSlice(machine, machine.selectors.didInputMove) ? !1 : visible;
    useIsoMorphicEffect(() => {
      var _a4;
      data.optionsPropsRef.current.static = null != (_a4 = props.static) ? _a4 : !1;
    }, [data.optionsPropsRef, props.static]);
    useIsoMorphicEffect(() => {
      data.optionsPropsRef.current.hold = hold;
    }, [data.optionsPropsRef, hold]);
    useTreeWalker(0 === comboboxState, {container:optionsElement, accept(node) {
      return "option" === node.getAttribute("role") ? NodeFilter.FILTER_REJECT : node.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }, walk(node) {
      node.setAttribute("role", "none");
    }});
    let labelledBy = useLabelledBy([null == buttonElement ? void 0 : buttonElement.id]);
    usesOpenClosedState = useSlot({open:0 === comboboxState, option:void 0});
    let handleWheel = useEvent(() => {
      machine.actions.setActivationTrigger(0);
    }), handleMouseDown = useEvent(event => {
      event.preventDefault();
      machine.actions.setActivationTrigger(0);
    });
    anchor = mergeProps(anchor ? getFloatingPanelProps() : {}, {"aria-labelledby":labelledBy, role:"listbox", "aria-multiselectable":1 === data.mode ? !0 : void 0, id, ref:optionsRef, style:{...theirProps.style, ...style, "--input-width":useElementSize(visible, inputElement, !0).width, "--button-width":useElementSize(visible, buttonElement, !0).width}, onWheel:0 === activationTrigger ? void 0 : handleWheel, onMouseDown:handleMouseDown, ...transitionDataAttributes(transitionData)});
    getFloatingPanelProps = visible && 1 === comboboxState && !props.static;
    let options = useFrozenData(getFloatingPanelProps, null == (_a3 = data.virtual) ? void 0 : _a3.options), frozenValue = useFrozenData(getFloatingPanelProps, data.value), isSelected = (0,import_react59.useCallback)(compareValue => data.compare(frozenValue, compareValue), [data.compare, frozenValue]);
    _a3 = (0,import_react59.useMemo)(() => {
      if (!data.virtual) {
        return data;
      }
      if (void 0 === options) {
        throw Error("Missing `options` in virtual mode");
      }
      return options !== data.virtual.options ? {...data, virtual:{...data.virtual, options}} : data;
    }, [data, options, null == (_b2 = data.virtual) ? void 0 : _b2.options]);
    data.virtual && Object.assign(theirProps, {children:import_react59.default.createElement(ComboboxDataContext.Provider, {value:_a3}, import_react59.default.createElement(VirtualProvider, {slot:usesOpenClosedState}, theirProps.children))});
    _b2 = useRender();
    _a3 = (0,import_react59.useMemo)(() => 1 === data.mode ? data : {...data, isSelected}, [data, isSelected]);
    return import_react59.default.createElement(Portal, {enabled:portal ? props.static || visible : !1, ownerDocument:ref}, import_react59.default.createElement(ComboboxDataContext.Provider, {value:_a3}, _b2({ourProps:anchor, theirProps:{...theirProps, children:import_react59.default.createElement(Frozen, {freeze:getFloatingPanelProps}, "function" === typeof theirProps.children ? null == (_c = theirProps.children) ? void 0 : _c.call(theirProps, usesOpenClosedState) : theirProps.children)}, slot:usesOpenClosedState, 
    defaultTag:"div", features:3, visible:internalId, name:"Combobox.Options"})));
  }), ComboboxOption = forwardRefWithAs(function(props, ref) {
    var _a3, _b2, _c;
    let data = useData("Combobox.Option"), machine = useComboboxMachineContext("Combobox.Option");
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-combobox-option-${internalId}`, value, disabled = null != (_c = null == (_b2 = null == (_a3 = data.virtual) ? void 0 : _a3.disabled) ? void 0 : _b2.call(_a3, value)) ? _c : !1, order = null, ...theirProps} = props;
    [props] = useSlice(machine, state => [state.inputElement]);
    let refocusInput = useRefocusableInput(props), active = useSlice(machine, (0,import_react59.useCallback)(state => machine.selectors.isActive(state, value, id), [value, id]));
    props = data.isSelected(value);
    let internalOptionRef = (0,import_react59.useRef)(null), bag = useLatestValue({disabled, value, domRef:internalOptionRef, order});
    _a3 = (0,import_react59.useContext)(VirtualContext);
    _a3 = useSyncRefs(ref, internalOptionRef, _a3 ? _a3.measureElement : null);
    let select = useEvent(() => {
      machine.actions.setIsTyping(!1);
      machine.actions.onChange(value);
    });
    useIsoMorphicEffect(() => machine.actions.registerOption(id, bag), [bag, id]);
    let shouldScrollIntoView = useSlice(machine, (0,import_react59.useCallback)(state => machine.selectors.shouldScrollIntoView(state, value, id), [value, id]));
    useIsoMorphicEffect(() => {
      if (shouldScrollIntoView) {
        return disposables().requestAnimationFrame(() => {
          var _a4, _b3;
          null == (_b3 = null == (_a4 = internalOptionRef.current) ? void 0 : _a4.scrollIntoView) || _b3.call(_a4, {block:"nearest"});
        });
      }
    }, [shouldScrollIntoView, internalOptionRef]);
    _b2 = useEvent(event => {
      event.preventDefault();
      0 !== event.button || disabled || (select(), isIOS() || isAndroid() || requestAnimationFrame(() => refocusInput()), 0 === data.mode && machine.actions.closeCombobox());
    });
    _c = useEvent(() => {
      if (disabled) {
        return machine.actions.goToOption({focus:5});
      }
      let idx = data.calculateIndex(value);
      machine.actions.goToOption({focus:4, idx});
    });
    let pointer = useTrackedPointer();
    internalId = useEvent(evt => pointer.update(evt));
    let handleMove = useEvent(evt => {
      !pointer.wasMoved(evt) || disabled || active && 0 === machine.state.activationTrigger || (evt = data.calculateIndex(value), machine.actions.goToOption({focus:4, idx:evt}, 0));
    }), handleLeave = useEvent(evt => {
      pointer.wasMoved(evt) && (disabled || active && (data.optionsPropsRef.current.hold || 0 === machine.state.activationTrigger && machine.actions.goToOption({focus:5})));
    });
    ref = useSlot({active, focus:active, selected:props, disabled});
    props = {id, ref:_a3, role:"option", tabIndex:!0 === disabled ? void 0 : -1, "aria-disabled":!0 === disabled ? !0 : void 0, "aria-selected":props, disabled:void 0, onMouseDown:_b2, onFocus:_c, onPointerEnter:internalId, onMouseEnter:internalId, onPointerMove:handleMove, onMouseMove:handleMove, onPointerLeave:handleLeave, onMouseLeave:handleLeave};
    return useRender()({ourProps:props, theirProps, slot:ref, defaultTag:"div", name:"Combobox.Option"});
  }), Combobox = Object.assign(ComboboxRoot, {Input:ComboboxInput, Button:ComboboxButton, Label:ComboboxLabel, Options:ComboboxOptions, Option:ComboboxOption}), DEFAULT_DATA_INTERACTIVE_TAG = require("module$node_modules$react$index").Fragment, DataInteractive = forwardRefWithAs(function(props, ref) {
    ({...props} = props);
    let {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f(), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:!1}), {pressed:active, pressProps} = useActivePress({disabled:!1});
    ref = mergeProps({ref}, focusProps, hoverProps, pressProps);
    let slot = useSlot({hover, focus, active});
    return useRender()({ourProps:ref, theirProps:props, slot, defaultTag:DEFAULT_DATA_INTERACTIVE_TAG, name:"DataInteractive"});
  }), import_react67 = __toESM(require("module$node_modules$react$index"), 1), import_react61 = require("module$node_modules$react$index"), import_react62 = __toESM(require("module$node_modules$react$index"), 1), MainTreeContext = (0,import_react62.createContext)(null), React21 = __toESM(require("module$node_modules$react$index"), 1), import_react65 = __toESM(require("module$node_modules$react$index"), 1), import_react63 = require("module$node_modules$react$index"), import_react64 = require("module$node_modules$react$index"), 
  FocusTrapFeatures = (FocusTrapFeatures2 => {
    FocusTrapFeatures2[FocusTrapFeatures2.None = 0] = "None";
    FocusTrapFeatures2[FocusTrapFeatures2.InitialFocus = 1] = "InitialFocus";
    FocusTrapFeatures2[FocusTrapFeatures2.TabLock = 2] = "TabLock";
    FocusTrapFeatures2[FocusTrapFeatures2.FocusLock = 4] = "FocusLock";
    FocusTrapFeatures2[FocusTrapFeatures2.RestoreFocus = 8] = "RestoreFocus";
    FocusTrapFeatures2[FocusTrapFeatures2.AutoFocus = 16] = "AutoFocus";
    return FocusTrapFeatures2;
  })(FocusTrapFeatures || {}), FocusTrapRoot = forwardRefWithAs(function(props, ref) {
    let container = (0,import_react65.useRef)(null);
    ref = useSyncRefs(container, ref);
    let {initialFocus, initialFocusFallback, containers, features = 15, ...theirProps} = props;
    useServerHandoffComplete() || (features = 0);
    props = useOwnerDocument(container.current);
    useRestoreFocus(features, {ownerDocument:props});
    var previousActiveElement = useInitialFocus(features, {ownerDocument:props, container, initialFocus, initialFocusFallback});
    useFocusLock(features, {ownerDocument:props, container, containers, previousActiveElement});
    let direction = useTabDirection();
    props = useEvent(e => {
      if (isHTMLElement(container.current)) {
        var el = container.current;
        (() => {
          match(direction.current, {[0]:() => {
            focusIn(el, 1, {skipElements:[e.relatedTarget, initialFocusFallback]});
          }, [1]:() => {
            focusIn(el, 8, {skipElements:[e.relatedTarget, initialFocusFallback]});
          }});
        })();
      }
    });
    previousActiveElement = useIsTopLayer(!!(features & 2), "focus-trap#tab-lock");
    let d = useDisposables(), recentlyUsedTabKey = (0,import_react65.useRef)(!1);
    ref = {ref, onKeyDown(e) {
      "Tab" == e.key && (recentlyUsedTabKey.current = !0, d.requestAnimationFrame(() => {
        recentlyUsedTabKey.current = !1;
      }));
    }, onBlur(e) {
      if (features & 4) {
        var allContainers = resolveContainers(containers);
        isHTMLElement(container.current) && allContainers.add(container.current);
        var relatedTarget = e.relatedTarget;
        isHTMLorSVGElement(relatedTarget) && "true" !== relatedTarget.dataset.headlessuiFocusGuard && (contains2(allContainers, relatedTarget) || (recentlyUsedTabKey.current ? focusIn(container.current, match(direction.current, {[0]:() => 4, [1]:() => 2}) | 16, {relativeTo:e.target}) : isHTMLorSVGElement(e.target) && focusElement(e.target)));
      }
    }};
    let render2 = useRender();
    return import_react65.default.createElement(import_react65.default.Fragment, null, previousActiveElement && import_react65.default.createElement(Hidden, {as:"button", type:"button", "data-headlessui-focus-guard":!0, onFocus:props, features:2}), render2({ourProps:ref, theirProps, defaultTag:"div", name:"FocusTrap"}), previousActiveElement && import_react65.default.createElement(Hidden, {as:"button", type:"button", "data-headlessui-focus-guard":!0, onFocus:props, features:2}));
  }), FocusTrap = Object.assign(FocusTrapRoot, {features:FocusTrapFeatures}), import_react66 = __toESM(require("module$node_modules$react$index"), 1), TransitionContext = (0,import_react66.createContext)(null);
  TransitionContext.displayName = "TransitionContext";
  var NestingContext = (0,import_react66.createContext)(null);
  NestingContext.displayName = "NestingContext";
  var DEFAULT_TRANSITION_CHILD_TAG = import_react66.Fragment, TransitionRoot = forwardRefWithAs(function(props, ref) {
    let {show, appear = !1, unmount = !0, ...theirProps} = props, internalTransitionRef = (0,import_react66.useRef)(null);
    var requiresRef = shouldForwardRef(props);
    ref = useSyncRefs(...(requiresRef ? [internalTransitionRef, ref] : null === ref ? [] : [ref]));
    useServerHandoffComplete();
    requiresRef = useOpenClosed();
    void 0 === show && null !== requiresRef && (show = 1 === (requiresRef & 1));
    if (void 0 === show) {
      throw Error("A \x3cTransition /\x3e is used but it is missing a `show\x3d{true | false}` prop.");
    }
    let [state, setState] = (0,import_react66.useState)(show ? "visible" : "hidden"), nestingBag = useNesting(() => {
      show || setState("hidden");
    }), [initial, setInitial] = (0,import_react66.useState)(!0), changes = (0,import_react66.useRef)([show]);
    useIsoMorphicEffect(() => {
      !1 !== initial && changes.current[changes.current.length - 1] !== show && (changes.current.push(show), setInitial(!1));
    }, [changes, show]);
    requiresRef = (0,import_react66.useMemo)(() => ({show, appear, initial}), [show, appear, initial]);
    useIsoMorphicEffect(() => {
      show ? setState("visible") : hasChildren(nestingBag) || null === internalTransitionRef.current || setState("hidden");
    }, [show, nestingBag]);
    let sharedProps = {unmount}, beforeEnter = useEvent(() => {
      var _a3;
      initial && setInitial(!1);
      null == (_a3 = props.beforeEnter) || _a3.call(props);
    }), beforeLeave = useEvent(() => {
      var _a3;
      initial && setInitial(!1);
      null == (_a3 = props.beforeLeave) || _a3.call(props);
    }), render2 = useRender();
    return import_react66.default.createElement(NestingContext.Provider, {value:nestingBag}, import_react66.default.createElement(TransitionContext.Provider, {value:requiresRef}, render2({ourProps:{...sharedProps, as:import_react66.Fragment, children:import_react66.default.createElement(InternalTransitionChild, {ref, ...sharedProps, ...theirProps, beforeEnter, beforeLeave})}, theirProps:{}, defaultTag:import_react66.Fragment, features:1, visible:"visible" === state, name:"Transition"})));
  }), InternalTransitionChild = forwardRefWithAs(function(props, ref) {
    var _a3, _b2;
    let {transition:transition2 = !0, beforeEnter, afterEnter, beforeLeave, afterLeave, enter, enterFrom, enterTo, entered, leave, leaveFrom, leaveTo, ...theirProps} = props, [localContainerElement, setLocalContainerElement] = (0,import_react66.useState)(null), container = (0,import_react66.useRef)(null), requiresRef = shouldForwardRef(props);
    props = useSyncRefs(...(requiresRef ? [container, ref, setLocalContainerElement] : null === ref ? [] : [ref]));
    let strategy = (null != (_a3 = theirProps.unmount) ? _a3 : 1) ? 0 : 1, {show, appear, initial} = useTransitionContext(), [treeState, setState] = (0,import_react66.useState)(show ? "visible" : "hidden");
    ref = useParentNesting();
    let {register, unregister} = ref;
    useIsoMorphicEffect(() => register(container), [register, container]);
    useIsoMorphicEffect(() => {
      if (1 === strategy && container.current) {
        if (show && "visible" !== treeState) {
          setState("visible");
        } else {
          return match(treeState, {hidden:() => unregister(container), visible:() => register(container)});
        }
      }
    }, [treeState, container, register, unregister, show, strategy]);
    let ready = useServerHandoffComplete();
    useIsoMorphicEffect(() => {
      if (requiresRef && ready && "visible" === treeState && null === container.current) {
        throw Error("Did you forget to passthrough the `ref` to the actual DOM node?");
      }
    }, [container, treeState, ready, requiresRef]);
    let skip = initial && !appear;
    _a3 = appear && show && initial;
    let isTransitioning = (0,import_react66.useRef)(!1), nesting = useNesting(() => {
      isTransitioning.current || (setState("hidden"), unregister(container));
    }, ref), start = useEvent(show2 => {
      isTransitioning.current = !0;
      nesting.onStart(container, show2 ? "enter" : "leave", direction2 => {
        "enter" === direction2 ? null == beforeEnter || beforeEnter() : "leave" === direction2 && (null == beforeLeave || beforeLeave());
      });
    }), end = useEvent(show2 => {
      show2 = show2 ? "enter" : "leave";
      isTransitioning.current = !1;
      nesting.onStop(container, show2, direction2 => {
        "enter" === direction2 ? null == afterEnter || afterEnter() : "leave" === direction2 && (null == afterLeave || afterLeave());
      });
      "leave" !== show2 || hasChildren(nesting) || (setState("hidden"), unregister(container));
    });
    (0,import_react66.useEffect)(() => {
      requiresRef && transition2 || (start(show), end(show));
    }, [show, requiresRef, transition2]);
    [, ref] = useTransition(transition2 && requiresRef && ready && !skip ? !0 : !1, localContainerElement, show, {start, end});
    props = compact({ref:props, className:(null == (_b2 = classNames(theirProps.className, _a3 && enter, _a3 && enterFrom, ref.enter && enter, ref.enter && ref.closed && enterFrom, ref.enter && !ref.closed && enterTo, ref.leave && leave, ref.leave && !ref.closed && leaveFrom, ref.leave && ref.closed && leaveTo, !ref.transition && show && entered)) ? void 0 : _b2.trim()) || void 0, ...transitionDataAttributes(ref)});
    _b2 = 0;
    "visible" === treeState && (_b2 |= 1);
    "hidden" === treeState && (_b2 |= 2);
    show && "hidden" === treeState && (_b2 |= 8);
    show || "visible" !== treeState || (_b2 |= 4);
    _a3 = useRender();
    return import_react66.default.createElement(NestingContext.Provider, {value:nesting}, import_react66.default.createElement(OpenClosedProvider, {value:_b2}, _a3({ourProps:props, theirProps, defaultTag:DEFAULT_TRANSITION_CHILD_TAG, features:1, visible:"visible" === treeState, name:"Transition.Child"})));
  }), TransitionChild = forwardRefWithAs(function(props, ref) {
    let hasTransitionContext = null !== (0,import_react66.useContext)(TransitionContext), hasOpenClosedContext = null !== useOpenClosed();
    return import_react66.default.createElement(import_react66.default.Fragment, null, !hasTransitionContext && hasOpenClosedContext ? import_react66.default.createElement(TransitionRoot, {ref, ...props}) : import_react66.default.createElement(InternalTransitionChild, {ref, ...props}));
  }), Transition = Object.assign(TransitionRoot, {Child:TransitionChild, Root:TransitionRoot}), reducers3 = {[0](state, action) {
    return state.titleId === action.id ? state : {...state, titleId:action.id};
  }}, DialogContext = (0,import_react67.createContext)(null);
  DialogContext.displayName = "DialogContext";
  var InternalDialog = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-dialog-${internalId}`, open, onClose, initialFocus, role = "dialog", autoFocus = !0, __demoMode = !1, unmount = !1, ...theirProps} = props;
    props = (0,import_react67.useRef)(!1);
    "dialog" !== role && "alertdialog" !== role && (props.current || (props.current = !0, console.warn(`Invalid role [${role}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), role = "dialog");
    var usesOpenClosedState = useOpenClosed();
    void 0 === open && null !== usesOpenClosedState && (open = 1 === (usesOpenClosedState & 1));
    let internalDialogRef = (0,import_react67.useRef)(null);
    props = useSyncRefs(internalDialogRef, ref);
    internalId = useOwnerDocument(internalDialogRef.current);
    let dialogState = open ? 0 : 1, [state, dispatch] = (0,import_react67.useReducer)(stateReducer, {titleId:null, descriptionId:null, panelRef:(0,import_react67.createRef)()}), close = useEvent(() => onClose(!1)), setTitleId = useEvent(id2 => dispatch({type:0, id:id2})), enabled = useServerHandoffComplete() ? 0 === dialogState : !1, [portals, PortalWrapper] = useNestedPortals(), mainTreeNode = useMainTreeNode();
    ({resolveContainers:ref} = useRootContainers({mainTreeNode, portals, defaultContainers:[{get current() {
      var _a3;
      return null != (_a3 = state.panelRef.current) ? _a3 : internalDialogRef.current;
    }}]}));
    usesOpenClosedState = null !== usesOpenClosedState ? 4 === (usesOpenClosedState & 4) : !1;
    useInertOthers(__demoMode ? !1 : usesOpenClosedState ? !1 : enabled, {allowed:useEvent(() => {
      var _a3, _b2;
      return [null != (_b2 = null == (_a3 = internalDialogRef.current) ? void 0 : _a3.closest("[data-headlessui-portal]")) ? _b2 : null];
    }), disallowed:useEvent(() => {
      var _a3;
      return [null != (_a3 = null == mainTreeNode ? void 0 : mainTreeNode.closest("body \x3e *:not(#headlessui-portal-root)")) ? _a3 : null];
    })});
    let stackMachine = stackMachines.get(null);
    useIsoMorphicEffect(() => {
      if (enabled) {
        return stackMachine.actions.push(id), () => stackMachine.actions.pop(id);
      }
    }, [stackMachine, id, enabled]);
    var isTopLayer = useSlice(stackMachine, (0,import_react67.useCallback)(state2 => stackMachine.selectors.isTop(state2, id), [stackMachine, id]));
    useOutsideClick(isTopLayer, ref, event => {
      event.preventDefault();
      close();
    });
    useEscape(isTopLayer, null == internalId ? void 0 : internalId.defaultView, event => {
      event.preventDefault();
      event.stopPropagation();
      document.activeElement && "blur" in document.activeElement && "function" === typeof document.activeElement.blur && document.activeElement.blur();
      close();
    });
    useScrollLock(__demoMode ? !1 : usesOpenClosedState ? !1 : enabled, internalId, ref);
    useOnDisappear(enabled, internalDialogRef, close);
    let [describedby, DescriptionProvider] = useDescriptions();
    internalId = (0,import_react67.useMemo)(() => [{dialogState, close, setTitleId, unmount}, state], [dialogState, close, setTitleId, unmount, state]);
    usesOpenClosedState = useSlot({open:0 === dialogState});
    props = {ref:props, id, role, tabIndex:-1, "aria-modal":__demoMode ? void 0 : 0 === dialogState ? !0 : void 0, "aria-labelledby":state.titleId, "aria-describedby":describedby, unmount};
    var shouldMoveFocusInside = !useIsTouchDevice();
    isTopLayer = 0;
    enabled && !__demoMode && (isTopLayer |= 10, autoFocus && (isTopLayer |= 16), shouldMoveFocusInside && (isTopLayer |= 1));
    shouldMoveFocusInside = useRender();
    return import_react67.default.createElement(ResetOpenClosedProvider, null, import_react67.default.createElement(ForcePortalRoot, {force:!0}, import_react67.default.createElement(Portal, null, import_react67.default.createElement(DialogContext.Provider, {value:internalId}, import_react67.default.createElement(PortalGroup, {target:internalDialogRef}, import_react67.default.createElement(ForcePortalRoot, {force:!1}, import_react67.default.createElement(DescriptionProvider, {slot:usesOpenClosedState}, 
    import_react67.default.createElement(PortalWrapper, null, import_react67.default.createElement(FocusTrap, {initialFocus, initialFocusFallback:internalDialogRef, containers:ref, features:isTopLayer}, import_react67.default.createElement(CloseProvider, {value:close}, shouldMoveFocusInside({ourProps:props, theirProps, slot:usesOpenClosedState, defaultTag:DEFAULT_DIALOG_TAG, features:DialogRenderFeatures, visible:0 === dialogState, name:"Dialog"})))))))))));
  }), DEFAULT_DIALOG_TAG = "div", DialogRenderFeatures = 3, DialogRoot = forwardRefWithAs(function(props, ref) {
    let {transition:transition2 = !1, open, ...rest} = props, usesOpenClosedState = useOpenClosed(), hasOpen = props.hasOwnProperty("open") || null !== usesOpenClosedState, hasOnClose = props.hasOwnProperty("onClose");
    if (!hasOpen && !hasOnClose) {
      throw Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
    }
    if (!hasOpen) {
      throw Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
    }
    if (!hasOnClose) {
      throw Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
    }
    if (!usesOpenClosedState && "boolean" !== typeof props.open) {
      throw Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${props.open}`);
    }
    if ("function" !== typeof props.onClose) {
      throw Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${props.onClose}`);
    }
    return void 0 === open && !transition2 || rest.static ? import_react67.default.createElement(MainTreeProvider, null, import_react67.default.createElement(InternalDialog, {ref, open, ...rest})) : import_react67.default.createElement(MainTreeProvider, null, import_react67.default.createElement(Transition, {show:open, transition:transition2, unmount:rest.unmount}, import_react67.default.createElement(InternalDialog, {ref, ...rest})));
  }), DialogPanel = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-dialog-panel-${internalId}`, transition:transition2 = !1, ...theirProps} = props, [{dialogState, unmount}, state] = useDialogContext("Dialog.Panel");
    ref = useSyncRefs(ref, state.panelRef);
    props = useSlot({open:0 === dialogState});
    internalId = useEvent(event => {
      event.stopPropagation();
    });
    ref = {ref, id, onClick:internalId};
    internalId = transition2 ? TransitionChild : import_react67.Fragment;
    let wrapperProps = transition2 ? {unmount} : {}, render2 = useRender();
    return import_react67.default.createElement(internalId, {...wrapperProps}, render2({ourProps:ref, theirProps, slot:props, defaultTag:"div", name:"Dialog.Panel"}));
  }), DialogBackdrop = forwardRefWithAs(function(props, ref) {
    let {transition:transition2 = !1, ...theirProps} = props, [{dialogState, unmount}] = useDialogContext("Dialog.Backdrop");
    props = useSlot({open:0 === dialogState});
    ref = {ref, "aria-hidden":!0};
    let Wrapper = transition2 ? TransitionChild : import_react67.Fragment, wrapperProps = transition2 ? {unmount} : {}, render2 = useRender();
    return import_react67.default.createElement(Wrapper, {...wrapperProps}, render2({ourProps:ref, theirProps, slot:props, defaultTag:"div", name:"Dialog.Backdrop"}));
  }), DialogTitle = forwardRefWithAs(function(props, ref) {
    let internalId = (0,import_react20.useId)(), {id = `headlessui-dialog-title-${internalId}`, ...theirProps} = props, [{dialogState, setTitleId}] = useDialogContext("Dialog.Title");
    ref = useSyncRefs(ref);
    (0,import_react67.useEffect)(() => {
      setTitleId(id);
      return () => setTitleId(null);
    }, [id, setTitleId]);
    props = useSlot({open:0 === dialogState});
    ref = {ref, id};
    return useRender()({ourProps:ref, theirProps, slot:props, defaultTag:"h2", name:"Dialog.Title"});
  }), DialogDescription = Description, Dialog = Object.assign(DialogRoot, {Panel:DialogPanel, Title:DialogTitle, Description}), import_react69 = __toESM(require("module$node_modules$react$index"), 1), _a2, startTransition = null != (_a2 = __toESM(require("module$node_modules$react$index"), 1).default.startTransition) ? _a2 : function(cb) {
    cb();
  }, reducers4 = {[0]:state => ({...state, disclosureState:match(state.disclosureState, {[0]:1, [1]:0})}), [1]:state => 1 === state.disclosureState ? state : {...state, disclosureState:1}, [2](state, action) {
    return state.buttonId === action.buttonId ? state : {...state, buttonId:action.buttonId};
  }, [3](state, action) {
    return state.panelId === action.panelId ? state : {...state, panelId:action.panelId};
  }, [4](state, action) {
    return state.buttonElement === action.element ? state : {...state, buttonElement:action.element};
  }, [5](state, action) {
    return state.panelElement === action.element ? state : {...state, panelElement:action.element};
  }}, DisclosureContext = (0,import_react69.createContext)(null);
  DisclosureContext.displayName = "DisclosureContext";
  var DisclosureAPIContext = (0,import_react69.createContext)(null);
  DisclosureAPIContext.displayName = "DisclosureAPIContext";
  var DisclosurePanelContext = (0,import_react69.createContext)(null);
  DisclosurePanelContext.displayName = "DisclosurePanelContext";
  var DEFAULT_DISCLOSURE_TAG = import_react69.Fragment, DisclosureRoot = forwardRefWithAs(function(props, ref) {
    let {defaultOpen = !1, ...theirProps} = props, internalDisclosureRef = (0,import_react69.useRef)(null);
    var disclosureRef = useSyncRefs(ref, optionalRef(ref2 => {
      internalDisclosureRef.current = ref2;
    }, void 0 === props.as || isFragment(props.as)));
    props = (0,import_react69.useReducer)(stateReducer2, {disclosureState:defaultOpen ? 0 : 1, buttonElement:null, panelElement:null, buttonId:null, panelId:null});
    let [{disclosureState, buttonId}, dispatch] = props, close = useEvent(focusableElement => {
      dispatch({type:1});
      let ownerDocument = getOwnerDocument(internalDisclosureRef.current);
      ownerDocument && buttonId && (focusableElement = focusableElement ? isHTMLorSVGElement(focusableElement) ? focusableElement : "current" in focusableElement && isHTMLorSVGElement(focusableElement.current) ? focusableElement.current : ownerDocument.getElementById(buttonId) : ownerDocument.getElementById(buttonId), null == focusableElement || focusableElement.focus());
    });
    ref = (0,import_react69.useMemo)(() => ({close}), [close]);
    let slot = useSlot({open:0 === disclosureState, close});
    disclosureRef = {ref:disclosureRef};
    let render2 = useRender();
    return import_react69.default.createElement(DisclosureContext.Provider, {value:props}, import_react69.default.createElement(DisclosureAPIContext.Provider, {value:ref}, import_react69.default.createElement(CloseProvider, {value:close}, import_react69.default.createElement(OpenClosedProvider, {value:match(disclosureState, {[0]:1, [1]:2})}, render2({ourProps:disclosureRef, theirProps, slot, defaultTag:DEFAULT_DISCLOSURE_TAG, name:"Disclosure"})))));
  }), DisclosureButton = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-disclosure-button-${internalId}`, disabled = !1, autoFocus = !1, ...theirProps} = props, [state, dispatch] = useDisclosureContext("Disclosure.Button");
    internalId = (0,import_react69.useContext)(DisclosurePanelContext);
    let isWithinPanel = null === internalId ? !1 : internalId === state.panelId;
    internalId = (0,import_react69.useRef)(null);
    internalId = useSyncRefs(internalId, ref, useEvent(element => {
      if (!isWithinPanel) {
        return dispatch({type:4, element});
      }
    }));
    (0,import_react69.useEffect)(() => {
      if (!isWithinPanel) {
        return dispatch({type:2, buttonId:id}), () => {
          dispatch({type:2, buttonId:null});
        };
      }
    }, [id, dispatch, isWithinPanel]);
    let handleKeyDown = useEvent(event => {
      var _a3;
      if (isWithinPanel) {
        if (1 !== state.disclosureState) {
          switch(event.key) {
            case " ":
            case "Enter":
              event.preventDefault(), event.stopPropagation(), dispatch({type:0}), null == (_a3 = state.buttonElement) || _a3.focus();
          }
        }
      } else {
        switch(event.key) {
          case " ":
          case "Enter":
            event.preventDefault(), event.stopPropagation(), dispatch({type:0});
        }
      }
    }), handleKeyUp = useEvent(event => {
      switch(event.key) {
        case " ":
          event.preventDefault();
      }
    }), handleClick = useEvent(event => {
      var _a3;
      isDisabledReactIssue7711(event.currentTarget) || disabled || (isWithinPanel ? (dispatch({type:0}), null == (_a3 = state.buttonElement) || _a3.focus()) : dispatch({type:0}));
    }), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    ref = useSlot({open:0 === state.disclosureState, hover, active, disabled, focus, autofocus:autoFocus});
    props = useResolveButtonType(props, state.buttonElement);
    props = isWithinPanel ? mergeProps({ref:internalId, type:props, disabled:disabled || void 0, autoFocus, onKeyDown:handleKeyDown, onClick:handleClick}, focusProps, hoverProps, pressProps) : mergeProps({ref:internalId, id, type:props, "aria-expanded":0 === state.disclosureState, "aria-controls":state.panelElement ? state.panelId : void 0, disabled:disabled || void 0, autoFocus, onKeyDown:handleKeyDown, onKeyUp:handleKeyUp, onClick:handleClick}, focusProps, hoverProps, pressProps);
    return useRender()({ourProps:props, theirProps, slot:ref, defaultTag:"button", name:"Disclosure.Button"});
  }), DisclosurePanel = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-disclosure-panel-${internalId}`, transition:transition2 = !1, ...theirProps} = props, [state, dispatch] = useDisclosureContext("Disclosure.Panel");
    ({close:props} = useDisclosureAPIContext("Disclosure.Panel"));
    let [localPanelElement, setLocalPanelElement] = (0,import_react69.useState)(null);
    ref = useSyncRefs(ref, useEvent(element => {
      startTransition(() => dispatch({type:5, element}));
    }), setLocalPanelElement);
    (0,import_react69.useEffect)(() => {
      dispatch({type:3, panelId:id});
      return () => {
        dispatch({type:3, panelId:null});
      };
    }, [id, dispatch]);
    internalId = useOpenClosed();
    let [visible, transitionData] = useTransition(transition2, localPanelElement, null !== internalId ? 1 === (internalId & 1) : 0 === state.disclosureState);
    props = useSlot({open:0 === state.disclosureState, close:props});
    ref = {ref, id, ...transitionDataAttributes(transitionData)};
    internalId = useRender();
    return import_react69.default.createElement(ResetOpenClosedProvider, null, import_react69.default.createElement(DisclosurePanelContext.Provider, {value:state.panelId}, internalId({ourProps:ref, theirProps, slot:props, defaultTag:"div", features:3, visible, name:"Disclosure.Panel"})));
  }), Disclosure = Object.assign(DisclosureRoot, {Button:DisclosureButton, Panel:DisclosurePanel}), import_react70 = __toESM(require("module$node_modules$react$index"), 1), Field = forwardRefWithAs(function(props, ref) {
    let inputId = `headlessui-control-${(0,import_react20.useId)()}`, [labelledby, LabelProvider] = useLabels(), [describedBy, DescriptionProvider] = useDescriptions();
    var providedDisabled = useDisabled();
    let {disabled = providedDisabled || !1, ...theirProps} = props;
    props = useSlot({disabled});
    ref = {ref, disabled:disabled || void 0, "aria-disabled":disabled || void 0};
    providedDisabled = useRender();
    return import_react70.default.createElement(DisabledProvider, {value:disabled}, import_react70.default.createElement(LabelProvider, {value:labelledby}, import_react70.default.createElement(DescriptionProvider, {value:describedBy}, import_react70.default.createElement(IdProvider, {id:inputId}, providedDisabled({ourProps:ref, theirProps:{...theirProps, children:import_react70.default.createElement(FormFieldsProvider, null, "function" === typeof theirProps.children ? theirProps.children(props) : 
    theirProps.children)}, slot:props, defaultTag:"div", name:"Field"})))));
  }), import_react72 = __toESM(require("module$node_modules$react$index"), 1), import_react71 = require("module$node_modules$react$index"), Fieldset = forwardRefWithAs(function(props, ref) {
    var _a3;
    let providedDisabled = useDisabled(), {disabled = providedDisabled || !1, ...theirProps} = props, [tag, resolveTag] = useResolvedTag(null != (_a3 = props.as) ? _a3 : "fieldset");
    ref = useSyncRefs(ref, resolveTag);
    let [labelledBy, LabelProvider] = useLabels();
    props = useSlot({disabled});
    ref = "fieldset" === tag ? {ref, "aria-labelledby":labelledBy, disabled:disabled || void 0} : {ref, role:"group", "aria-labelledby":labelledBy, "aria-disabled":disabled || void 0};
    _a3 = useRender();
    return import_react72.default.createElement(DisabledProvider, {value:disabled}, import_react72.default.createElement(LabelProvider, null, _a3({ourProps:ref, theirProps, slot:props, defaultTag:"fieldset", name:"Fieldset"})));
  }), Input = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let providedId = useProvidedId(), providedDisabled = useDisabled(), {id = providedId || `headlessui-input-${internalId}`, disabled = providedDisabled || !1, autoFocus = !1, invalid = !1, ...theirProps} = props;
    props = useLabelledBy();
    internalId = useDescribedBy();
    let {isFocused:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled});
    ref = mergeProps({ref, id, "aria-labelledby":props, "aria-describedby":internalId, "aria-invalid":invalid ? "true" : void 0, disabled:disabled || void 0, autoFocus}, focusProps, hoverProps);
    props = useSlot({disabled, invalid, hover, focus, autofocus:autoFocus});
    return useRender()({ourProps:ref, theirProps, slot:props, defaultTag:"input", name:"Input"});
  }), import_react73 = __toESM(require("module$node_modules$react$index"), 1), Legend = forwardRefWithAs(function(props, ref) {
    return import_react73.default.createElement(Label, {as:"div", ref, ...props});
  }), import_react76 = __toESM(require("module$node_modules$react$index"), 1), import_react_dom9 = require("module$node_modules$react_dom$index"), import_react74 = require("module$node_modules$react$index"), emojiRegex = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g, reducers5 = {[1](state) {
    if (state.dataRef.current.disabled || 1 === state.listboxState) {
      return state;
    }
    let buttonPositionState = state.buttonElement ? ElementPositionState.Tracked(computeVisualPosition(state.buttonElement)) : state.buttonPositionState;
    return {...state, activeOptionIndex:null, pendingFocus:{focus:5}, listboxState:1, __demoMode:!1, buttonPositionState};
  }, [0](state, action) {
    if (state.dataRef.current.disabled || 0 === state.listboxState) {
      return state;
    }
    let activeOptionIndex = state.activeOptionIndex, {isSelected} = state.dataRef.current, optionIdx = state.options.findIndex(option => isSelected(option.dataRef.current.value));
    -1 !== optionIdx && (activeOptionIndex = optionIdx);
    return {...state, frozenValue:!1, pendingFocus:action.focus, listboxState:0, activeOptionIndex, __demoMode:!1, buttonPositionState:ElementPositionState.Idle};
  }, [2](state, action) {
    var _a3, _b2, _c;
    if (state.dataRef.current.disabled || 1 === state.listboxState) {
      return state;
    }
    let base = {...state, searchQuery:"", activationTrigger:null != (_a3 = action.trigger) ? _a3 : 1, __demoMode:!1};
    if (5 === action.focus) {
      return {...base, activeOptionIndex:null};
    }
    if (4 === action.focus) {
      return {...base, activeOptionIndex:state.options.findIndex(o => o.id === action.id)};
    }
    if (1 === action.focus) {
      var _d = state.activeOptionIndex;
      if (null !== _d) {
        _d = state.options[_d].dataRef.current.domRef;
        var _e = calculateActiveIndex(action, {resolveItems:() => state.options, resolveActiveIndex:() => state.activeOptionIndex, resolveId:option => option.id, resolveDisabled:option => option.dataRef.current.disabled});
        if (null !== _e && (_a3 = state.options[_e].dataRef.current.domRef, (null == (_b2 = _d.current) ? void 0 : _b2.previousElementSibling) === _a3.current || null === (null == (_c = _a3.current) ? void 0 : _c.previousElementSibling))) {
          return {...base, activeOptionIndex:_e};
        }
      }
    } else if (2 === action.focus && (_b2 = state.activeOptionIndex, null !== _b2 && (_b2 = state.options[_b2].dataRef.current.domRef, _c = calculateActiveIndex(action, {resolveItems:() => state.options, resolveActiveIndex:() => state.activeOptionIndex, resolveId:option => option.id, resolveDisabled:option => option.dataRef.current.disabled}), null !== _c && (_a3 = state.options[_c].dataRef.current.domRef, (null == (_d = _b2.current) ? void 0 : _d.nextElementSibling) === _a3.current || null === (null == 
    (_e = _a3.current) ? void 0 : _e.nextElementSibling))))) {
      return {...base, activeOptionIndex:_c};
    }
    let adjustedState = adjustOrderedState2(state);
    _b2 = calculateActiveIndex(action, {resolveItems:() => adjustedState.options, resolveActiveIndex:() => adjustedState.activeOptionIndex, resolveId:option => option.id, resolveDisabled:option => option.dataRef.current.disabled});
    return {...base, ...adjustedState, activeOptionIndex:_b2};
  }, [3]:(state, action) => {
    if (state.dataRef.current.disabled || 1 === state.listboxState) {
      return state;
    }
    let offset3 = "" !== state.searchQuery ? 0 : 1, searchQuery = state.searchQuery + action.value.toLowerCase();
    action = (action = (null !== state.activeOptionIndex ? state.options.slice(state.activeOptionIndex + offset3).concat(state.options.slice(0, state.activeOptionIndex + offset3)) : state.options).find(option => {
      var _a3;
      return !option.dataRef.current.disabled && (null == (_a3 = option.dataRef.current.textValue) ? void 0 : _a3.startsWith(searchQuery));
    })) ? state.options.indexOf(action) : -1;
    return -1 === action || action === state.activeOptionIndex ? {...state, searchQuery} : {...state, searchQuery, activeOptionIndex:action, activationTrigger:1};
  }, [4](state) {
    return state.dataRef.current.disabled || 1 === state.listboxState || "" === state.searchQuery ? state : {...state, searchQuery:""};
  }, [5](state) {
    return 0 === state.dataRef.current.mode ? {...state, frozenValue:!0} : {...state};
  }, [6]:(state, action) => {
    let options = state.options.concat(action.options);
    action = state.activeOptionIndex;
    5 !== state.pendingFocus.focus && (action = calculateActiveIndex(state.pendingFocus, {resolveItems:() => options, resolveActiveIndex:() => state.activeOptionIndex, resolveId:item => item.id, resolveDisabled:item => item.dataRef.current.disabled}));
    if (null === state.activeOptionIndex) {
      let {isSelected} = state.dataRef.current;
      if (isSelected) {
        let idx = options.findIndex(option => null == isSelected ? void 0 : isSelected(option.dataRef.current.value));
        -1 !== idx && (action = idx);
      }
    }
    return {...state, options, activeOptionIndex:action, pendingFocus:{focus:5}, pendingShouldSort:!0};
  }, [7]:(state, action) => {
    let options = state.options, idxs = [];
    action = new Set(action.options);
    for (let [idx, option] of options.entries()) {
      if (action.has(option.id) && (idxs.push(idx), action.delete(option.id), 0 === action.size)) {
        break;
      }
    }
    if (0 < idxs.length) {
      options = options.slice();
      for (let idx of idxs.reverse()) {
        options.splice(idx, 1);
      }
    }
    return {...state, options, activationTrigger:1};
  }, [8]:(state, action) => state.buttonElement === action.element ? state : {...state, buttonElement:action.element}, [9]:(state, action) => state.optionsElement === action.element ? state : {...state, optionsElement:action.element}, [10]:state => state.pendingShouldSort ? {...state, ...adjustOrderedState2(state), pendingShouldSort:!1} : state, [11](state) {
    return "Tracked" !== state.buttonPositionState.kind ? state : {...state, buttonPositionState:ElementPositionState.Moved};
  }}, ListboxMachine = class extends Machine {
    constructor(initialState) {
      super(initialState);
      __publicField(this, "actions", {onChange:newValue => {
        let {onChange, compare, mode, value} = this.state.dataRef.current;
        return match(mode, {[0]:() => null == onChange ? void 0 : onChange(newValue), [1]:() => {
          let copy = value.slice(), idx = copy.findIndex(item => compare(item, newValue));
          -1 === idx ? copy.push(newValue) : copy.splice(idx, 1);
          return null == onChange ? void 0 : onChange(copy);
        }});
      }, registerOption:batch(() => {
        let options = [], seen = new Set();
        return [(id, dataRef) => {
          seen.has(dataRef) || (seen.add(dataRef), options.push({id, dataRef}));
        }, () => {
          seen.clear();
          return this.send({type:6, options:options.splice(0)});
        }];
      }), unregisterOption:batch(() => {
        let options = [];
        return [id => options.push(id), () => {
          this.send({type:7, options:options.splice(0)});
        }];
      }), goToOption:batch(() => {
        let last = null;
        return [(focus, trigger) => {
          last = {type:2, ...focus, trigger};
        }, () => last && this.send(last)];
      }), closeListbox:() => {
        this.send({type:1});
      }, openListbox:focus => {
        this.send({type:0, focus});
      }, selectActiveOption:() => {
        var _a3;
        null !== this.state.activeOptionIndex ? ({dataRef:_a3} = this.state.options[this.state.activeOptionIndex], this.actions.selectOption(_a3.current.value)) : 0 === this.state.dataRef.current.mode && (this.actions.closeListbox(), null == (_a3 = this.state.buttonElement) || _a3.focus({preventScroll:!0}));
      }, selectOption:value => {
        this.send({type:5, value});
      }, search:value => {
        this.send({type:3, value});
      }, clearSearch:() => {
        this.send({type:4});
      }, setButtonElement:element => {
        this.send({type:8, element});
      }, setOptionsElement:element => {
        this.send({type:9, element});
      }});
      __publicField(this, "selectors", {activeDescendantId(state) {
        var _a3;
        let activeOptionIndex = state.activeOptionIndex;
        state = state.options;
        return null === activeOptionIndex ? void 0 : null == (_a3 = state[activeOptionIndex]) ? void 0 : _a3.id;
      }, isActive(state, id) {
        var _a3;
        let activeOptionIndex = state.activeOptionIndex;
        state = state.options;
        return null !== activeOptionIndex ? (null == (_a3 = state[activeOptionIndex]) ? void 0 : _a3.id) === id : !1;
      }, hasFrozenValue(state) {
        return state.frozenValue;
      }, shouldScrollIntoView(state, id) {
        return state.__demoMode || 0 !== state.listboxState || 0 === state.activationTrigger ? !1 : this.isActive(state, id);
      }, didButtonMove(state) {
        return "Moved" === state.buttonPositionState.kind;
      }});
      this.on(6, () => {
        requestAnimationFrame(() => {
          this.send({type:10});
        });
      });
      let id = this.state.id, stackMachine = stackMachines.get(null);
      this.disposables.add(stackMachine.on(0, state => {
        stackMachine.selectors.isTop(state, id) || 0 !== this.state.listboxState || this.actions.closeListbox();
      }));
      this.on(0, () => stackMachine.actions.push(id));
      this.on(1, () => stackMachine.actions.pop(id));
      this.disposables.group(d => {
        this.on(1, state => {
          state.buttonElement && (d.dispose(), d.add(detectMovement(state.buttonElement, state.buttonPositionState, () => {
            this.send({type:11});
          })));
        });
      });
      this.on(5, (_, action) => {
        var _a3;
        this.actions.onChange(action.value);
        0 === this.state.dataRef.current.mode && (this.actions.closeListbox(), null == (_a3 = this.state.buttonElement) || _a3.focus({preventScroll:!0}));
      });
    }
    static new({id, __demoMode = !1}) {
      return new ListboxMachine({id, dataRef:{current:{}}, listboxState:__demoMode ? 0 : 1, options:[], searchQuery:"", activeOptionIndex:null, activationTrigger:1, buttonElement:null, optionsElement:null, pendingShouldSort:!1, pendingFocus:{focus:5}, frozenValue:!1, __demoMode, buttonPositionState:ElementPositionState.Idle});
    }
    reduce(state, action) {
      return match(action.type, reducers5, state, action);
    }
  }, import_react75 = require("module$node_modules$react$index"), ListboxContext = (0,import_react75.createContext)(null), ListboxDataContext = (0,import_react76.createContext)(null);
  ListboxDataContext.displayName = "ListboxDataContext";
  var DEFAULT_LISTBOX_TAG = import_react76.Fragment, SelectedOptionContext = (0,import_react76.createContext)(!1), DEFAULT_SELECTED_OPTION_TAG = import_react76.Fragment, ListboxRoot = forwardRefWithAs(function(props, ref) {
    let id = (0,import_react20.useId)();
    var providedDisabled = useDisabled();
    let {value:controlledValue, defaultValue:_defaultValue, form, name, onChange:controlledOnChange, by, invalid = !1, disabled = providedDisabled || !1, horizontal = !1, multiple = !1, __demoMode = !1, ...theirProps} = props;
    props = horizontal ? "horizontal" : "vertical";
    ref = useSyncRefs(ref);
    let defaultValue = useDefaultValue(_defaultValue), [value = multiple ? [] : void 0, theirOnChange] = useControllable(controlledValue, controlledOnChange, defaultValue), machine = useListboxMachine({id, __demoMode});
    providedDisabled = (0,import_react76.useRef)({static:!1, hold:!1});
    var listRef = (0,import_react76.useRef)(new Map());
    let compare = useByComparator(by);
    var isSelected = (0,import_react76.useCallback)(compareValue => match(data.mode, {[1]:() => value.some(option => compare(option, compareValue)), [0]:() => compare(value, compareValue)}), [value]);
    let data = useSlot({value, disabled, invalid, mode:multiple ? 1 : 0, orientation:props, onChange:theirOnChange, compare, isSelected, optionsPropsRef:providedDisabled, listRef});
    useIsoMorphicEffect(() => {
      machine.state.dataRef.current = data;
    }, [data]);
    props = useSlice(machine, state => state.listboxState);
    let stackMachine = stackMachines.get(null);
    providedDisabled = useSlice(stackMachine, (0,import_react76.useCallback)(state => stackMachine.selectors.isTop(state, id), [stackMachine, id]));
    let [buttonElement, optionsElement] = useSlice(machine, state => [state.buttonElement, state.optionsElement]);
    useOutsideClick(providedDisabled, [buttonElement, optionsElement], (event, target) => {
      machine.send({type:1});
      isFocusableElement(target, 1) || (event.preventDefault(), null == buttonElement || buttonElement.focus());
    });
    providedDisabled = useSlot({open:0 === props, disabled, invalid, value});
    let [labelledby, LabelProvider] = useLabels({inherit:!0});
    ref = {ref};
    listRef = (0,import_react76.useCallback)(() => {
      if (void 0 !== defaultValue) {
        return null == theirOnChange ? void 0 : theirOnChange(defaultValue);
      }
    }, [theirOnChange, defaultValue]);
    isSelected = useRender();
    return import_react76.default.createElement(LabelProvider, {value:labelledby, props:{htmlFor:null == buttonElement ? void 0 : buttonElement.id}, slot:{open:0 === props, disabled}}, import_react76.default.createElement(FloatingProvider, null, import_react76.default.createElement(ListboxContext.Provider, {value:machine}, import_react76.default.createElement(ListboxDataContext.Provider, {value:data}, import_react76.default.createElement(OpenClosedProvider, {value:match(props, {[0]:1, [1]:2})}, null != 
    name && null != value && import_react76.default.createElement(FormFields, {disabled, data:{[name]:value}, form, onReset:listRef}), isSelected({ourProps:ref, theirProps, slot:providedDisabled, defaultTag:DEFAULT_LISTBOX_TAG, name:"Listbox"}))))));
  }), ListboxButton = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)(), providedId = useProvidedId();
    let data = useData2("Listbox.Button"), machine = useListboxMachineContext("Listbox.Button"), {id = providedId || `headlessui-listbox-button-${internalId}`, disabled = data.disabled || !1, autoFocus = !1, ...theirProps} = props;
    internalId = useSyncRefs(ref, useFloatingReference(), machine.actions.setButtonElement);
    providedId = (0,import_react52.useContext)(FloatingContext).getReferenceProps;
    let [listboxState, buttonElement, optionsElement] = useSlice(machine, state => [state.listboxState, state.buttonElement, state.optionsElement]);
    useQuickRelease(0 === listboxState, {trigger:buttonElement, action:(0,import_react76.useCallback)(e => {
      if (null == buttonElement ? 0 : buttonElement.contains(e.target)) {
        return Action.Ignore;
      }
      let option = e.target.closest('[role\x3d"option"]:not([data-disabled])');
      return isHTMLElement(option) ? Action.Select(option) : (null == optionsElement ? 0 : optionsElement.contains(e.target)) ? Action.Ignore : Action.Close;
    }, [buttonElement, optionsElement]), close:machine.actions.closeListbox, select:machine.actions.selectActiveOption});
    let handleKeyDown = useEvent(event => {
      switch(event.key) {
        case "Enter":
          attemptSubmit(event.currentTarget);
          break;
        case " ":
        case "ArrowDown":
          event.preventDefault();
          machine.actions.openListbox({focus:data.value ? 5 : 0});
          break;
        case "ArrowUp":
          event.preventDefault(), machine.actions.openListbox({focus:data.value ? 5 : 3});
      }
    }), handleKeyUp = useEvent(event => {
      switch(event.key) {
        case " ":
          event.preventDefault();
      }
    }), toggleProps = useHandleToggle(event => {
      var _a3;
      0 === machine.state.listboxState ? ((0,import_react_dom9.flushSync)(() => machine.actions.closeListbox()), null == (_a3 = machine.state.buttonElement) || _a3.focus({preventScroll:!0})) : (event.preventDefault(), machine.actions.openListbox({focus:5}));
    }), handleKeyPress = useEvent(event => event.preventDefault()), labelledBy = useLabelledBy([id]), describedBy = useDescribedBy(), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    ref = useSlot({open:0 === listboxState, active:active || 0 === listboxState, disabled, invalid:data.invalid, value:data.value, hover, focus, autofocus:autoFocus});
    let open = useSlice(machine, state => 0 === state.listboxState);
    props = mergeProps(providedId(), {ref:internalId, id, type:useResolveButtonType(props, buttonElement), "aria-haspopup":"listbox", "aria-controls":null == optionsElement ? void 0 : optionsElement.id, "aria-expanded":open, "aria-labelledby":labelledBy, "aria-describedby":describedBy, disabled:disabled || void 0, autoFocus, onKeyDown:handleKeyDown, onKeyUp:handleKeyUp, onKeyPress:handleKeyPress}, toggleProps, focusProps, hoverProps, pressProps);
    return useRender()({ourProps:props, theirProps, slot:ref, defaultTag:"button", name:"Listbox.Button"});
  }), ListboxLabel = Label, ListboxOptions = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-listbox-options-${internalId}`, anchor:rawAnchor, portal = !1, modal = !0, transition:transition2 = !1, ...theirProps} = props, anchor = useResolvedAnchor(rawAnchor), [localOptionsElement, setLocalOptionsElement] = (0,import_react76.useState)(null);
    anchor && (portal = !0);
    let data = useData2("Listbox.Options"), machine = useListboxMachineContext("Listbox.Options"), [listboxState, buttonElement, optionsElement, __demoMode] = useSlice(machine, state => [state.listboxState, state.buttonElement, state.optionsElement, state.__demoMode]);
    internalId = useOwnerDocument(buttonElement);
    var ownerDocument = useOwnerDocument(optionsElement), usesOpenClosedState = useOpenClosed();
    let [visible, transitionData] = useTransition(transition2, localOptionsElement, null !== usesOpenClosedState ? 1 === (usesOpenClosedState & 1) : 0 === listboxState);
    useOnDisappear(visible, buttonElement, machine.actions.closeListbox);
    useScrollLock(__demoMode ? !1 : modal && 0 === listboxState, ownerDocument);
    useInertOthers(__demoMode ? !1 : modal && 0 === listboxState, {allowed:(0,import_react76.useCallback)(() => [buttonElement, optionsElement], [buttonElement, optionsElement])});
    ownerDocument = useSlice(machine, machine.selectors.didButtonMove) ? !1 : visible;
    usesOpenClosedState = useSlice(machine, machine.selectors.hasFrozenValue) && !props.static;
    let frozenValue = useFrozenData(usesOpenClosedState, data.value), isSelected = (0,import_react76.useCallback)(compareValue => data.compare(frozenValue, compareValue), [data.compare, frozenValue]), selectedOptionIndex = useSlice(machine, state => {
      var _a3;
      if (null == anchor || null == (_a3 = null == anchor ? void 0 : anchor.to) || !_a3.includes("selection")) {
        return null;
      }
      state = state.options.findIndex(option => isSelected(option.dataRef.current.value));
      -1 === state && (state = 0);
      return state;
    });
    usesOpenClosedState = (() => {
      if (null != anchor) {
        if (null === selectedOptionIndex) {
          return {...anchor, inner:void 0};
        }
        var elements = Array.from(data.listRef.current.values());
        return {...anchor, inner:{listRef:{current:elements}, index:selectedOptionIndex}};
      }
    })();
    let [floatingRef, style] = useFloatingPanel(usesOpenClosedState);
    usesOpenClosedState = useFloatingPanelProps();
    var optionsRef = useSyncRefs(ref, anchor ? floatingRef : null, machine.actions.setOptionsElement, setLocalOptionsElement);
    let searchDisposables = useDisposables();
    (0,import_react76.useEffect)(() => {
      optionsElement && 0 === listboxState && (isActiveElement(optionsElement) || null == optionsElement || optionsElement.focus({preventScroll:!0}));
    }, [listboxState, optionsElement]);
    var handleKeyDown = useEvent(event => {
      var _a3;
      searchDisposables.dispose();
      switch(event.key) {
        case " ":
          if ("" !== machine.state.searchQuery) {
            return event.preventDefault(), event.stopPropagation(), machine.actions.search(event.key);
          }
        case "Enter":
          event.preventDefault();
          event.stopPropagation();
          machine.actions.selectActiveOption();
          break;
        case match(data.orientation, {vertical:"ArrowDown", horizontal:"ArrowRight"}):
          return event.preventDefault(), event.stopPropagation(), machine.actions.goToOption({focus:2});
        case match(data.orientation, {vertical:"ArrowUp", horizontal:"ArrowLeft"}):
          return event.preventDefault(), event.stopPropagation(), machine.actions.goToOption({focus:1});
        case "Home":
        case "PageUp":
          return event.preventDefault(), event.stopPropagation(), machine.actions.goToOption({focus:0});
        case "End":
        case "PageDown":
          return event.preventDefault(), event.stopPropagation(), machine.actions.goToOption({focus:3});
        case "Escape":
          event.preventDefault();
          event.stopPropagation();
          (0,import_react_dom9.flushSync)(() => machine.actions.closeListbox());
          null == (_a3 = machine.state.buttonElement) || _a3.focus({preventScroll:!0});
          break;
        case "Tab":
          event.preventDefault();
          event.stopPropagation();
          (0,import_react_dom9.flushSync)(() => machine.actions.closeListbox());
          focusFrom(machine.state.buttonElement, event.shiftKey ? 2 : 4);
          break;
        default:
          1 === event.key.length && (machine.actions.search(event.key), searchDisposables.setTimeout(() => machine.actions.clearSearch(), 350));
      }
    });
    let labelledby = useSlice(machine, state => {
      var _a3;
      return null == (_a3 = state.buttonElement) ? void 0 : _a3.id;
    });
    ref = useSlot({open:0 === listboxState});
    usesOpenClosedState = mergeProps(anchor ? usesOpenClosedState() : {}, {id, ref:optionsRef, "aria-activedescendant":useSlice(machine, machine.selectors.activeDescendantId), "aria-multiselectable":1 === data.mode ? !0 : void 0, "aria-labelledby":labelledby, "aria-orientation":data.orientation, onKeyDown:handleKeyDown, role:"listbox", tabIndex:0 === listboxState ? 0 : void 0, style:{...theirProps.style, ...style, "--button-width":useElementSize(visible, buttonElement, !0).width}, ...transitionDataAttributes(transitionData)});
    optionsRef = useRender();
    handleKeyDown = (0,import_react76.useMemo)(() => 1 === data.mode ? data : {...data, isSelected}, [data, isSelected]);
    return import_react76.default.createElement(Portal, {enabled:portal ? props.static || visible : !1, ownerDocument:internalId}, import_react76.default.createElement(ListboxDataContext.Provider, {value:handleKeyDown}, optionsRef({ourProps:usesOpenClosedState, theirProps, slot:ref, defaultTag:"div", features:3, visible:ownerDocument, name:"Listbox.Options"})));
  }), ListboxOption = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-listbox-option-${internalId}`, disabled = !1, value, ...theirProps} = props, usedInSelectedOption = !0 === (0,import_react76.useContext)(SelectedOptionContext), data = useData2("Listbox.Option"), machine = useListboxMachineContext("Listbox.Option"), active = useSlice(machine, state => machine.selectors.isActive(state, id));
    props = data.isSelected(value);
    let internalOptionRef = (0,import_react76.useRef)(null), getTextValue2 = useTextValue(internalOptionRef), bag = useLatestValue({disabled, value, domRef:internalOptionRef, get textValue() {
      return getTextValue2();
    }});
    internalId = useSyncRefs(ref, internalOptionRef, el => {
      el ? data.listRef.current.set(id, el) : data.listRef.current.delete(id);
    });
    let shouldScrollIntoView = useSlice(machine, state => machine.selectors.shouldScrollIntoView(state, id));
    useIsoMorphicEffect(() => {
      if (shouldScrollIntoView) {
        return disposables().requestAnimationFrame(() => {
          var _a3, _b2;
          null == (_b2 = null == (_a3 = internalOptionRef.current) ? void 0 : _a3.scrollIntoView) || _b2.call(_a3, {block:"nearest"});
        });
      }
    }, [shouldScrollIntoView, internalOptionRef]);
    useIsoMorphicEffect(() => {
      if (!usedInSelectedOption) {
        return machine.actions.registerOption(id, bag), () => machine.actions.unregisterOption(id);
      }
    }, [bag, id, usedInSelectedOption]);
    var handleClick = useEvent(event => {
      if (disabled) {
        return event.preventDefault();
      }
      machine.actions.selectOption(value);
    });
    let handleFocus = useEvent(() => {
      if (disabled) {
        return machine.actions.goToOption({focus:5});
      }
      machine.actions.goToOption({focus:4, id});
    }), pointer = useTrackedPointer(), handleEnter = useEvent(evt => pointer.update(evt)), handleMove = useEvent(evt => {
      pointer.wasMoved(evt) && (disabled || active && 0 === machine.state.activationTrigger || machine.actions.goToOption({focus:4, id}, 0));
    }), handleLeave = useEvent(evt => {
      pointer.wasMoved(evt) && (disabled || active && 0 === machine.state.activationTrigger && machine.actions.goToOption({focus:5}));
    });
    ref = useSlot({active, focus:active, selected:props, disabled, selectedOption:props && usedInSelectedOption});
    internalId = usedInSelectedOption ? {} : {id, ref:internalId, role:"option", tabIndex:!0 === disabled ? void 0 : -1, "aria-disabled":!0 === disabled ? !0 : void 0, "aria-selected":props, disabled:void 0, onClick:handleClick, onFocus:handleFocus, onPointerEnter:handleEnter, onMouseEnter:handleEnter, onPointerMove:handleMove, onMouseMove:handleMove, onPointerLeave:handleLeave, onMouseLeave:handleLeave};
    handleClick = useRender();
    return !props && usedInSelectedOption ? null : handleClick({ourProps:internalId, theirProps, slot:ref, defaultTag:"div", name:"Listbox.Option"});
  }), ListboxSelectedOption = forwardRefWithAs(function(props, ref) {
    let {options:children, placeholder, ...theirProps} = props;
    props = {ref:useSyncRefs(ref)};
    var data = useData2("ListboxSelectedOption");
    ref = useSlot({});
    data = void 0 === data.value || null === data.value || 1 === data.mode && Array.isArray(data.value) && 0 === data.value.length;
    let render2 = useRender();
    return import_react76.default.createElement(SelectedOptionContext.Provider, {value:!0}, render2({ourProps:props, theirProps:{...theirProps, children:import_react76.default.createElement(import_react76.default.Fragment, null, placeholder && data ? placeholder : children)}, slot:ref, defaultTag:DEFAULT_SELECTED_OPTION_TAG, name:"ListboxSelectedOption"}));
  }), Listbox = Object.assign(ListboxRoot, {Button:ListboxButton, Label:ListboxLabel, Options:ListboxOptions, Option:ListboxOption, SelectedOption:ListboxSelectedOption}), import_react78 = __toESM(require("module$node_modules$react$index"), 1), import_react_dom10 = require("module$node_modules$react_dom$index"), reducers6 = {[1](state) {
    if (1 === state.menuState) {
      return state;
    }
    let buttonPositionState = state.buttonElement ? ElementPositionState.Tracked(computeVisualPosition(state.buttonElement)) : state.buttonPositionState;
    return {...state, activeItemIndex:null, pendingFocus:{focus:5}, menuState:1, buttonPositionState};
  }, [0](state, action) {
    return 0 === state.menuState ? state : {...state, __demoMode:!1, pendingFocus:action.focus, menuState:0, buttonPositionState:ElementPositionState.Idle};
  }, [2]:(state, action) => {
    var _a3, _b2, _c;
    if (1 === state.menuState) {
      return state;
    }
    let base = {...state, searchQuery:"", activationTrigger:null != (_a3 = action.trigger) ? _a3 : 1, __demoMode:!1};
    if (5 === action.focus) {
      return {...base, activeItemIndex:null};
    }
    if (4 === action.focus) {
      return {...base, activeItemIndex:state.items.findIndex(o => o.id === action.id)};
    }
    if (1 === action.focus) {
      var _d = state.activeItemIndex;
      if (null !== _d) {
        _d = state.items[_d].dataRef.current.domRef;
        var _e = calculateActiveIndex(action, {resolveItems:() => state.items, resolveActiveIndex:() => state.activeItemIndex, resolveId:item => item.id, resolveDisabled:item => item.dataRef.current.disabled});
        if (null !== _e && (_a3 = state.items[_e].dataRef.current.domRef, (null == (_b2 = _d.current) ? void 0 : _b2.previousElementSibling) === _a3.current || null === (null == (_c = _a3.current) ? void 0 : _c.previousElementSibling))) {
          return {...base, activeItemIndex:_e};
        }
      }
    } else if (2 === action.focus && (_b2 = state.activeItemIndex, null !== _b2 && (_b2 = state.items[_b2].dataRef.current.domRef, _c = calculateActiveIndex(action, {resolveItems:() => state.items, resolveActiveIndex:() => state.activeItemIndex, resolveId:item => item.id, resolveDisabled:item => item.dataRef.current.disabled}), null !== _c && (_a3 = state.items[_c].dataRef.current.domRef, (null == (_d = _b2.current) ? void 0 : _d.nextElementSibling) === _a3.current || null === (null == (_e = _a3.current) ? 
    void 0 : _e.nextElementSibling))))) {
      return {...base, activeItemIndex:_c};
    }
    let adjustedState = adjustOrderedState3(state);
    _b2 = calculateActiveIndex(action, {resolveItems:() => adjustedState.items, resolveActiveIndex:() => adjustedState.activeItemIndex, resolveId:item => item.id, resolveDisabled:item => item.dataRef.current.disabled});
    return {...base, ...adjustedState, activeItemIndex:_b2};
  }, [3]:(state, action) => {
    let offset3 = "" !== state.searchQuery ? 0 : 1, searchQuery = state.searchQuery + action.value.toLowerCase();
    action = (action = (null !== state.activeItemIndex ? state.items.slice(state.activeItemIndex + offset3).concat(state.items.slice(0, state.activeItemIndex + offset3)) : state.items).find(item => {
      var _a3;
      return (null == (_a3 = item.dataRef.current.textValue) ? void 0 : _a3.startsWith(searchQuery)) && !item.dataRef.current.disabled;
    })) ? state.items.indexOf(action) : -1;
    return -1 === action || action === state.activeItemIndex ? {...state, searchQuery} : {...state, searchQuery, activeItemIndex:action, activationTrigger:1};
  }, [4](state) {
    return "" === state.searchQuery ? state : {...state, searchQuery:"", searchActiveItemIndex:null};
  }, [5]:(state, action) => {
    let items = state.items.concat(action.items.map(item => item));
    action = state.activeItemIndex;
    5 !== state.pendingFocus.focus && (action = calculateActiveIndex(state.pendingFocus, {resolveItems:() => items, resolveActiveIndex:() => state.activeItemIndex, resolveId:item => item.id, resolveDisabled:item => item.dataRef.current.disabled}));
    return {...state, items, activeItemIndex:action, pendingFocus:{focus:5}, pendingShouldSort:!0};
  }, [6]:(state, action) => {
    let items = state.items, idxs = [];
    action = new Set(action.items);
    for (let [idx, item] of items.entries()) {
      if (action.has(item.id) && (idxs.push(idx), action.delete(item.id), 0 === action.size)) {
        break;
      }
    }
    if (0 < idxs.length) {
      items = items.slice();
      for (let idx of idxs.reverse()) {
        items.splice(idx, 1);
      }
    }
    return {...state, items, activationTrigger:1};
  }, [7]:(state, action) => state.buttonElement === action.element ? state : {...state, buttonElement:action.element}, [8]:(state, action) => state.itemsElement === action.element ? state : {...state, itemsElement:action.element}, [9]:state => state.pendingShouldSort ? {...state, ...adjustOrderedState3(state), pendingShouldSort:!1} : state, [10](state) {
    return "Tracked" !== state.buttonPositionState.kind ? state : {...state, buttonPositionState:ElementPositionState.Moved};
  }}, MenuMachine = class extends Machine {
    constructor(initialState) {
      super(initialState);
      __publicField(this, "actions", {registerItem:batch(() => {
        let items = [], seen = new Set();
        return [(id, dataRef) => {
          seen.has(dataRef) || (seen.add(dataRef), items.push({id, dataRef}));
        }, () => {
          seen.clear();
          return this.send({type:5, items:items.splice(0)});
        }];
      }), unregisterItem:batch(() => {
        let items = [];
        return [id => items.push(id), () => this.send({type:6, items:items.splice(0)})];
      })});
      __publicField(this, "selectors", {activeDescendantId(state) {
        var _a3;
        let activeItemIndex = state.activeItemIndex;
        state = state.items;
        return null === activeItemIndex ? void 0 : null == (_a3 = state[activeItemIndex]) ? void 0 : _a3.id;
      }, isActive(state, id) {
        var _a3;
        let activeItemIndex = state.activeItemIndex;
        state = state.items;
        return null !== activeItemIndex ? (null == (_a3 = state[activeItemIndex]) ? void 0 : _a3.id) === id : !1;
      }, shouldScrollIntoView(state, id) {
        return state.__demoMode || 0 !== state.menuState || 0 === state.activationTrigger ? !1 : this.isActive(state, id);
      }, didButtonMove(state) {
        return "Moved" === state.buttonPositionState.kind;
      }});
      this.on(5, () => {
        this.disposables.requestAnimationFrame(() => {
          this.send({type:9});
        });
      });
      let id = this.state.id, stackMachine = stackMachines.get(null);
      this.disposables.add(stackMachine.on(0, state => {
        stackMachine.selectors.isTop(state, id) || 0 !== this.state.menuState || this.send({type:1});
      }));
      this.on(0, () => stackMachine.actions.push(id));
      this.on(1, () => stackMachine.actions.pop(id));
      this.disposables.group(d => {
        this.on(1, state => {
          state.buttonElement && (d.dispose(), d.add(detectMovement(state.buttonElement, state.buttonPositionState, () => {
            this.send({type:10});
          })));
        });
      });
    }
    static new({id, __demoMode = !1}) {
      return new MenuMachine({id, __demoMode, menuState:__demoMode ? 0 : 1, buttonElement:null, itemsElement:null, items:[], searchQuery:"", activeItemIndex:null, activationTrigger:1, pendingShouldSort:!1, pendingFocus:{focus:5}, buttonPositionState:ElementPositionState.Idle});
    }
    reduce(state, action) {
      return match(action.type, reducers6, state, action);
    }
  }, import_react77 = require("module$node_modules$react$index"), MenuContext = (0,import_react77.createContext)(null), DEFAULT_MENU_TAG = import_react78.Fragment, DEFAULT_ITEM_TAG = import_react78.Fragment, MenuRoot = forwardRefWithAs(function(props, ref) {
    let id = (0,import_react20.useId)(), {__demoMode = !1, ...theirProps} = props, machine = useMenuMachine({id, __demoMode}), [menuState, itemsElement, buttonElement] = useSlice(machine, state => [state.menuState, state.itemsElement, state.buttonElement]);
    props = useSyncRefs(ref);
    let stackMachine = stackMachines.get(null);
    ref = useSlice(stackMachine, (0,import_react78.useCallback)(state => stackMachine.selectors.isTop(state, id), [stackMachine, id]));
    useOutsideClick(ref, [buttonElement, itemsElement], (event, target) => {
      var _a3;
      machine.send({type:1});
      isFocusableElement(target, 1) || (event.preventDefault(), null == (_a3 = machine.state.buttonElement) || _a3.focus());
    });
    ref = useEvent(() => {
      machine.send({type:1});
    });
    ref = useSlot({open:0 === menuState, close:ref});
    props = {ref:props};
    let render2 = useRender();
    return import_react78.default.createElement(FloatingProvider, null, import_react78.default.createElement(MenuContext.Provider, {value:machine}, import_react78.default.createElement(OpenClosedProvider, {value:match(menuState, {[0]:1, [1]:2})}, render2({ourProps:props, theirProps, slot:ref, defaultTag:DEFAULT_MENU_TAG, name:"Menu"}))));
  }), MenuButton = forwardRefWithAs(function(props, ref) {
    let machine = useMenuMachineContext("Menu.Button");
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-menu-button-${internalId}`, disabled = !1, autoFocus = !1, ...theirProps} = props, internalButtonRef = (0,import_react78.useRef)(null);
    internalId = (0,import_react52.useContext)(FloatingContext).getReferenceProps;
    let buttonRef = useSyncRefs(ref, internalButtonRef, useFloatingReference(), useEvent(element => machine.send({type:7, element}))), handleKeyDown = useEvent(event => {
      switch(event.key) {
        case " ":
        case "Enter":
        case "ArrowDown":
          event.preventDefault();
          event.stopPropagation();
          machine.send({type:0, focus:{focus:0}});
          break;
        case "ArrowUp":
          event.preventDefault(), event.stopPropagation(), machine.send({type:0, focus:{focus:3}});
      }
    }), handleKeyUp = useEvent(event => {
      switch(event.key) {
        case " ":
          event.preventDefault();
      }
    }), [menuState, buttonElement, itemsElement] = useSlice(machine, state => [state.menuState, state.buttonElement, state.itemsElement]);
    useQuickRelease(0 === menuState, {trigger:buttonElement, action:(0,import_react78.useCallback)(e => {
      if (null == buttonElement ? 0 : buttonElement.contains(e.target)) {
        return Action.Ignore;
      }
      let item = e.target.closest('[role\x3d"menuitem"]:not([data-disabled])');
      return isHTMLElement(item) ? Action.Select(item) : (null == itemsElement ? 0 : itemsElement.contains(e.target)) ? Action.Ignore : Action.Close;
    }, [buttonElement, itemsElement]), close:(0,import_react78.useCallback)(() => machine.send({type:1}), []), select:(0,import_react78.useCallback)(target => target.click(), [])});
    let toggleProps = useHandleToggle(event => {
      var _a3;
      disabled || (0 === menuState ? ((0,import_react_dom10.flushSync)(() => machine.send({type:1})), null == (_a3 = internalButtonRef.current) || _a3.focus({preventScroll:!0})) : (event.preventDefault(), machine.send({type:0, focus:{focus:5}, trigger:0})));
    }), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    ref = useSlot({open:0 === menuState, active:active || 0 === menuState, disabled, hover, focus, autofocus:autoFocus});
    props = mergeProps(internalId(), {ref:buttonRef, id, type:useResolveButtonType(props, internalButtonRef.current), "aria-haspopup":"menu", "aria-controls":null == itemsElement ? void 0 : itemsElement.id, "aria-expanded":0 === menuState, disabled:disabled || void 0, autoFocus, onKeyDown:handleKeyDown, onKeyUp:handleKeyUp}, toggleProps, focusProps, hoverProps, pressProps);
    return useRender()({ourProps:props, theirProps, slot:ref, defaultTag:"button", name:"Menu.Button"});
  }), MenuItems = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-menu-items-${internalId}`, anchor:rawAnchor, portal = !1, modal = !0, transition:transition2 = !1, ...theirProps} = props;
    internalId = useResolvedAnchor(rawAnchor);
    let machine = useMenuMachineContext("Menu.Items"), [floatingRef, style] = useFloatingPanel(internalId);
    var getFloatingPanelProps = useFloatingPanelProps();
    let [localItemsElement, setLocalItemsElement] = (0,import_react78.useState)(null), itemsRef = useSyncRefs(ref, internalId ? floatingRef : null, useEvent(element => machine.send({type:8, element})), setLocalItemsElement), [menuState, buttonElement] = useSlice(machine, state => [state.menuState, state.buttonElement]);
    ref = useOwnerDocument(buttonElement);
    var ownerDocument = useOwnerDocument(localItemsElement);
    internalId && (portal = !0);
    var usesOpenClosedState = useOpenClosed();
    let [visible, transitionData] = useTransition(transition2, localItemsElement, null !== usesOpenClosedState ? 1 === (usesOpenClosedState & 1) : 0 === menuState);
    useOnDisappear(visible, buttonElement, () => {
      machine.send({type:1});
    });
    usesOpenClosedState = useSlice(machine, state => state.__demoMode);
    useScrollLock(usesOpenClosedState ? !1 : modal && 0 === menuState, ownerDocument);
    useInertOthers(usesOpenClosedState ? !1 : modal && 0 === menuState, {allowed:(0,import_react78.useCallback)(() => [buttonElement, localItemsElement], [buttonElement, localItemsElement])});
    ownerDocument = useSlice(machine, machine.selectors.didButtonMove) ? !1 : visible;
    (0,import_react78.useEffect)(() => {
      localItemsElement && 0 === menuState && (isActiveElement(localItemsElement) || localItemsElement.focus({preventScroll:!0}));
    }, [menuState, localItemsElement]);
    useTreeWalker(0 === menuState, {container:localItemsElement, accept(node) {
      return "menuitem" === node.getAttribute("role") ? NodeFilter.FILTER_REJECT : node.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }, walk(node) {
      node.setAttribute("role", "none");
    }});
    let searchDisposables = useDisposables(), handleKeyDown = useEvent(event => {
      var _a3, _b2, _c;
      searchDisposables.dispose();
      switch(event.key) {
        case " ":
          if ("" !== machine.state.searchQuery) {
            return event.preventDefault(), event.stopPropagation(), machine.send({type:3, value:event.key});
          }
        case "Enter":
          event.preventDefault();
          event.stopPropagation();
          null !== machine.state.activeItemIndex && ({dataRef:event} = machine.state.items[machine.state.activeItemIndex], null == (_b2 = null == (_a3 = event.current) ? void 0 : _a3.domRef.current) || _b2.click());
          machine.send({type:1});
          restoreFocusIfNecessary(machine.state.buttonElement);
          break;
        case "ArrowDown":
          return event.preventDefault(), event.stopPropagation(), machine.send({type:2, focus:2});
        case "ArrowUp":
          return event.preventDefault(), event.stopPropagation(), machine.send({type:2, focus:1});
        case "Home":
        case "PageUp":
          return event.preventDefault(), event.stopPropagation(), machine.send({type:2, focus:0});
        case "End":
        case "PageDown":
          return event.preventDefault(), event.stopPropagation(), machine.send({type:2, focus:3});
        case "Escape":
          event.preventDefault();
          event.stopPropagation();
          (0,import_react_dom10.flushSync)(() => machine.send({type:1}));
          null == (_c = machine.state.buttonElement) || _c.focus({preventScroll:!0});
          break;
        case "Tab":
          event.preventDefault();
          event.stopPropagation();
          (0,import_react_dom10.flushSync)(() => machine.send({type:1}));
          focusFrom(machine.state.buttonElement, event.shiftKey ? 2 : 4);
          break;
        default:
          1 === event.key.length && (machine.send({type:3, value:event.key}), searchDisposables.setTimeout(() => machine.send({type:4}), 350));
      }
    }), handleKeyUp = useEvent(event => {
      switch(event.key) {
        case " ":
          event.preventDefault();
      }
    });
    usesOpenClosedState = useSlot({open:0 === menuState});
    internalId = mergeProps(internalId ? getFloatingPanelProps() : {}, {"aria-activedescendant":useSlice(machine, machine.selectors.activeDescendantId), "aria-labelledby":useSlice(machine, state => {
      var _a3;
      return null == (_a3 = state.buttonElement) ? void 0 : _a3.id;
    }), id, onKeyDown:handleKeyDown, onKeyUp:handleKeyUp, role:"menu", tabIndex:0 === menuState ? 0 : void 0, ref:itemsRef, style:{...theirProps.style, ...style, "--button-width":useElementSize(visible, buttonElement, !0).width}, ...transitionDataAttributes(transitionData)});
    getFloatingPanelProps = useRender();
    return import_react78.default.createElement(Portal, {enabled:portal ? props.static || visible : !1, ownerDocument:ref}, getFloatingPanelProps({ourProps:internalId, theirProps, slot:usesOpenClosedState, defaultTag:"div", features:3, visible:ownerDocument, name:"Menu.Items"}));
  }), MenuItem = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-menu-item-${internalId}`, disabled = !1, ...theirProps} = props, machine = useMenuMachineContext("Menu.Item"), active = useSlice(machine, state => machine.selectors.isActive(state, id)), internalItemRef = (0,import_react78.useRef)(null);
    ref = useSyncRefs(ref, internalItemRef);
    let shouldScrollIntoView = useSlice(machine, state => machine.selectors.shouldScrollIntoView(state, id));
    useIsoMorphicEffect(() => {
      if (shouldScrollIntoView) {
        return disposables().requestAnimationFrame(() => {
          var _a3, _b2;
          null == (_b2 = null == (_a3 = internalItemRef.current) ? void 0 : _a3.scrollIntoView) || _b2.call(_a3, {block:"nearest"});
        });
      }
    }, [shouldScrollIntoView, internalItemRef]);
    let getTextValue2 = useTextValue(internalItemRef), bag = (0,import_react78.useRef)({disabled, domRef:internalItemRef, get textValue() {
      return getTextValue2();
    }});
    useIsoMorphicEffect(() => {
      bag.current.disabled = disabled;
    }, [bag, disabled]);
    useIsoMorphicEffect(() => {
      machine.actions.registerItem(id, bag);
      return () => machine.actions.unregisterItem(id);
    }, [bag, id]);
    props = useEvent(() => {
      machine.send({type:1});
    });
    internalId = useEvent(event => {
      if (disabled) {
        return event.preventDefault();
      }
      machine.send({type:1});
      restoreFocusIfNecessary(machine.state.buttonElement);
    });
    let handleFocus = useEvent(() => {
      if (disabled) {
        return machine.send({type:2, focus:5});
      }
      machine.send({type:2, focus:4, id});
    }), pointer = useTrackedPointer(), handleEnter = useEvent(event => pointer.update(event)), handleMove = useEvent(event => {
      pointer.wasMoved(event) && (disabled || active || machine.send({type:2, focus:4, id, trigger:0}));
    }), handleLeave = useEvent(event => {
      pointer.wasMoved(event) && (disabled || active && 0 === machine.state.activationTrigger && machine.send({type:2, focus:5}));
    }), [labelledby, LabelProvider] = useLabels(), [describedby, DescriptionProvider] = useDescriptions();
    props = useSlot({active, focus:active, disabled, close:props});
    ref = {id, ref, role:"menuitem", tabIndex:!0 === disabled ? void 0 : -1, "aria-disabled":!0 === disabled ? !0 : void 0, "aria-labelledby":labelledby, "aria-describedby":describedby, disabled:void 0, onClick:internalId, onFocus:handleFocus, onPointerEnter:handleEnter, onMouseEnter:handleEnter, onPointerMove:handleMove, onMouseMove:handleMove, onPointerLeave:handleLeave, onMouseLeave:handleLeave};
    internalId = useRender();
    return import_react78.default.createElement(LabelProvider, null, import_react78.default.createElement(DescriptionProvider, null, internalId({ourProps:ref, theirProps, slot:props, defaultTag:DEFAULT_ITEM_TAG, name:"Menu.Item"})));
  }), MenuSection = forwardRefWithAs(function(props, ref) {
    let [labelledby, LabelProvider] = useLabels();
    ref = {ref, "aria-labelledby":labelledby, role:"group"};
    let render2 = useRender();
    return import_react78.default.createElement(LabelProvider, null, render2({ourProps:ref, theirProps:props, slot:{}, defaultTag:"div", name:"Menu.Section"}));
  }), MenuHeading = forwardRefWithAs(function(props, ref) {
    let internalId = (0,import_react20.useId)(), {id = `headlessui-menu-heading-${internalId}`, ...theirProps} = props, context = useLabelContext();
    useIsoMorphicEffect(() => context.register(id), [id, context.register]);
    props = {id, ref, role:"presentation", ...context.props};
    return useRender()({ourProps:props, theirProps, slot:{}, defaultTag:"header", name:"Menu.Heading"});
  }), MenuSeparator = forwardRefWithAs(function(props, ref) {
    ref = {ref, role:"separator"};
    return useRender()({ourProps:ref, theirProps:props, slot:{}, defaultTag:"div", name:"Menu.Separator"});
  }), Menu = Object.assign(MenuRoot, {Button:MenuButton, Items:MenuItems, Item:MenuItem, Section:MenuSection, Heading:MenuHeading, Separator:MenuSeparator}), import_react80 = __toESM(require("module$node_modules$react$index"), 1), reducers7 = {[0]:state => 0 === state.popoverState ? state : {...state, popoverState:0, __demoMode:!1}, [1](state) {
    return 1 === state.popoverState ? state : {...state, popoverState:1, __demoMode:!1};
  }, [2](state, action) {
    return state.button === action.button ? state : {...state, button:action.button};
  }, [3](state, action) {
    return state.buttonId === action.buttonId ? state : {...state, buttonId:action.buttonId};
  }, [4](state, action) {
    return state.panel === action.panel ? state : {...state, panel:action.panel};
  }, [5](state, action) {
    return state.panelId === action.panelId ? state : {...state, panelId:action.panelId};
  }}, PopoverMachine = class extends Machine {
    constructor(initialState) {
      super(initialState);
      __publicField(this, "actions", {close:() => this.send({type:1}), refocusableClose:focusableElement => {
        this.actions.close();
        let restoreElement = (() => focusableElement ? isHTMLElement(focusableElement) ? focusableElement : "current" in focusableElement && isHTMLElement(focusableElement.current) ? focusableElement.current : this.state.button : this.state.button)();
        null == restoreElement || restoreElement.focus();
      }, open:() => this.send({type:0}), setButtonId:id => this.send({type:3, buttonId:id}), setButton:button => this.send({type:2, button}), setPanelId:id => this.send({type:5, panelId:id}), setPanel:panel => this.send({type:4, panel})});
      __publicField(this, "selectors", {isPortalled:state => {
        var _a3;
        if (!state.button || !state.panel) {
          return !1;
        }
        var ownerDocument = null != (_a3 = getOwnerDocument(state.button)) ? _a3 : document;
        for (var root of ownerDocument.querySelectorAll("body \x3e *")) {
          if (Number(null == root ? void 0 : root.contains(state.button)) ^ Number(null == root ? void 0 : root.contains(state.panel))) {
            return !0;
          }
        }
        _a3 = getFocusableElements(ownerDocument);
        ownerDocument = _a3.indexOf(state.button);
        root = _a3[(ownerDocument + 1) % _a3.length];
        return state.panel.contains(_a3[(ownerDocument + _a3.length - 1) % _a3.length]) || state.panel.contains(root) ? !1 : !0;
      }});
      let id = this.state.id, stackMachine = stackMachines.get(null);
      this.on(0, () => stackMachine.actions.push(id));
      this.on(1, () => stackMachine.actions.pop(id));
    }
    static new({id, __demoMode = !1}) {
      return new PopoverMachine({id, __demoMode, popoverState:__demoMode ? 0 : 1, buttons:{current:[]}, button:null, buttonId:null, panel:null, panelId:null, beforePanelSentinel:{current:null}, afterPanelSentinel:{current:null}, afterButtonSentinel:{current:null}});
    }
    reduce(state, action) {
      return match(action.type, reducers7, state, action);
    }
  }, import_react79 = require("module$node_modules$react$index"), PopoverContext = (0,import_react79.createContext)(null), PopoverGroupContext = (0,import_react80.createContext)(null);
  PopoverGroupContext.displayName = "PopoverGroupContext";
  var PopoverPanelContext = (0,import_react80.createContext)(null);
  PopoverPanelContext.displayName = "PopoverPanelContext";
  var PopoverRoot = forwardRefWithAs(function(props, ref) {
    var _a3, id = (0,import_react20.useId)();
    let {__demoMode = !1, ...theirProps} = props, machine = usePopoverMachine({id, __demoMode}), internalPopoverRef = (0,import_react80.useRef)(null);
    props = useSyncRefs(ref, optionalRef(ref2 => {
      internalPopoverRef.current = ref2;
    }));
    let [popoverState, button, panel, buttonId, panelId] = useSlice(machine, (0,import_react80.useCallback)(state => [state.popoverState, state.button, state.panel, state.buttonId, state.panelId], []));
    ref = useRootDocument(null != (_a3 = internalPopoverRef.current) ? _a3 : button);
    let buttonIdRef = useLatestValue(buttonId), panelIdRef = useLatestValue(panelId), registerBag = (0,import_react80.useMemo)(() => ({buttonId:buttonIdRef, panelId:panelIdRef, close:machine.actions.close}), [buttonIdRef, panelIdRef, machine]), groupContext = (0,import_react80.useContext)(PopoverGroupContext), registerPopover = null == groupContext ? void 0 : groupContext.registerPopover, isFocusWithinPopoverGroup = useEvent(() => {
      var _a4, _b2;
      let activeElement2 = getActiveElement(null != (_a4 = internalPopoverRef.current) ? _a4 : button);
      return null != (_b2 = null == groupContext ? void 0 : groupContext.isFocusWithinPopoverGroup()) ? _b2 : activeElement2 && ((null == button ? void 0 : button.contains(activeElement2)) || (null == panel ? void 0 : panel.contains(activeElement2)));
    });
    (0,import_react80.useEffect)(() => null == registerPopover ? void 0 : registerPopover(registerBag), [registerPopover, registerBag]);
    let [portals, PortalWrapper] = useNestedPortals();
    _a3 = useMainTreeNode(button);
    let root = useRootContainers({mainTreeNode:_a3, portals, defaultContainers:[{get current() {
      return machine.state.button;
    }}, {get current() {
      return machine.state.panel;
    }}]});
    useEventListener(ref, "focus", event => {
      var _a4, _b2, _c, _d, _e, _f;
      event.target === window || !isHTMLorSVGElement(event.target) || 0 !== machine.state.popoverState || isFocusWithinPopoverGroup() || !machine.state.button || !machine.state.panel || root.contains(event.target) || null != (_b2 = null == (_a4 = machine.state.beforePanelSentinel.current) ? void 0 : _a4.contains) && _b2.call(_a4, event.target) || null != (_d = null == (_c = machine.state.afterPanelSentinel.current) ? void 0 : _c.contains) && _d.call(_c, event.target) || (null == (_f = null == (_e = 
      machine.state.afterButtonSentinel.current) ? void 0 : _e.contains) ? 0 : _f.call(_e, event.target)) || machine.actions.close();
    }, !0);
    useOutsideClick(0 === popoverState, root.resolveContainers, (event, target) => {
      machine.actions.close();
      isFocusableElement(target, 1) || (event.preventDefault(), null == button || button.focus());
    });
    ref = useSlot({open:0 === popoverState, close:machine.actions.refocusableClose});
    id = useSlice(machine, (0,import_react80.useCallback)(state => match(state.popoverState, {[0]:1, [1]:2}), []));
    props = {ref:props};
    let render2 = useRender();
    return import_react80.default.createElement(MainTreeProvider, {node:_a3}, import_react80.default.createElement(FloatingProvider, null, import_react80.default.createElement(PopoverPanelContext.Provider, {value:null}, import_react80.default.createElement(PopoverContext.Provider, {value:machine}, import_react80.default.createElement(CloseProvider, {value:machine.actions.refocusableClose}, import_react80.default.createElement(OpenClosedProvider, {value:id}, import_react80.default.createElement(PortalWrapper, 
    null, render2({ourProps:props, theirProps, slot:ref, defaultTag:"div", name:"Popover"}))))))));
  }), PopoverButton = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-popover-button-${internalId}`, disabled = !1, autoFocus = !1, ...theirProps} = props, machine = usePopoverMachineContext("Popover.Button"), [popoverState, isPortalled, button, buttonId, panel, panelId, afterButtonSentinel] = useSlice(machine, (0,import_react80.useCallback)(state => [state.popoverState, machine.selectors.isPortalled(state), state.button, state.buttonId, state.panel, state.panelId, state.afterButtonSentinel], [])), internalButtonRef = (0,import_react80.useRef)(null);
    internalId = `headlessui-focus-sentinel-${(0,import_react20.useId)()}`;
    var groupContext = (0,import_react80.useContext)(PopoverGroupContext);
    let closeOthers = null == groupContext ? void 0 : groupContext.closeOthers, isWithinPanel = null !== (0,import_react80.useContext)(PopoverPanelContext);
    (0,import_react80.useEffect)(() => {
      if (!isWithinPanel) {
        return machine.actions.setButtonId(id), () => machine.actions.setButtonId(null);
      }
    }, [isWithinPanel, id, machine]);
    let [uniqueIdentifier] = (0,import_react80.useState)(() => Symbol());
    var buttonRef = useSyncRefs(internalButtonRef, ref, useFloatingReference(), useEvent(button2 => {
      if (!isWithinPanel) {
        if (button2) {
          machine.state.buttons.current.push(uniqueIdentifier);
        } else {
          let idx = machine.state.buttons.current.indexOf(uniqueIdentifier);
          -1 !== idx && machine.state.buttons.current.splice(idx, 1);
        }
        1 < machine.state.buttons.current.length && console.warn("You are already using a \x3cPopover.Button /\x3e but only 1 \x3cPopover.Button /\x3e is supported.");
        button2 && machine.actions.setButton(button2);
      }
    })), withinPanelButtonRef = useSyncRefs(internalButtonRef, ref);
    let handleKeyDown = useEvent(event => {
      var _a3, _b2, _c;
      if (isWithinPanel) {
        if (1 !== machine.state.popoverState) {
          switch(event.key) {
            case " ":
            case "Enter":
              event.preventDefault(), null == (_b2 = (_a3 = event.target).click) || _b2.call(_a3), machine.actions.close(), null == (_c = machine.state.button) || _c.focus();
          }
        }
      } else {
        switch(event.key) {
          case " ":
          case "Enter":
            event.preventDefault();
            event.stopPropagation();
            1 === machine.state.popoverState ? (null == closeOthers || closeOthers(machine.state.buttonId), machine.actions.open()) : machine.actions.close();
            break;
          case "Escape":
            if (0 !== machine.state.popoverState) {
              return null == closeOthers ? void 0 : closeOthers(machine.state.buttonId);
            }
            internalButtonRef.current && (_a3 = getActiveElement(internalButtonRef.current), !_a3 || internalButtonRef.current.contains(_a3)) && (event.preventDefault(), event.stopPropagation(), machine.actions.close());
        }
      }
    }), handleKeyUp = useEvent(event => {
      isWithinPanel || " " === event.key && event.preventDefault();
    }), handleClick = useEvent(event => {
      var _a3, _b2;
      isDisabledReactIssue7711(event.currentTarget) || disabled || (isWithinPanel ? (machine.actions.close(), null == (_a3 = machine.state.button) || _a3.focus()) : (event.preventDefault(), event.stopPropagation(), 1 === machine.state.popoverState ? (null == closeOthers || closeOthers(machine.state.buttonId), machine.actions.open()) : machine.actions.close(), null == (_b2 = machine.state.button) || _b2.focus()));
    }), handleMouseDown = useEvent(event => {
      event.preventDefault();
      event.stopPropagation();
    }), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    ref = 0 === popoverState;
    groupContext = useSlot({open:ref, active:active || ref, disabled, hover, focus, autofocus:autoFocus});
    props = useResolveButtonType(props, button);
    props = isWithinPanel ? mergeProps({ref:withinPanelButtonRef, type:props, onKeyDown:handleKeyDown, onClick:handleClick, disabled:disabled || void 0, autoFocus}, focusProps, hoverProps, pressProps) : mergeProps({ref:buttonRef, id:buttonId, type:props, "aria-expanded":0 === popoverState, "aria-controls":panel ? panelId : void 0, disabled:disabled || void 0, autoFocus, onKeyDown:handleKeyDown, onKeyUp:handleKeyUp, onClick:handleClick, onMouseDown:handleMouseDown}, focusProps, hoverProps, pressProps);
    let direction = useTabDirection();
    buttonRef = useEvent(() => {
      function run() {
        0 === match(direction.current, {[0]:() => focusIn(el, 1), [1]:() => focusIn(el, 8)}) && focusIn(getFocusableElements(getRootNode(machine.state.button)).filter(el2 => "true" !== el2.dataset.headlessuiFocusGuard), match(direction.current, {[0]:4, [1]:2}), {relativeTo:machine.state.button});
      }
      if (isHTMLElement(machine.state.panel)) {
        var el = machine.state.panel;
        run();
      }
    });
    withinPanelButtonRef = useRender();
    return import_react80.default.createElement(import_react80.default.Fragment, null, withinPanelButtonRef({ourProps:props, theirProps, slot:groupContext, defaultTag:"button", name:"Popover.Button"}), ref && !isWithinPanel && isPortalled && import_react80.default.createElement(Hidden, {id:internalId, ref:afterButtonSentinel, features:2, "data-headlessui-focus-guard":!0, as:"button", type:"button", onFocus:buttonRef}));
  }), PopoverOverlay = forwardRefWithAs(BackdropFn2), PopoverBackdrop = forwardRefWithAs(BackdropFn2), PopoverPanel = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-popover-panel-${internalId}`, focus = !1, anchor:rawAnchor, portal = !1, modal = !1, transition:transition2 = !1, ...theirProps} = props, machine = usePopoverMachineContext("Popover.Panel"), isPortalled = useSlice(machine, machine.selectors.isPortalled), [popoverState, button, __demoMode, beforePanelSentinel, afterPanelSentinel] = useSlice(machine, (0,import_react80.useCallback)(state => [state.popoverState, state.button, state.__demoMode, state.beforePanelSentinel, state.afterPanelSentinel], 
    [])), beforePanelSentinelId = `headlessui-focus-sentinel-before-${internalId}`;
    internalId = `headlessui-focus-sentinel-after-${internalId}`;
    let internalPanelRef = (0,import_react80.useRef)(null);
    var anchor = useResolvedAnchor(rawAnchor);
    let [floatingRef, style] = useFloatingPanel(anchor);
    var getFloatingPanelProps = useFloatingPanelProps();
    anchor && (portal = !0);
    let [localPanelElement, setLocalPanelElement] = (0,import_react80.useState)(null);
    var panelRef = useSyncRefs(internalPanelRef, ref, anchor ? floatingRef : null, machine.actions.setPanel, setLocalPanelElement);
    ref = useOwnerDocument(button);
    var ownerDocument = useOwnerDocument(internalPanelRef.current);
    useIsoMorphicEffect(() => {
      machine.actions.setPanelId(id);
      return () => machine.actions.setPanelId(null);
    }, [id, machine]);
    var usesOpenClosedState = useOpenClosed();
    let [visible, transitionData] = useTransition(transition2, localPanelElement, null !== usesOpenClosedState ? 1 === (usesOpenClosedState & 1) : 0 === popoverState);
    useOnDisappear(visible, button, machine.actions.close);
    useScrollLock(__demoMode ? !1 : modal && visible, ownerDocument);
    usesOpenClosedState = useEvent(event => {
      var _a3;
      switch(event.key) {
        case "Escape":
          if (0 === machine.state.popoverState && internalPanelRef.current) {
            var activeElement2 = getActiveElement(internalPanelRef.current);
            if (!activeElement2 || internalPanelRef.current.contains(activeElement2)) {
              event.preventDefault(), event.stopPropagation(), machine.actions.close(), null == (_a3 = machine.state.button) || _a3.focus();
            }
          }
      }
    });
    (0,import_react80.useEffect)(() => {
      var _a3;
      props.static || 1 === popoverState && (null != (_a3 = props.unmount) ? _a3 : 1) && machine.actions.setPanel(null);
    }, [popoverState, props.unmount, props.static, machine]);
    (0,import_react80.useEffect)(() => {
      if (!__demoMode && focus && 0 === popoverState && internalPanelRef.current) {
        var activeElement2 = getActiveElement(internalPanelRef.current);
        internalPanelRef.current.contains(activeElement2) || focusIn(internalPanelRef.current, 1);
      }
    }, [__demoMode, focus, internalPanelRef.current, popoverState]);
    ownerDocument = useSlot({open:0 === popoverState, close:machine.actions.refocusableClose});
    anchor = mergeProps(anchor ? getFloatingPanelProps() : {}, {ref:panelRef, id, onKeyDown:usesOpenClosedState, onBlur:focus && 0 === popoverState ? event => {
      var _a3, _b2, _c, _d, _e;
      !(event = event.relatedTarget) || !internalPanelRef.current || null != (_a3 = internalPanelRef.current) && _a3.contains(event) || (machine.actions.close(), ((null == (_c = null == (_b2 = beforePanelSentinel.current) ? void 0 : _b2.contains) ? 0 : _c.call(_b2, event)) || (null == (_e = null == (_d = afterPanelSentinel.current) ? void 0 : _d.contains) ? 0 : _e.call(_d, event))) && event.focus({preventScroll:!0}));
    } : void 0, tabIndex:-1, style:{...theirProps.style, ...style, "--button-width":useElementSize(visible, button, !0).width}, ...transitionDataAttributes(transitionData)});
    let direction = useTabDirection();
    getFloatingPanelProps = useEvent(() => {
      function run() {
        match(direction.current, {[0]:() => {
          var _a3;
          0 !== focusIn(el, 1) || null != (_a3 = machine.state.afterPanelSentinel.current) && _a3.focus();
        }, [1]:() => {
          var _a3;
          null == (_a3 = machine.state.button) || _a3.focus({preventScroll:!0});
        }});
      }
      let el = internalPanelRef.current;
      el && run();
    });
    panelRef = useEvent(() => {
      function run() {
        match(direction.current, {[0]:() => {
          var _a3;
          if (machine.state.button) {
            var root = null != (_a3 = getRootNode(machine.state.button)) ? _a3 : document.body;
            _a3 = getFocusableElements(root);
            root = _a3.indexOf(machine.state.button);
            var before = _a3.slice(0, root + 1);
            _a3 = [..._a3.slice(root + 1), ...before];
            for (let element of _a3.slice()) {
              if ("true" === element.dataset.headlessuiFocusGuard || (null == localPanelElement ? 0 : localPanelElement.contains(element))) {
                root = _a3.indexOf(element), -1 !== root && _a3.splice(root, 1);
              }
            }
            focusIn(_a3, 1, {sorted:!1});
          }
        }, [1]:() => {
          var _a3;
          0 !== focusIn(el, 2) || null != (_a3 = machine.state.button) && _a3.focus();
        }});
      }
      let el = internalPanelRef.current;
      el && run();
    });
    usesOpenClosedState = useRender();
    return import_react80.default.createElement(ResetOpenClosedProvider, null, import_react80.default.createElement(PopoverPanelContext.Provider, {value:id}, import_react80.default.createElement(CloseProvider, {value:machine.actions.refocusableClose}, import_react80.default.createElement(Portal, {enabled:portal ? props.static || visible : !1, ownerDocument:ref}, visible && isPortalled && import_react80.default.createElement(Hidden, {id:beforePanelSentinelId, ref:beforePanelSentinel, features:2, "data-headlessui-focus-guard":!0, 
    as:"button", type:"button", onFocus:getFloatingPanelProps}), usesOpenClosedState({ourProps:anchor, theirProps, slot:ownerDocument, defaultTag:"div", features:3, visible, name:"Popover.Panel"}), visible && isPortalled && import_react80.default.createElement(Hidden, {id:internalId, ref:afterPanelSentinel, features:2, "data-headlessui-focus-guard":!0, as:"button", type:"button", onFocus:panelRef})))));
  }), PopoverGroup = forwardRefWithAs(function(props, ref) {
    let internalGroupRef = (0,import_react80.useRef)(null);
    var groupRef = useSyncRefs(internalGroupRef, ref);
    let [popovers, setPopovers] = (0,import_react80.useState)([]), unregisterPopover = useEvent(registerBag => {
      setPopovers(existing => {
        let idx = existing.indexOf(registerBag);
        return -1 !== idx ? (existing = existing.slice(), existing.splice(idx, 1), existing) : existing;
      });
    }), registerPopover = useEvent(registerBag => {
      setPopovers(existing => [...existing, registerBag]);
      return () => unregisterPopover(registerBag);
    }), isFocusWithinPopoverGroup = useEvent(() => {
      var _a3;
      let root = getRootNode(internalGroupRef.current);
      if (!root) {
        return !1;
      }
      let activeElement2 = getActiveElement(internalGroupRef.current);
      return (null == (_a3 = internalGroupRef.current) ? 0 : _a3.contains(activeElement2)) ? !0 : popovers.some(bag => {
        var _a4, _b2;
        return (null == (_a4 = root.getElementById(bag.buttonId.current)) ? void 0 : _a4.contains(activeElement2)) || (null == (_b2 = root.getElementById(bag.panelId.current)) ? void 0 : _b2.contains(activeElement2));
      });
    }), closeOthers = useEvent(buttonId => {
      for (let popover of popovers) {
        popover.buttonId.current !== buttonId && popover.close();
      }
    });
    ref = (0,import_react80.useMemo)(() => ({registerPopover, unregisterPopover, isFocusWithinPopoverGroup, closeOthers}), [registerPopover, unregisterPopover, isFocusWithinPopoverGroup, closeOthers]);
    let slot = useSlot({});
    groupRef = {ref:groupRef};
    let render2 = useRender();
    return import_react80.default.createElement(MainTreeProvider, null, import_react80.default.createElement(PopoverGroupContext.Provider, {value:ref}, render2({ourProps:groupRef, theirProps:props, slot, defaultTag:"div", name:"Popover.Group"})));
  }), Popover = Object.assign(PopoverRoot, {Button:PopoverButton, Backdrop:PopoverBackdrop, Overlay:PopoverOverlay, Panel:PopoverPanel, Group:PopoverGroup}), import_react81 = __toESM(require("module$node_modules$react$index"), 1), reducers8 = {[0](state, action) {
    action = [...state.options, {id:action.id, element:action.element, propsRef:action.propsRef}];
    return {...state, options:sortByDomNode(action, option => option.element.current)};
  }, [1](state, action) {
    let options = state.options.slice(), idx = state.options.findIndex(radio => radio.id === action.id);
    if (-1 === idx) {
      return state;
    }
    options.splice(idx, 1);
    return {...state, options};
  }}, RadioGroupDataContext = (0,import_react81.createContext)(null);
  RadioGroupDataContext.displayName = "RadioGroupDataContext";
  var RadioGroupActionsContext = (0,import_react81.createContext)(null);
  RadioGroupActionsContext.displayName = "RadioGroupActionsContext";
  var RadioGroupRoot = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)(), providedDisabled = useDisabled();
    let {id = `headlessui-radiogroup-${internalId}`, value:controlledValue, form, name, onChange:controlledOnChange, by, disabled = providedDisabled || !1, defaultValue:_defaultValue, tabIndex = 0, ...theirProps} = props, compare = useByComparator(by), [state, dispatch] = (0,import_react81.useReducer)(stateReducer3, {options:[]}), options = state.options, [labelledby, LabelProvider] = useLabels(), [describedby, DescriptionProvider] = useDescriptions(), internalRadioGroupRef = (0,import_react81.useRef)(null);
    internalId = useSyncRefs(internalRadioGroupRef, ref);
    let defaultValue = useDefaultValue(_defaultValue), [value, onChange] = useControllable(controlledValue, controlledOnChange, defaultValue), firstOption = (0,import_react81.useMemo)(() => options.find(option => option.propsRef.current.disabled ? !1 : !0), [options]), containsCheckedOption = (0,import_react81.useMemo)(() => options.some(option => compare(option.propsRef.current.value, value)), [options, value]), triggerChange = useEvent(nextValue => {
      var _a3;
      if (disabled || compare(nextValue, value)) {
        return !1;
      }
      let nextOption = null == (_a3 = options.find(option => compare(option.propsRef.current.value, nextValue))) ? void 0 : _a3.propsRef.current;
      if (null == nextOption ? 0 : nextOption.disabled) {
        return !1;
      }
      null == onChange || onChange(nextValue);
      return !0;
    });
    providedDisabled = useEvent(event => {
      if (internalRadioGroupRef.current) {
        var all = options.filter(option => !1 === option.propsRef.current.disabled).map(radio => radio.element.current);
        switch(event.key) {
          case "Enter":
            attemptSubmit(event.currentTarget);
            break;
          case "ArrowLeft":
          case "ArrowUp":
            event.preventDefault();
            event.stopPropagation();
            2 === focusIn(all, 18) && (event = options.find(option => isActiveElement(option.element.current))) && triggerChange(event.propsRef.current.value);
            break;
          case "ArrowRight":
          case "ArrowDown":
            event.preventDefault();
            event.stopPropagation();
            2 === focusIn(all, 20) && (event = options.find(option => isActiveElement(option.element.current))) && triggerChange(event.propsRef.current.value);
            break;
          case " ":
            event.preventDefault(), event.stopPropagation(), (event = options.find(option => isActiveElement(option.element.current))) && triggerChange(event.propsRef.current.value);
        }
      }
    });
    let registerOption = useEvent(option => {
      dispatch({type:0, ...option});
      return () => dispatch({type:1, id:option.id});
    });
    props = (0,import_react81.useMemo)(() => ({value, firstOption, containsCheckedOption, disabled, compare, tabIndex, ...state}), [value, firstOption, containsCheckedOption, disabled, compare, tabIndex, state]);
    ref = (0,import_react81.useMemo)(() => ({registerOption, change:triggerChange}), [registerOption, triggerChange]);
    internalId = {ref:internalId, id, role:"radiogroup", "aria-labelledby":labelledby, "aria-describedby":describedby, onKeyDown:providedDisabled};
    providedDisabled = useSlot({value});
    let reset = (0,import_react81.useCallback)(() => {
      if (void 0 !== defaultValue) {
        return triggerChange(defaultValue);
      }
    }, [triggerChange, defaultValue]), render2 = useRender();
    return import_react81.default.createElement(DescriptionProvider, {name:"RadioGroup.Description"}, import_react81.default.createElement(LabelProvider, {name:"RadioGroup.Label"}, import_react81.default.createElement(RadioGroupActionsContext.Provider, {value:ref}, import_react81.default.createElement(RadioGroupDataContext.Provider, {value:props}, null != name && import_react81.default.createElement(FormFields, {disabled, data:{[name]:value || "on"}, overrides:{type:"radio", checked:null != value}, 
    form, onReset:reset}), render2({ourProps:internalId, theirProps, slot:providedDisabled, defaultTag:"div", name:"RadioGroup"})))));
  }), RadioGroupOption = forwardRefWithAs(function(props, ref) {
    var _a3, data = useData3("RadioGroup.Option");
    let actions = useActions("RadioGroup.Option");
    var internalId = (0,import_react20.useId)();
    let {id = `headlessui-radiogroup-option-${internalId}`, value, disabled = data.disabled || !1, autoFocus = !1, ...theirProps} = props, internalOptionRef = (0,import_react81.useRef)(null);
    props = useSyncRefs(internalOptionRef, ref);
    let [labelledby, LabelProvider] = useLabels(), [describedby, DescriptionProvider] = useDescriptions(), propsRef = useLatestValue({value, disabled});
    useIsoMorphicEffect(() => actions.registerOption({id, element:internalOptionRef, propsRef}), [id, actions, internalOptionRef, propsRef]);
    ref = useEvent(event => {
      var _a4;
      if (isDisabledReactIssue7711(event.currentTarget)) {
        return event.preventDefault();
      }
      actions.change(value) && (null == (_a4 = internalOptionRef.current) || _a4.focus());
    });
    internalId = (null == (_a3 = data.firstOption) ? void 0 : _a3.id) === id;
    let {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled});
    _a3 = data.compare(data.value, value);
    data = mergeProps({ref:props, id, role:"radio", "aria-checked":_a3 ? "true" : "false", "aria-labelledby":labelledby, "aria-describedby":describedby, "aria-disabled":disabled ? !0 : void 0, tabIndex:disabled ? -1 : _a3 || !data.containsCheckedOption && internalId ? data.tabIndex : -1, onClick:disabled ? void 0 : ref, autoFocus}, focusProps, hoverProps);
    _a3 = useSlot({checked:_a3, disabled, active:focus, hover, focus, autofocus:autoFocus});
    props = useRender();
    return import_react81.default.createElement(DescriptionProvider, {name:"RadioGroup.Description"}, import_react81.default.createElement(LabelProvider, {name:"RadioGroup.Label"}, props({ourProps:data, theirProps, slot:_a3, defaultTag:"div", name:"RadioGroup.Option"})));
  }), Radio = forwardRefWithAs(function(props, ref) {
    var _a3, data = useData3("Radio");
    let actions = useActions("Radio");
    var internalId = (0,import_react20.useId)(), providedId = useProvidedId(), providedDisabled = useDisabled();
    let {id = providedId || `headlessui-radio-${internalId}`, value, disabled = data.disabled || providedDisabled || !1, autoFocus = !1, ...theirProps} = props, internalRadioRef = (0,import_react81.useRef)(null);
    props = useSyncRefs(internalRadioRef, ref);
    ref = useLabelledBy();
    internalId = useDescribedBy();
    let propsRef = useLatestValue({value, disabled});
    useIsoMorphicEffect(() => actions.registerOption({id, element:internalRadioRef, propsRef}), [id, actions, internalRadioRef, propsRef]);
    providedId = useEvent(event => {
      var _a4;
      if (isDisabledReactIssue7711(event.currentTarget)) {
        return event.preventDefault();
      }
      actions.change(value) && (null == (_a4 = internalRadioRef.current) || _a4.focus());
    });
    let {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled});
    providedDisabled = (null == (_a3 = data.firstOption) ? void 0 : _a3.id) === id;
    _a3 = data.compare(data.value, value);
    data = mergeProps({ref:props, id, role:"radio", "aria-checked":_a3 ? "true" : "false", "aria-labelledby":ref, "aria-describedby":internalId, "aria-disabled":disabled ? !0 : void 0, tabIndex:disabled ? -1 : _a3 || !data.containsCheckedOption && providedDisabled ? data.tabIndex : -1, autoFocus, onClick:disabled ? void 0 : providedId}, focusProps, hoverProps);
    _a3 = useSlot({checked:_a3, disabled, hover, focus, autofocus:autoFocus});
    return useRender()({ourProps:data, theirProps, slot:_a3, defaultTag:"span", name:"Radio"});
  }), RadioGroupLabel = Label, RadioGroupDescription = Description, RadioGroup = Object.assign(RadioGroupRoot, {Option:RadioGroupOption, Radio, Label:RadioGroupLabel, Description:RadioGroupDescription}), Select = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let providedId = useProvidedId(), providedDisabled = useDisabled(), {id = providedId || `headlessui-select-${internalId}`, disabled = providedDisabled || !1, invalid = !1, autoFocus = !1, ...theirProps} = props;
    props = useLabelledBy();
    internalId = useDescribedBy();
    let {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    ref = mergeProps({ref, id, "aria-labelledby":props, "aria-describedby":internalId, "aria-invalid":invalid ? "true" : void 0, disabled:disabled || void 0, autoFocus}, focusProps, hoverProps, pressProps);
    props = useSlot({disabled, invalid, hover, focus, active, autofocus:autoFocus});
    return useRender()({ourProps:ref, theirProps, slot:props, defaultTag:"select", name:"Select"});
  }), import_react82 = __toESM(require("module$node_modules$react$index"), 1), GroupContext = (0,import_react82.createContext)(null);
  GroupContext.displayName = "GroupContext";
  var DEFAULT_GROUP_TAG3 = import_react82.Fragment, SwitchRoot = forwardRefWithAs(function(props, ref) {
    var _a3, internalId = (0,import_react20.useId)(), providedId = useProvidedId(), providedDisabled = useDisabled();
    let {id = providedId || `headlessui-switch-${internalId}`, disabled = providedDisabled || !1, checked:controlledChecked, defaultChecked:_defaultChecked, onChange:controlledOnChange, name, value, form, autoFocus = !1, ...theirProps} = props;
    internalId = (0,import_react82.useContext)(GroupContext);
    let [switchElement, setSwitchElement] = (0,import_react82.useState)(null);
    providedId = (0,import_react82.useRef)(null);
    let switchRef = useSyncRefs(providedId, ref, null === internalId ? null : internalId.setSwitch, setSwitchElement), defaultChecked = useDefaultValue(_defaultChecked), [checked, onChange] = useControllable(controlledChecked, controlledOnChange, null != defaultChecked ? defaultChecked : !1), d = useDisposables(), [changing, setChanging] = (0,import_react82.useState)(!1), toggle = useEvent(() => {
      setChanging(!0);
      null == onChange || onChange(!checked);
      d.nextFrame(() => {
        setChanging(!1);
      });
    });
    internalId = useEvent(event => {
      if (isDisabledReactIssue7711(event.currentTarget)) {
        return event.preventDefault();
      }
      event.preventDefault();
      toggle();
    });
    providedId = useEvent(event => {
      " " === event.key ? (event.preventDefault(), toggle()) : "Enter" === event.key && attemptSubmit(event.currentTarget);
    });
    providedDisabled = useEvent(event => event.preventDefault());
    let labelledBy = useLabelledBy(), describedBy = useDescribedBy(), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled});
    ref = useSlot({checked, disabled, hover, focus, active, autofocus:autoFocus, changing});
    props = mergeProps({id, ref:switchRef, role:"switch", type:useResolveButtonType(props, switchElement), tabIndex:-1 === props.tabIndex ? 0 : null != (_a3 = props.tabIndex) ? _a3 : 0, "aria-checked":checked, "aria-labelledby":labelledBy, "aria-describedby":describedBy, disabled:disabled || void 0, autoFocus, onClick:internalId, onKeyUp:providedId, onKeyPress:providedDisabled}, focusProps, hoverProps, pressProps);
    _a3 = (0,import_react82.useCallback)(() => {
      if (void 0 !== defaultChecked) {
        return null == onChange ? void 0 : onChange(defaultChecked);
      }
    }, [onChange, defaultChecked]);
    internalId = useRender();
    return import_react82.default.createElement(import_react82.default.Fragment, null, null != name && import_react82.default.createElement(FormFields, {disabled, data:{[name]:value || "on"}, overrides:{type:"checkbox", checked}, form, onReset:_a3}), internalId({ourProps:props, theirProps, slot:ref, defaultTag:"button", name:"Switch"}));
  }), SwitchGroup = function(props) {
    var _a3;
    let [switchElement, setSwitchElement] = (0,import_react82.useState)(null), [labelledby, LabelProvider] = useLabels(), [describedby, DescriptionProvider] = useDescriptions(), context = (0,import_react82.useMemo)(() => ({switch:switchElement, setSwitch:setSwitchElement}), [switchElement, setSwitchElement]), render2 = useRender();
    return import_react82.default.createElement(DescriptionProvider, {name:"Switch.Description", value:describedby}, import_react82.default.createElement(LabelProvider, {name:"Switch.Label", value:labelledby, props:{htmlFor:null == (_a3 = context.switch) ? void 0 : _a3.id, onClick(event) {
      switchElement && (isHTMLLabelElement(event.currentTarget) && event.preventDefault(), switchElement.click(), switchElement.focus({preventScroll:!0}));
    }}}, import_react82.default.createElement(GroupContext.Provider, {value:context}, render2({ourProps:{}, theirProps:props, slot:{}, defaultTag:DEFAULT_GROUP_TAG3, name:"Switch.Group"}))));
  }, SwitchLabel = Label, SwitchDescription = Description, Switch = Object.assign(SwitchRoot, {Group:SwitchGroup, Label:SwitchLabel, Description:SwitchDescription}), import_react84 = __toESM(require("module$node_modules$react$index"), 1), import_react83 = __toESM(require("module$node_modules$react$index"), 1), React36 = __toESM(require("module$node_modules$react$index"), 1), StableCollectionContext = React36.createContext(null), reducers9 = {[0](state, action) {
    let tabs = sortByDomNode(state.tabs, tab => tab.current);
    var panels = sortByDomNode(state.panels, panel => panel.current);
    let focusableTabs = tabs.filter(tab => {
      var _a4;
      return !(null == (_a4 = tab.current) ? 0 : _a4.hasAttribute("disabled"));
    });
    panels = {...state, tabs, panels};
    if (0 > action.index || action.index > tabs.length - 1) {
      var _a3 = match(Math.sign(action.index - state.selectedIndex), {[-1]:() => 1, [0]:() => match(Math.sign(action.index), {[-1]:() => 0, [0]:() => 0, [1]:() => 1}), [1]:() => 0});
      if (0 === focusableTabs.length) {
        return panels;
      }
      _a3 = match(_a3, {[0]:() => tabs.indexOf(focusableTabs[0]), [1]:() => tabs.indexOf(focusableTabs[focusableTabs.length - 1])});
      return {...panels, selectedIndex:-1 === _a3 ? state.selectedIndex : _a3};
    }
    var before = tabs.slice(0, action.index);
    before = [...tabs.slice(action.index), ...before].find(tab => focusableTabs.includes(tab));
    if (!before) {
      return panels;
    }
    before = null != (_a3 = tabs.indexOf(before)) ? _a3 : state.selectedIndex;
    -1 === before && (before = state.selectedIndex);
    return {...panels, selectedIndex:before};
  }, [1](state, action) {
    if (state.tabs.includes(action.tab)) {
      return state;
    }
    let activeTab = state.tabs[state.selectedIndex];
    action = sortByDomNode([...state.tabs, action.tab], tab => tab.current);
    let selectedIndex = state.selectedIndex;
    state.info.current.isControlled || (selectedIndex = action.indexOf(activeTab), -1 === selectedIndex && (selectedIndex = state.selectedIndex));
    return {...state, tabs:action, selectedIndex};
  }, [2](state, action) {
    return {...state, tabs:state.tabs.filter(tab => tab !== action.tab)};
  }, [3](state, action) {
    return state.panels.includes(action.panel) ? state : {...state, panels:sortByDomNode([...state.panels, action.panel], panel => panel.current)};
  }, [4](state, action) {
    return {...state, panels:state.panels.filter(panel => panel !== action.panel)};
  }}, TabsDataContext = (0,import_react84.createContext)(null);
  TabsDataContext.displayName = "TabsDataContext";
  var TabsActionsContext = (0,import_react84.createContext)(null);
  TabsActionsContext.displayName = "TabsActionsContext";
  var TabRoot = forwardRefWithAs(function(props, ref) {
    var _a3, _b2, internalId = (0,import_react20.useId)();
    let {id = `headlessui-tabs-tab-${internalId}`, disabled = !1, autoFocus = !1, ...theirProps} = props, {orientation, activation, selectedIndex, tabs, panels} = useData4("Tab"), actions = useActions2("Tab"), data = useData4("Tab"), [tabElement, setTabElement] = (0,import_react84.useState)(null), internalTabRef = (0,import_react84.useRef)(null);
    ref = useSyncRefs(internalTabRef, ref, setTabElement);
    useIsoMorphicEffect(() => actions.registerTab(internalTabRef), [actions, internalTabRef]);
    internalId = useStableCollectionIndex("tabs");
    let myIndex = tabs.indexOf(internalTabRef);
    -1 === myIndex && (myIndex = internalId);
    internalId = myIndex === selectedIndex;
    let activateUsing = useEvent(cb => {
      cb = cb();
      if (2 === cb && "auto" === activation) {
        let newTab = getActiveElement(internalTabRef.current), idx = data.tabs.findIndex(tab => tab.current === newTab);
        -1 !== idx && actions.change(idx);
      }
      return cb;
    }), handleKeyDown = useEvent(event => {
      let list = tabs.map(tab => tab.current).filter(Boolean);
      if (" " === event.key || "Enter" === event.key) {
        event.preventDefault(), event.stopPropagation(), actions.change(myIndex);
      } else {
        switch(event.key) {
          case "Home":
          case "PageUp":
            return event.preventDefault(), event.stopPropagation(), activateUsing(() => focusIn(list, 1));
          case "End":
          case "PageDown":
            return event.preventDefault(), event.stopPropagation(), activateUsing(() => focusIn(list, 8));
        }
        if (2 === activateUsing(() => match(orientation, {vertical() {
          return "ArrowUp" === event.key ? focusIn(list, 18) : "ArrowDown" === event.key ? focusIn(list, 20) : 0;
        }, horizontal() {
          return "ArrowLeft" === event.key ? focusIn(list, 18) : "ArrowRight" === event.key ? focusIn(list, 20) : 0;
        }}))) {
          return event.preventDefault();
        }
      }
    }), ready = (0,import_react84.useRef)(!1), handleSelection = useEvent(() => {
      var _a4;
      ready.current || (ready.current = !0, null == (_a4 = internalTabRef.current) || _a4.focus({preventScroll:!0}), actions.change(myIndex), microTask(() => {
        ready.current = !1;
      }));
    }), handleMouseDown = useEvent(event => {
      event.preventDefault();
    }), {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled}), {pressed:active, pressProps} = useActivePress({disabled}), slot = useSlot({selected:internalId, hover, active, focus, autofocus:autoFocus, disabled});
    props = mergeProps({ref, onKeyDown:handleKeyDown, onMouseDown:handleMouseDown, onClick:handleSelection, id, role:"tab", type:useResolveButtonType(props, tabElement), "aria-controls":null == (_b2 = null == (_a3 = panels[myIndex]) ? void 0 : _a3.current) ? void 0 : _b2.id, "aria-selected":internalId, tabIndex:internalId ? 0 : -1, disabled:disabled || void 0, autoFocus}, focusProps, hoverProps, pressProps);
    return useRender()({ourProps:props, theirProps, slot, defaultTag:"button", name:"Tabs.Tab"});
  }), TabGroup = forwardRefWithAs(function(props, ref) {
    let {defaultIndex = 0, vertical = !1, manual = !1, onChange, selectedIndex = null, ...theirProps} = props;
    const orientation = vertical ? "vertical" : "horizontal", activation = manual ? "manual" : "auto";
    let isControlled = null !== selectedIndex;
    var info = useLatestValue({isControlled}), tabsRef = useSyncRefs(ref);
    let [state, dispatch] = (0,import_react84.useReducer)(stateReducer4, {info, selectedIndex:null != selectedIndex ? selectedIndex : defaultIndex, tabs:[], panels:[]});
    info = useSlot({selectedIndex:state.selectedIndex});
    let onChangeRef = useLatestValue(onChange || (() => {
    })), stableTabsRef = useLatestValue(state.tabs);
    ref = (0,import_react84.useMemo)(() => ({orientation, activation, ...state}), [orientation, activation, state]);
    let registerTab = useEvent(tab => {
      dispatch({type:1, tab});
      return () => dispatch({type:2, tab});
    }), registerPanel = useEvent(panel => {
      dispatch({type:3, panel});
      return () => dispatch({type:4, panel});
    }), change = useEvent(index3 => {
      realSelectedIndex.current !== index3 && onChangeRef.current(index3);
      isControlled || dispatch({type:0, index:index3});
    }), realSelectedIndex = useLatestValue(isControlled ? props.selectedIndex : state.selectedIndex);
    props = (0,import_react84.useMemo)(() => ({registerTab, registerPanel, change}), []);
    useIsoMorphicEffect(() => {
      dispatch({type:0, index:null != selectedIndex ? selectedIndex : defaultIndex});
    }, [selectedIndex]);
    useIsoMorphicEffect(() => {
      if (void 0 !== realSelectedIndex.current && !(0 >= state.tabs.length)) {
        var sorted = sortByDomNode(state.tabs, tab => tab.current);
        sorted.some((tab, i) => state.tabs[i] !== tab) && change(sorted.indexOf(state.tabs[realSelectedIndex.current]));
      }
    });
    tabsRef = {ref:tabsRef};
    let render2 = useRender();
    return import_react84.default.createElement(StableCollection, null, import_react84.default.createElement(TabsActionsContext.Provider, {value:props}, import_react84.default.createElement(TabsDataContext.Provider, {value:ref}, 0 >= ref.tabs.length && import_react84.default.createElement(FocusSentinel, {onFocus:() => {
      var _a3, _b2;
      for (let tab of stableTabsRef.current) {
        if (0 === (null == (_a3 = tab.current) ? void 0 : _a3.tabIndex)) {
          return null == (_b2 = tab.current) || _b2.focus(), !0;
        }
      }
      return !1;
    }}), render2({ourProps:tabsRef, theirProps, slot:info, defaultTag:"div", name:"Tabs"}))));
  }), TabList = forwardRefWithAs(function(props, ref) {
    let {orientation, selectedIndex} = useData4("Tab.List");
    var listRef = useSyncRefs(ref);
    ref = useSlot({selectedIndex});
    listRef = {ref:listRef, role:"tablist", "aria-orientation":orientation};
    return useRender()({ourProps:listRef, theirProps:props, slot:ref, defaultTag:"div", name:"Tabs.List"});
  }), TabPanels = forwardRefWithAs(function(props, ref) {
    var {selectedIndex} = useData4("Tab.Panels");
    ref = useSyncRefs(ref);
    selectedIndex = useSlot({selectedIndex});
    ref = {ref};
    return useRender()({ourProps:ref, theirProps:props, slot:selectedIndex, defaultTag:"div", name:"Tabs.Panels"});
  }), TabPanel = forwardRefWithAs(function(props, ref) {
    var _a3, _b2, _c, _d, internalId = (0,import_react20.useId)();
    let {id = `headlessui-tabs-panel-${internalId}`, tabIndex = 0, ...theirProps} = props, {selectedIndex, tabs, panels} = useData4("Tab.Panel"), actions = useActions2("Tab.Panel"), internalPanelRef = (0,import_react84.useRef)(null);
    internalId = useSyncRefs(internalPanelRef, ref);
    useIsoMorphicEffect(() => actions.registerPanel(internalPanelRef), [actions, internalPanelRef]);
    props = useStableCollectionIndex("panels");
    let myIndex = panels.indexOf(internalPanelRef);
    -1 === myIndex && (myIndex = props);
    props = myIndex === selectedIndex;
    let {isFocusVisible:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f();
    ref = useSlot({selected:props, focus});
    internalId = mergeProps({ref:internalId, id, role:"tabpanel", "aria-labelledby":null == (_b2 = null == (_a3 = tabs[myIndex]) ? void 0 : _a3.current) ? void 0 : _b2.id, tabIndex:props ? tabIndex : -1}, focusProps);
    _a3 = useRender();
    return props || null != (_c = theirProps.unmount) && !_c || null != (_d = theirProps.static) && _d ? _a3({ourProps:internalId, theirProps, slot:ref, defaultTag:"div", features:3, visible:props, name:"Tabs.Panel"}) : import_react84.default.createElement(Hidden, {"aria-hidden":"true", ...internalId});
  }), Tab = Object.assign(TabRoot, {Group:TabGroup, List:TabList, Panels:TabPanels, Panel:TabPanel}), Textarea = forwardRefWithAs(function(props, ref) {
    var internalId = (0,import_react20.useId)();
    let providedId = useProvidedId(), providedDisabled = useDisabled(), {id = providedId || `headlessui-textarea-${internalId}`, disabled = providedDisabled || !1, autoFocus = !1, invalid = !1, ...theirProps} = props;
    props = useLabelledBy();
    internalId = useDescribedBy();
    let {isFocused:focus, focusProps} = $f7dceffc5ad7768b$export$4e328f61c538687f({autoFocus}), {isHovered:hover, hoverProps} = $6179b936705e76d3$export$ae780daf29e6d456({isDisabled:disabled});
    ref = mergeProps({ref, id, "aria-labelledby":props, "aria-describedby":internalId, "aria-invalid":invalid ? "true" : void 0, disabled:disabled || void 0, autoFocus}, focusProps, hoverProps);
    props = useSlot({disabled, invalid, hover, focus, autofocus:autoFocus});
    return useRender()({ourProps:ref, theirProps, slot:props, defaultTag:"textarea", name:"Textarea"});
  });
};

//# sourceMappingURL=module$node_modules$$headlessui$react$dist$headlessui_dev_cjs.js.map
